!!VERSION 1.2

Library "Bitwise" by "Hyper"
{
    public long Set(long @base, uint offset, bool isOffsetBitIndex = true)
    {
        return @base | (isOffsetBitIndex ? (1L << (int)offset) : offset);
    }

    public long Reset(long @base, uint offset, bool isOffsetBitIndex = true)
    {
        return @base & (isOffsetBitIndex ? (1L << (int)offset) : offset);
    }

    public bool Test(long @base, uint offset, bool isOffsetBitIndex = true)
    {
        return (@base & (isOffsetBitIndex ? (1L << (int)offset) : offset)) != 0;
    }
}

Library "Blackboard" by "Hyper, ĐeäTh & Sajid"
{
    #lib "Collections"
    #lib "StringMapOperation"

    using System.Runtime.InteropServices;

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate uint _tGetNameHash();

    public long GetBlackboardFromPlayer(long player)
    {
        if (player == 0)
            return 0;

        long gocPlayerBlackboard = GameObject.GetGOC(player, "GOCPlayerBlackboard");

        if (gocPlayerBlackboard == 0)
            return 0;

        // app::player::GOCPlayerBlackboard->pBlackboard = 0x80
        return Read<long>(gocPlayerBlackboard + 0x80);
    }

    public long GetBlackboardContent(long blackboard, string name)
    {
        if (blackboard == 0)
            return 0;

        // csl::ut::MoveArray<BlackboardContent*> m_Blackboards = 0x18
        var blackboards = Read<Collections.MoveArray<IntPtr>>(blackboard + 0x18);

        for (int i = 0; i < blackboards.Length; i++)
        {
            IntPtr blackboardContent = blackboards[i];

            if (blackboardContent == IntPtr.Zero)
                continue;

            var fpGetNameHash = Marshal.GetDelegateForFunctionPointer<_tGetNameHash>(Read<IntPtr>(Read<IntPtr>(blackboardContent) + 1 * IntPtr.Size));
            
            if (fpGetNameHash() == StringMapOperation.ComputeHash(name))
            {
                return (long)blackboardContent;
            }
        }

        return 0;
    }
}

Library "BlackboardItem" by "Hyper"
{
    #lib "Blackboard"
    #lib "GameDocument"
    #lib "GameObject"

    public long Get(long blackboard = 0)
    {
        if (blackboard == 0)
        {
            long sonic = GameDocument.GetGameObject("Sonic");
            
            if (sonic == 0)
                return 0;

            blackboard = Blackboard.GetBlackboardFromPlayer(sonic);

            if (blackboard == 0)
                return 0;
        }

        return Blackboard.GetBlackboardContent(blackboard, "BlackboardItem");
    }

    public int GetRingCount(long blackboardItem = 0)
    {
        if (blackboardItem == 0 && (blackboardItem = Get()) == 0)
            return 0;

        return Read<int>(blackboardItem + 0x28);
    }

    public void SetRingCount(int count)
    {
        if (Get() == 0)
            return;

        WriteProtected<int>(Get() + 0x28, count);
    }
}

Library "BlackboardStatus" by "Hyper"
{
    #lib "Bitwise"
    #lib "Blackboard"
    #lib "GameDocument"
    #lib "GameObject"

    public enum StateFlags
    {
        IsBoost = 0x00,
        IsRecoveryJump = 0x02,
        IsAirBoost = 0x04,
        IsGrindJump = 0x06,
        IsGrind = 0x07,
        IsJump = 0x08,
        IsDoubleJump = 0x09,
        IsBounceJump = 0x0A,
        IsFall = 0x0B,
        IsStomp = 0x0C,
        IsDiving = 0x0D,
        IsDivingBoost = 0x0E,
        IsCyloop = 0x11,
        IsCyloopEnd = 0x12,
        IsDrift = 0x13,
        IsDriftDash = 0x14,
        IsHoming = 0x17,
        IsParry = 0x18,
        IsWallClimb = 0x19,
        IsIdle = 0x1A,
        IsBoarding = 0x1E,
        IsSpringJump = 0x21,
        IsPhantomRush = 0x26
    }

    public enum WorldFlags
    {
        IsAutoRun = 0x0A,
        IsCyberSpace = 0x1D,
        IsPowerBoost = 0x26,
        IsHeightMapCollision = 0x31
    }

    public long Get(long blackboard = 0)
    {
        if (blackboard == 0)
        {
            long sonic = GameDocument.GetGameObject("Sonic");
            
            if (sonic == 0)
                return 0;

            blackboard = Blackboard.GetBlackboardFromPlayer(sonic);

            if (blackboard == 0)
                return 0;
        }

        return Blackboard.GetBlackboardContent(blackboard, "BlackboardStatus");
    }

    public bool IsSuper(long blackboardStatus = 0)
    {
        if (blackboardStatus == 0 && (blackboardStatus = Get()) == 0)
            return false;

        return Read<bool>(blackboardStatus + 0x24);
    }

    public bool IsCyberSpace(long blackboardStatus = 0)
    {
        if (blackboardStatus == 0 && (blackboardStatus = Get()) == 0)
            return false;

        return Bitwise.Test(*GetWorldFlags(), (uint)WorldFlags.IsCyberSpace);
    }

    public long* GetFieldPointer(long blackboardStatus = 0, long fieldOffset = 0)
    {
        if (blackboardStatus == 0 && (blackboardStatus = Get()) == 0)
            return null;

        return (long*)new IntPtr(blackboardStatus + fieldOffset).ToPointer();
    }

    public long* GetStateFlags(long blackboardStatus = 0)
    {
        return GetFieldPointer(blackboardStatus, 0x30);
    }

    public long* GetWorldFlags(long blackboardStatus = 0)
    {
        return GetFieldPointer(blackboardStatus, 0x38);
    }
}

Library "Collections" by "Sajid & Hyper"
{
    using System.Collections.Generic;

    public unsafe struct MoveArray<T> where T : unmanaged
    {
        public T* Items;
        public int Length;
        public int Capacity;
        public void* Allocator;
        
        public int Count => Length;    

        public ref T this[int index]
        {
            get => ref Items[index];
        }
    }

    public class StackList<T> : List<T>
    {
        private int _maxCapacity;

        public StackList(int maxCapacity)
        {
            _maxCapacity = maxCapacity;
        }

        public new void Add(T item)
        {
            if (Count >= _maxCapacity)
            {
                RemoveAt(Count - 1);
            }

            Insert(0, item);
        }

        public T GetItemAt(int index)
        {
            if (Count == 0)
                return default;

            if (index >= Count)
            {
                return this[Count - 1];
            }

            return this[index];
        }

        public void Push(T item)
        {
            Add(item);
        }

        public T Pop()
        {
            T item = GetItemAt(0);

            RemoveAt(0);

            return item;
        }

        public T Peek()
        {
            return GetItemAt(0);
        }
    }
}

Library "Converse" by "Hyper & M&M"
{
    #include "Helpers" noemit

    #lib "Memory"

    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Text.RegularExpressions;

    private static bool _isInitialised = false;

    public enum Language : sbyte
    {
        Unknown = -1,
        English,
        French,
        Italian,
        German,
        Spanish,
        Polish,
        Portuguese,
        Russian,
        Japanese,
        ChineseTraditional,
        ChineseSimplified,
        Korean
    }

    private static sbyte _language = -1;

    public class ReplacementString
    {
        public string Pattern { get; set; }

        public string Replacement { get; set; }

        public bool IsRegex { get; set; }

        public ReplacementString(string in_pattern, string in_replacement, bool in_isRegex)
        {
            Pattern = in_pattern;
            Replacement = in_replacement;
            IsRegex = in_isRegex;
        }
    }

    private static Dictionary<string, string> _redirectedStrings = new();
    private static List<ReplacementString> _replacementStrings = new();

    public delegate string TConverseNotifyAction(string key, string text);
    private static List<TConverseNotifyAction> _converseNotifyActions = new();

    UNMANAGED_FUNCTION(long, RedirectString, long pCnvrsKey, long pCnvrsText, int cnvrsTextLength)
    {
        if (pCnvrsKey == 0)
            return pCnvrsText;

        string cnvrsKey = Marshal.PtrToStringAnsi((IntPtr)pCnvrsKey);
        string cnvrsText = pCnvrsText == 0 ? string.Empty : Marshal.PtrToStringUni((IntPtr)pCnvrsText);
        IntPtr pData = IntPtr.Zero;

        void MarshalString(string str)
        {
            int length = sizeof(int) + ((str.Length + 1) * sizeof(short));

            pData = Marshal.AllocHGlobal(length);

            var wideTextStart = pData + sizeof(int);
            var wideText = Encoding.Unicode.GetBytes(str);
            var wideTextEnd = wideTextStart + wideText.Length;
            
            Marshal.Copy(wideText, 0, wideTextStart, wideText.Length);
            
            // Null terminator.
            Marshal.WriteInt16(wideTextEnd, 0);

            pCnvrsText = (long)pData;
            cnvrsTextLength = length;
        }

        string redirectResult = cnvrsText;
        {
            foreach (var entry in _redirectedStrings)
            {
                if (entry.Key == cnvrsKey)
                    redirectResult = entry.Value;
            }

            if (redirectResult != cnvrsText)
                MarshalString(redirectResult);
        }

        string notifyResult = redirectResult;
        {
            foreach (var action in _converseNotifyActions)
                notifyResult = action(cnvrsKey, notifyResult);

            if (notifyResult != cnvrsText)
                MarshalString(notifyResult);
        }

        foreach (var entry in _replacementStrings)
        {
            string replacementResult = notifyResult;

            if (entry.IsRegex)
            {
                replacementResult = new Regex(entry.Pattern).Replace(notifyResult, entry.Replacement);
            }
            else
            {
                replacementResult = notifyResult.Replace(entry.Pattern, entry.Replacement);
            }

            if (replacementResult != cnvrsText)
                MarshalString(replacementResult);
        }

        if (pData != IntPtr.Zero)
        {
            // Wide string length.
            Marshal.WriteInt32(pData, cnvrsTextLength);
            Marshal.FreeHGlobal(pData);
        }
        else if (pCnvrsText != 0)
        {
            /* No need to reallocate all strings,
               return -1 and reload original pointer. */
            pCnvrsText = -1;
        }

        return pCnvrsText;
    }

    private void Init()
    {
        if (_isInitialised)
            return;

        void ConverseHook(long addr)
        {
            WriteAsmHook
            (
                $@"
                    mov  r8d, dword ptr [rsp + 0x1C8 + 0xFFFFFFFFFFFFFE60]
                    mov  rcx, rsi
                    mov  rax, {GET_UNMANAGED_FUNCTION_PTR(RedirectString)}
                    call rax
                    cmp  rax, 0
                    jne  notNull
                    mov  rdx, {(long)Marshal.StringToHGlobalUni(" ")}
                    mov  r8d, 1
                    jmp  exit
                notNull:
                    cmp  rax, -1
                    je   notCustom
                    lea  rdx, qword ptr [rax + 4]
                    mov  r8d, dword ptr [rax]
                    jmp  exit
                notCustom:
                    mov  rdx, qword ptr [rsp + 0x1C8 + 0xFFFFFFFFFFFFFE58]
                    mov  r8d, dword ptr [rsp + 0x1C8 + 0xFFFFFFFFFFFFFE60]
                exit:
                    mov  rcx, qword ptr [rdi + 8]
                    mov  rax, {Memory.ReadCall(addr + 0x09)}
                    call rax
                ",

                addr,

                HookBehavior.Replace
            );
        }

        WriteNop
        (
            /* 0x14DA9000D */
            ScanSignature
            (
                "\x0F\x84\xE8\x00\x00\x00\x48\x8D\x8F\xC8\x00\x00\x00",
                "xxxxxxxxxxxxx"
            ),
            
            6
        );

        ConverseHook
        (
            /* 0x14DA90041 */
            ScanSignature
            (
                "\x44\x8B\x44\x24\x28\x48\x8B\x4F\x08\xE8\xCC\xCC\xCC\xCC\x48\x89\xC2\x48\x8B\x8F\xF0\x00\x00\x00",
                "xxxxxxxxxx????xxxxxxxxxx"
            )
        );

        WriteNop
        (
            /* 0x14DA900A6 */
            ScanSignature
            (
                "\x74\x53\x44\x8B\x44\x24\x28",
                "xxxxxxx"
            ),
            
            2
        );

        ConverseHook
        (
            /* 0x14DA900A8 */
            ScanSignature
            (
                "\x44\x8B\x44\x24\x28\x48\x8B\x4F\x08\xE8\xCC\xCC\xCC\xCC\x48\x89\xC2\x48\x89\xF9",
                "xxxxxxxxxx????xxxxxx"
            )
        );

        fixed (sbyte* p_language = &_language)
        {
            /* 0x140A14050 */
            long sig = Memory.ReadCall
            (
                ScanSignature
                (
                    "\xE8\xCC\xCC\xCC\xCC\x48\x89\xC1\xE8\xCC\xCC\xCC\xCC\x48\x8B\x4C\x24\x30",
                    "x????xxxx????xxxxx"
                )
            );

            WriteAsmHook
            (
                $@"
                    mov   rax, qword ptr [rcx + 8]
                    movzx ecx, byte ptr [rax + 9]
                    mov   rax, {(long)p_language}
                    mov   byte ptr [rax], cl
                    mov   rax, {Memory.ReadJump(sig + 8)}
                    jmp   rax
                ",

                sig,

                HookBehavior.Replace
            );
        }

        _isInitialised = true;
    }

    public Language GetCurrentLanguage()
    {
        Init();

        return (Language)_language;
    }

    public void AddConverseNotifyAction(TConverseNotifyAction action)
    {
        Init();

        if (_converseNotifyActions.Contains(action))
            return;

        _converseNotifyActions.Add(action);
    }

    public void RemoveConverseNotifyAction(TConverseNotifyAction action)
    {
        Init();

        if (!_converseNotifyActions.Contains(action))
            return;

        _converseNotifyActions.Remove(action);
    }

    public void Redirect(string key, string text)
    {
        Init();

        if (_redirectedStrings.ContainsKey(key))
        {
            _redirectedStrings[key] = text;
            return;
        }

        _redirectedStrings.Add(key, text);
    }

    public void Replace(string pattern, string replacement, bool isRegex = false)
    {
        Init();

        if (string.IsNullOrEmpty(pattern))
            return;

        var first = _replacementStrings.FirstOrDefault(x => x.Pattern == pattern);
        
        if (first != null)
        {
            first.Replacement = replacement;
            return;
        }

        _replacementStrings.Add(new ReplacementString(pattern, replacement, isRegex));
    }

    public void Restore(string key)
    {
        Init();

        if (string.IsNullOrEmpty(key))
            return;
        
        if (_redirectedStrings.ContainsKey(key))
            _redirectedStrings.Remove(key);
        
        _replacementStrings.RemoveAll(x => x.Pattern == key);
    }
}

Library "GameDocument" by "Hyper, ĐeäTh & Sajid"
{
    #lib "Collections"

    using System.Runtime.InteropServices;

    /* 0x140C478D8 */
    private static long gameDocumentUsageSig = ScanSignature
    (
        "\x48\x89\x2D\xCC\xCC\xCC\xCC\x8D\x75\x20",
        "xxx????xxx"
    );

    public long Get()
    {
        if (gameDocumentUsageSig == 0)
            return 0;

        return Read<long>(gameDocumentUsageSig + Read<int>(gameDocumentUsageSig + 3) + 7);
    }

    public long GetService(long gameDocument, string name)
    {
        if (gameDocument == 0)
            return 0;
            
        // csl::ut::MoveArray<hh::game::GameService*> m_Services = 0x150
        var services = Read<Collections.MoveArray<IntPtr>>(gameDocument + 0x150);

        for (int i = 0; i < services.Length; i++)
        {
            IntPtr service = services[i];

            // hh::game::GameService->pStaticClass = 0x38
            // hh::game::GameServiceClass->pName   = 0x00
            if (Marshal.PtrToStringAnsi(Read<IntPtr>(Read<IntPtr>(service + 0x38))) == name)
            {
                return (long)service;
            }
        }

        return 0;
    }

    public long GetService(string name)
    {
        return GetService(Get(), name);
    }

    public long GetGameObject(long gameDocument, string name)
    {
        if (gameDocument == 0)
            return 0;
            
        // csl::ut::MoveArray<hh::game::GameObject*> m_Objects = 0x130
        var gameObjects = Read<Collections.MoveArray<IntPtr>>(gameDocument + 0x130);

        for (int i = 0; i < gameObjects.Length; i++)
        {
            IntPtr gameObject = gameObjects[i];

            // hh::game::GameObject->pObjectName = 0xB8
            if (Marshal.PtrToStringAnsi(Read<IntPtr>(gameObject + 0xB8)) == name)
            {
                return (long)gameObject;
            }
        }

        return 0;
    }

    public long GetGameObject(string name)
    {
        return GetGameObject(Get(), name);
    }
}

Library "GameMode" by "Hyper"
{
    using System.Runtime.InteropServices;

    private static bool _isInitialised = false;

    public enum DestinationMode : sbyte
    {
        Unknown = -1,
        GameModeStage,
        GameModeCyberStage
    }

    private static sbyte _destinationMode = -1;
    
    private static long _pGameModeName = 0;

    public void Init()
    {
        if (_isInitialised)
            return;

        fixed (long* p_pGameModeName = &_pGameModeName)
        {
            WriteAsmHook
            (
                $@"
                    push   rbx
                    sub    rsp, 0x30
                    cmp    r8, 0
                    je     exit
                    mov    rax, qword ptr [r8]
                    mov    rbx, 0x65646F4D656D6147 ; GameMode
                    cmp    rax, rbx
                    mov    rax, {(long)p_pGameModeName}
                    jne    unknown
                    mov    qword ptr [rax], r8
                    jmp    exit
                unknown:
                    mov    rbx, {(long)Marshal.StringToHGlobalAnsi("GameModeUnknown")}
                    mov    qword ptr [rax], rbx
                exit:
                    mov    rbx, rcx
                    movaps xmmword ptr [rsp + 0x38 + 0xFFFFFFFFFFFFFFE8], xmm6
                ",

                /* 0x146BEA180 */
                ScanSignature
                (
                    "\x40\x53\x48\x83\xEC\x30\x48\x89\xCB\x0F\x29\x74\x24\x20\x48\x83\xE9\x80\x0F\x28\xF1\xE8\xCC\xCC\xCC\xCC\x48\x85\xC0\x74\x12",
                    "xxxxxxxxxxxxxxxxxxxxxx????xxxxx"
                ),

                HookBehavior.Replace
            );

            WriteAsmHook
            (
                $@"
                    mov   rcx, {(long)Marshal.StringToHGlobalAnsi("GameModeTitle")}
                    mov   rdx, {(long)p_pGameModeName}
                    mov   qword ptr [rdx], rcx
                    mov   edx, 0x38
                    mov   qword ptr [rdi], rax
                    mov   rcx, rsi
                    movsd xmm0, qword ptr [rbx]
                ",

                /* 0x1401D8EA4 */
                ScanSignature
                (
                    "\xBA\x38\x00\x00\x00\x48\x89\x07",
                    "xxxxxxxx"
                ),

                HookBehavior.Replace
            );

            // Set if we're currently in Cyber Space.
            WriteAsmHook
            (
                $@"
                    mov r8, {(long)Marshal.StringToHGlobalAnsi("GameModeCyberStage")}
                    mov rcx, {(long)p_pGameModeName}
                    mov qword ptr [rcx], r8
                    mov r8d, 0x10
                    mov qword ptr [rsi], rax
                    lea rcx, qword ptr [rsi + 0x100]
                ",

                /* 0x147334264 */
                ScanSignature
                (
                    "\x41\xB8\x10\x00\x00\x00\x48\x89\x06\x48\x8D\x8E\x00\x01\x00\x00\x0F\x10\x03\x0F\x11\x86\xE0\x00\x00\x00\x0F\x10\x4B\x10\x0F\x11\x8E\xF0\x00\x00\x00\x48\x8B\x13\xE8\xCC\xCC\xCC\xCC\x4C\x31\x05",
                    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx????xxx"
                ),

                HookBehavior.Replace
            );

            // Set if we're currently on an island.
            WriteAsmHook
            (
                $@"
                    mov qword ptr [rsi + 0x1A8], rbx
                    mov rbp, {(long)Marshal.StringToHGlobalAnsi("GameModeStage")}
                    mov rax, {(long)p_pGameModeName}
                    mov qword ptr [rax], rbp
                    xor ebp, ebp
                    mov qword ptr [rsi + 0x190], rbp
                ",

                /* 0x147967172 */
                ScanSignature
                (
                    "\x48\x89\x9E\xA8\x01\x00\x00\x31\xED",
                    "xxxxxxxxx"
                ),

                HookBehavior.Replace
            );

            fixed (sbyte* p_destinationMode = &_destinationMode)
            {
                // Set if we're entering Cyber Space from Training Simulator.
                WriteAsmHook
                (
                    $@"
                        mov    rdx, {(long)Marshal.StringToHGlobalAnsi("GameModeTutorial")}
                        mov    rax, {(long)p_pGameModeName}
                        mov    qword ptr [rax], rdx
                        mov    rax, {(long)p_destinationMode}
                        mov    byte ptr [rax], 1
                        mov    rax, [rdi + 0x10]
                        movaps xmmword ptr [rdi + 0x110], xmm0
                        mov    rdx, [rax + 0x70]
                    ",
                    
                    /* 0x14015AAA9 */
                    ScanSignature
                    (
                        "\x48\x8B\x47\x10\x0F\x29\x87\x10\x01\x00\x00",
                        "xxxxxxxxxxx"
                    ),
                    
                    HookBehavior.Replace
                );
                
                // Set if we're returning to an island from Training Simulator after quitting Cyber Space.
                WriteAsmHook
                (
                    $@"
                        ; Restore original code.
                        movups xmm0, xmmword ptr [rsp + 0x210 + 0xFFFFFFFFFFFFFE10]
                        mov    qword ptr [rbp + 0x110 + 0xFFFFFFFFFFFFFFA0], rax
                        mov    word ptr [rdi + 0x120], 0x101
                        mov    rcx, {(long)Marshal.StringToHGlobalAnsi("GameModeTutorial")}
                        mov    rax, {(long)p_pGameModeName}
                        mov    qword ptr [rax], rcx
                        mov    rax, {(long)p_destinationMode}
                        mov    byte ptr [rax], 0
                    ",
                    
                    /* 0x140158D07 */
                    ScanSignature
                    (
                        "\x0F\x10\x44\x24\x20\x48\x89\x85\xB0\x00\x00\x00\x66\xC7\x87\x20\x01\x00\x00\x01\x01",
                        "xxxxxxxxxxxxxxxxxxxxx"
                    ),
                    
                    HookBehavior.Replace
                );

                // Set if we're returning to an island from Training Simulator after completing Cyber Space.
                WriteAsmHook
                (
                    $@"
                        mov rbx, {(long)Marshal.StringToHGlobalAnsi("w6d01")}
                        lea rcx, qword ptr [rbx]
                        mov rbx, {(long)Marshal.StringToHGlobalAnsi("GameModeTutorial")}
                        mov rdx, {(long)p_pGameModeName}
                        mov qword ptr [rdx], rbx
                        mov rax, {(long)p_destinationMode}
                        mov byte ptr [rax], 0
                        xor ebx, ebx
                        mov edx, ebx
                    ",
                    
                    /* 0x140158AD0 */
                    ScanSignature
                    (
                        "\x33\xDB\x48\x8D\x0D\xCC\xCC\xCC\xCC\x8B\xD3",
                        "xxxxx????xx"
                    ),
                    
                    HookBehavior.Replace
                );
            }
        }

        _isInitialised = true;
    }

    public string GetName()
    {
        Init();

        if (_pGameModeName == 0)
            return "GameModeUnknown";

        return Marshal.PtrToStringAnsi((IntPtr)_pGameModeName);
    }

    public DestinationMode GetTutorialDestination()
    {
        return (DestinationMode)_destinationMode;
    }
}

Library "GameObject" by "Hyper, ĐeäTh & Sajid"
{
    #lib "Collections"

    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Runtime.InteropServices;

    public long GetGOC(long gameObject, string name)
    {
        if (gameObject == 0)
            return 0;

        // csl::ut::MoveArray<hh::game::GOComponent*> m_Components = 0x58
        var components = Read<Collections.MoveArray<IntPtr>>(gameObject + 0x58);

        for (int i = 0; i < components.Length; i++)
        {
            IntPtr component = components[i];
            
            // hh::game::GOComponent->pStaticClass = 0x48
            // hh::game::ComponentClass->pName     = 0x00
            if (Marshal.PtrToStringAnsi(Read<IntPtr>(Read<IntPtr>(component + 0x48))) == name)
            {
                return (long)component;
            }
        }

        return 0;
    }

    public class Transform
    {
        public Vector3* Position;
        public Quaternion* Rotation;
        public Vector3* Scale;

        public Transform(long gocTransform)
        {
            Position = (Vector3*)(gocTransform + 0xC0);
            Rotation = (Quaternion*)(gocTransform + 0xD0);
            Scale    = (Vector3*)(gocTransform + 0xE0);
        }

        public static Transform Get(long gameObject)
        {
            if (gameObject == 0)
                return null;

            long gocTransform = GameObject.GetGOC(gameObject, "GOCTransform");

            if (gocTransform == 0)
                return null;

            return new Transform(gocTransform);
        }
    }
}

Library "GameService" by "Hyper & Sajid"
{
    #include "Helpers" noemit

    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.InteropServices;

    private static bool _isInitialised = false;

    private static List<long> _userServiceClassPtrs = new();

    UNMANAGED_FUNCTION(long, CreateServices, long ppClasses)
    {
        var classes = new List<long>();

        // Copy array contents to our list.
        while (Read<long>(ppClasses) != 0)
        {
            classes.Add(Read<long>(ppClasses));
            ppClasses += 8;
        }

        // Add user service class pointers.
        foreach (long ptr in _userServiceClassPtrs)
            classes.Add(ptr);
        
        classes.Add(0);

        var classesArr = classes.ToArray();

        fixed (long* pClasses = classesArr)
            return (long)pClasses;
    }

    private void Init()
    {
        if (_isInitialised)
            return;
        
        WriteAsmHook
        (
            $@"
                push r14
                sub  rsp, 0x20
                mov  rax, qword ptr [rdx]
                mov  r14, rdx
                mov  rbx, rcx
                mov  rcx, r14
                mov  rdx, {GET_UNMANAGED_FUNCTION_PTR(CreateServices)}
                call rdx
                mov  r14, rax
                mov  rax, qword ptr [rax]
            ",

            /* 0x147140C75 */
            ScanSignature
            (
                "\x41\x56\x48\x83\xEC\x20\x48\x8B\x02\x49\x89\xD6",
                "xxxxxxxxxxxx"
            ),

            HookBehavior.Replace
        );

        _isInitialised = true;
    }

    public void AddUserService(long ptr)
    {
        Init();

        if (_userServiceClassPtrs.Contains(ptr))
            return;

        _userServiceClassPtrs.Add(ptr);
    }

    public void RemoveUserService(long ptr)
    {
        Init();
        
        if (!_userServiceClassPtrs.Contains(ptr))
            return;

        _userServiceClassPtrs.Remove(ptr);
    }
}

Library "Helpers" by "Hyper"
{
    #define UNMANAGED_FUNCTION(returnType, functionName, ...) \
        [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.StdCall)] \
        private delegate returnType T##functionName(__VA_ARGS__); \
        private static T##functionName _del##functionName = new T##functionName(functionName); \
        private static long _fp##functionName = (long)System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(_del##functionName); \
        public returnType functionName(__VA_ARGS__)

    #define GET_UNMANAGED_FUNCTION_PTR(functionName) _fp##functionName

    #define CREATE_FUNCTION_PTR(returnType, functionName, location, ...) \
        [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.StdCall)] \
        private delegate returnType T##functionName(__VA_ARGS__); \
        private static long _addr##functionName = location;

    #define GET_FUNCTION_PTR(functionName) System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<T##functionName>((IntPtr)_addr##functionName)

    #define TO_STRING_PTR(str) (long)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(str)

    #define FROM_STRING_PTR(ptr) System.Runtime.InteropServices.Marshal.PtrToStringAnsi((IntPtr)ptr)
}

Library "HMM" by "Hyper"
{
    #lib "INI"

    using System.Collections.Generic;
    using System.IO;

    public class Mod
    {
        public string Name { get; set; }

        public string Version { get; set; }

        public string Author { get; set; }

        public string Path { get; set; }

        public Dictionary<string, Dictionary<string, string>> Ini { get; set; } = new();

        public Mod(string modIniPath)
        {
            var ini = INI.Read(modIniPath);

            if (ini == null)
                return;

            Name = ini["Desc"]["Title"];
            Version = ini["Desc"]["Version"];
            Author = ini["Desc"]["Author"];
            Path = System.IO.Path.GetDirectoryName(modIniPath);
            Ini = ini;
        }
    }

    public Dictionary<string, Dictionary<string, string>> GetModsDatabase()
    {
        string workingDir = Directory.GetCurrentDirectory();
        string cpkredirCfgPath = Path.Combine(workingDir, "cpkredir.ini");

        if (!File.Exists(cpkredirCfgPath))
            return new();

        var cpkredirCfg = INI.Read(cpkredirCfgPath);
        string modsDbPath = cpkredirCfg["CPKREDIR"]["ModsDbIni"];

        if (!File.Exists(modsDbPath))
            return new();

        return INI.Read(modsDbPath);
    }

    public List<Mod> GetMods()
    {
        List<Mod> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        int activeModCount = INI.Parse<int>(modsDb["Main"]["ActiveModCount"], 0);

        foreach (var entry in modsDb["Mods"].Keys)
        {
            for (int i = 0; i < activeModCount; i++)
            {
                if (modsDb["Main"][$"ActiveMod{i}"].Contains(entry))
                {
                    result.Add(new Mod(modsDb["Mods"][entry]));
                }
            }
        }

        return result;
    }

    public List<string> GetCodes()
    {
        List<string> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        foreach (var value in modsDb["Codes"].Values)
            result.Add(value);

        return result;
    }

    public List<Mod> FindModsByName(string name)
    {
        List<Mod> result = new();

        foreach (var mod in GetMods())
        {
            if (mod.Name.Contains(name))
            {
                result.Add(mod);
            }
        }

        return result;
    }
}

Library "INI" by "Hyper"
{
    using System.Collections.Generic;
    using System.IO;
    
    public Dictionary<string, Dictionary<string, string>> Read(string path)
    {
        Dictionary<string, Dictionary<string, string>> result = new();

        if (!File.Exists(path))
            return result;

        using (StreamReader reader = new StreamReader(path))
        {
            string section = string.Empty;
            string line = string.Empty;

            // Add root section.
            result.Add(section, new Dictionary<string, string>());

            while ((line = reader.ReadLine()) != null)
            {
                if (line.StartsWith("[") && line.EndsWith("]"))
                {
                    section = line.Substring(1, line.Length - 2);
                    result.Add(section, new Dictionary<string, string>());
                    continue;
                }

                if (line.StartsWith(";") || line.StartsWith("#"))
                    continue;

                int delimiterIndex = line.IndexOf('=');

                if (delimiterIndex == -1)
                    continue;

                string key = line.Substring(0, delimiterIndex);
                string value = line.Substring(delimiterIndex + 1);

                if (value.StartsWith("\"") && value.EndsWith("\"") && value.Length > 1)
                    value = value.Substring(1, value.Length - 2);
                
                result[section].Add(key, value);
            }
        }

        return result;
    }

    public T Parse<T>(string value, T defaultValue)
    {
        T result = defaultValue;

        if (typeof(T) == typeof(string))
        {
            result = (T)(object)value;
        }
        else if (typeof(T) == typeof(int))
        {
            if (int.TryParse(value, out int intValue))
            {
                result = (T)(object)intValue;
            }
        }
        else if (typeof(T) == typeof(double))
        {
            if (double.TryParse(value, out double doubleValue))
            {
                result = (T)(object)doubleValue;
            }
        }
        else if (typeof(T) == typeof(float))
        {
            if (float.TryParse(value, out float floatValue))
            {
                result = (T)(object)floatValue;
            }
        }

        return result;
    }
}

Library "LevelInfo" by "Hyper, ĐeäTh & Sajid"
{
    #lib "Collections"
    #lib "GameDocument"

    public long GetLevelInfo(long gameDocument = 0)
    {
        if (gameDocument == 0 && (gameDocument = GameDocument.Get()) == 0)
            return 0;

        return GameDocument.GetService(gameDocument, "LevelInfo");
    }
    
    public long GetPlayerInformation(long levelInfo = 0, int playerIndex = 0)
    {
        if (levelInfo == 0 && (levelInfo = GetLevelInfo()) == 0)
            return 0;

        return Read<long>((levelInfo + 0xC8) + (playerIndex * IntPtr.Size));
    }
}

Library "Lua" by "Hyper & ĐeäTh"
{
    #include "Helpers" noemit

    #lib "GameDocument"
    #lib "GameMode"
    #lib "GameService"
    #lib "Memory"
    #lib "StringMapOperation"

    using System.Collections.Generic;
    using System.IO;

    private static bool _isInitialised = false;
    private static bool _isScriptSequenceInactive = true;

    private static List<string> _deniedGameModes = new()
    {
        "GameModeBattleRush",
        "GameModeFishing",
        "GameModeHacking",
        "GameModeStage"
    };

    private static string _lastGameModeName = "GameModeUnknown";

    private static long _pLuaState = 0;
    private static long _sigScriptSequenceManagerStaticClassCtor = 0;

    private static List<uint> _luaScripts = new();

    #define LUA_TNONE          (-1)
    #define LUA_TNIL           0
    #define LUA_TBOOLEAN       1
    #define LUA_TLIGHTUSERDATA 2
    #define LUA_TNUMBER	       3
    #define LUA_TSTRING	       4
    #define LUA_TTABLE         5
    #define LUA_TFUNCTION      6
    #define LUA_TUSERDATA      7
    #define LUA_TTHREAD        8
    #define LUA_NUMTYPES       9

    /* 0x153A6D900 */
    private static long _sig_luaL_loadbufferx = ScanSignature("\x48\x83\xEC\x48\x48\x8B\x44\x24\x70\x48", "xxxxxxxxxx");
    CREATE_FUNCTION_PTR(long, luaL_loadbufferx, _sig_luaL_loadbufferx, long L, long buff, long size, long name, long mode)

    /* 0x140E6DB50 */
    private static long _sig_lua_getglobal = Memory.ReadCall(ScanSignature("\xE8\xCC\xCC\xCC\xCC\x48\x8B\x0F\x48\x8B\xD3\xE8", "x????xxxxxxx"));
    CREATE_FUNCTION_PTR(long, lua_getglobal, _sig_lua_getglobal, long L, long name)

    /* 0x153959B30 */
    private static long _sig_lua_pcallk = ScanSignature("\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x40\x31\xF6", "xxxxxxxxxxxx");
    CREATE_FUNCTION_PTR(long, lua_pcallk, _sig_lua_pcallk, long L, int nargs, int nresults, int errfunc, long ctx, long k)

    /* 0x140E6D890 */
    private static long _sig_lua_pushlstring = ScanSignature("\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x8B\xD9\x4D", "xxxxxxxxxxxxxx");
    CREATE_FUNCTION_PTR(long, lua_pushlstring, _sig_lua_pushlstring, long L, long s, long len)

    /* 0x140E6D870 */
    private static long _sig_lua_pushinteger = ScanSignature("\x48\x8B\x41\x10\x48\x89\x10\xC6\x40\x08\x03", "xxxxxxxxxxx");
    CREATE_FUNCTION_PTR(long, lua_pushinteger, _sig_lua_pushinteger, long L, int n)

    /* 0x153927520 */
    private static long _sig_lua_pushnumber = ScanSignature("\x48\x8B\x41\x10\xC5\xFA", "xxxxxx");
    CREATE_FUNCTION_PTR(long, lua_pushnumber, _sig_lua_pushnumber, long L, float n)

    /* 0x140E6DAD0 */
    private static long _sig_lua_pushboolean = ScanSignature("\x48\x8B\x41\x10\x85", "xxxxx");
    CREATE_FUNCTION_PTR(long, lua_pushboolean, _sig_lua_pushboolean, long L, int b)

    /* 0x153912110 */
    private static long _sig_lua_type = ScanSignature("\x48\x83\xEC\x28\xE8\xCC\xCC\xCC\xCC\x0F\xB6\x50\x08\xF6", "xxxxx????xxxxx");
    CREATE_FUNCTION_PTR(long, lua_type, _sig_lua_type, long L, int idx)

    /* 0x15391B810 */
    private static long _sig_lua_tolstring = ScanSignature("\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x4C\x89\xC3\x89", "xxxxxxxxxxxxxxxxxxx");
    CREATE_FUNCTION_PTR(long, lua_tolstring, _sig_lua_tolstring, long L, int idx, long len)

    /* 0x140E6D3D0 */
    private static long _sig_lua_tointegerx = ScanSignature("\x40\x53\x48\x83\xEC\x20\x49\x8B\xD8\x48\xC7", "xxxxxxxxxxx");
    CREATE_FUNCTION_PTR(long, lua_tointegerx, _sig_lua_tointegerx, long L, int idx, long pisnum)

    /* 0x140E6D230 */
    private static long _sig_lua_tonumberx = ScanSignature("\x48\x83\xEC\x28\xE8\xCC\xCC\xCC\xCC\x80\x78\x08\x13", "xxxxx????xxxx");
    CREATE_FUNCTION_PTR(long, lua_tonumberx, _sig_lua_tonumberx, long L, int idx, long pisnum)

    /* 0x153916890 */
    private static long _sig_lua_toboolean = ScanSignature("\x48\x83\xEC\x28\xE8\xCC\xCC\xCC\xCC\x0F\xB6\x48\x08\x80\xF9\x01", "xxxxx????xxxxxxx");
    CREATE_FUNCTION_PTR(bool, lua_toboolean, _sig_lua_toboolean, long L, int idx)

    /* 0x14BDE5E20 */
    private static long _sigInitScriptSequenceManager = ScanSignature("\x48\x89\x5C\x24\x10\x48\x89\x6C\x24\x18\x56\x57\x41\x54\x41\x56\x41\x57\x48\x81\xEC\x30\x01\x00\x00\x48\x89", "xxxxxxxxxxxxxxxxxxxxxxxxxxx");
    CREATE_FUNCTION_PTR(int*, InitScriptSequenceManager, _sigInitScriptSequenceManager, long pScriptSequenceManager, uint* pStringHash, char a3)
    
    /* 0x14BDD7B60 */
    private static long _sigRegisterScriptSequenceManager = ScanSignature("\x40\x56\x48\x81\xEC\xC0\x00\x00\x00\x48\x89\xCE\x45", "xxxxxxxxxxxxx");
    CREATE_FUNCTION_PTR(long, RegisterScriptSequenceManager, _sigRegisterScriptSequenceManager, long pScriptSequenceManager)

    public void Init()
    {
        if (_lastGameModeName != GameMode.GetName())
        {
            InitScriptSequence();

            _lastGameModeName = GameMode.GetName();
        }

        if (_isInitialised)
            return;

        GameMode.Init();

        fixed (bool* p_isScriptSequenceInactive = &_isScriptSequenceInactive)
        fixed (long* p_pLuaState = &_pLuaState)
        {
            WriteAsmHook
            (
                $@"
                    push rbp
                    sub  rsp, 0x50
                    mov  r9b, byte ptr [r8 + 0x20]
                    mov  rbp, {(long)p_isScriptSequenceInactive}
                    mov  byte ptr [rbp], r9b
                    cmp  r9b, 0
                    jz   getLuaState
                    mov  rbp, {(long)p_pLuaState}
                    mov  qword ptr [rbp], 0
                    jmp  exit
                getLuaState:
                    mov  r9, qword ptr [rcx + 0x10]
                    cmp  r9, 0
                    jz   exit
                    mov  r9, qword ptr [r9]
                    cmp  r9, 0
                    jz   exit
                    mov  r9, qword ptr [r9 + 0x48]
                    cmp  r9, 0
                    jz   exit
                    mov  r9, qword ptr [r9 + 0x18]
                    cmp  r9, 0
                    jz   exit
                    mov  rbp, {(long)p_pLuaState}
                    mov  qword ptr [rbp], r9
                exit:
                    cmp  byte ptr [r8 + 0x20], 0
                    mov  r9, r8
                    mov  rbp, rcx
                ",

                /* 0x1409172E7 */
                ScanSignature
                (
                    "\x55\x48\x83\xEC\x50\x41\x80\x78\x20\x00",
                    "xxxxxxxxxx"
                ),

                HookBehavior.Replace
            );
        }

        _isInitialised = true;
    }

    public void InitScriptSequence()
    {
        if (_deniedGameModes.Contains(GameMode.GetName()) ||
            GameMode.GetTutorialDestination() == GameMode.DestinationMode.GameModeStage)
        {
            return;
        }

        if (_sigScriptSequenceManagerStaticClassCtor == 0)
        {
            /* 0x140053480 */
            _sigScriptSequenceManagerStaticClassCtor = ScanSignature
            (
                "\x45\x33\xC9\x4C\x8D\x05\xCC\xCC\xCC\xCC\x48\x8D\x15\xCC\xCC\xCC\xCC\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE9\x73\x3F",
                "xxxxxx????xxx????xxx????xxx"
            );

            if (_sigScriptSequenceManagerStaticClassCtor == 0)
            {
                Console.WriteLine("[Lua] Failed to initialise script sequence!");
                return;
            }

            /* 0x143C53810 */
            GameService.AddUserService(Memory.ReadEffectiveAddress(_sigScriptSequenceManagerStaticClassCtor + 0x11));
        }

        long pGameDocument = GameDocument.Get();

        if (pGameDocument == 0)
            return;

        long pScriptSequenceManager = GameDocument.GetService(pGameDocument, "ScriptSequenceManager");

        if (pScriptSequenceManager == 0)
            return;

        // BuildLevel
        uint hash = 0x59B595D6;

        GET_FUNCTION_PTR(InitScriptSequenceManager)(pScriptSequenceManager, &hash, (char)0);
        GET_FUNCTION_PTR(RegisterScriptSequenceManager)(pScriptSequenceManager);
    }

    public long GetState()
    {
        Init();

        /*
            This stupid null check validates the Lua state
            by checking if lua_State.next is null. This won't
            always mean the state is valid, of course, as any
            bit of memory could have a null QWORD, but it works.

            PUC-Rio should really add a signature to the lua_State
            struct for external validation, because checking the
            result of luaL_newstate is just not good enough.
        */
        if (_pLuaState != 0 && *(long*)_pLuaState != 0)
            return 0;

        if (_isScriptSequenceInactive)
            return 0;

        return _pLuaState;
    }

    public void Script(string code, bool isRunOnce = false)
    {
        Init();

        if (GetState() == 0)
            return;

        if (isRunOnce)
        {
            uint codeHash = StringMapOperation.ComputeHash(code);

            if (_luaScripts.Contains(codeHash))
            {
                return;
            }
            else
            {
                _luaScripts.Add(codeHash);
            }
        }
            
        long str = TO_STRING_PTR(code);
        
        GET_FUNCTION_PTR(luaL_loadbufferx)(GetState(), str, code.Length, str, 0);
        GET_FUNCTION_PTR(lua_pcallk)(GetState(), 0, -1, 0, 0, 0);
    }

    public void LoadScript(string path, bool isRunOnce = false)
    {
        if (!File.Exists(path))
            return;

        string code = string.Empty;

        try
        {
            code = File.ReadAllText(path);
        }
        catch (IOException ex)
        {
            Console.WriteLine($"[Lua] Error: \"{path}\" is being used by another process.");
        }

        if (string.IsNullOrEmpty(code))
            return;

        Script(code, isRunOnce);
    }

    private void Call(string funcName, int resultCount, params object[] args)
    {
        Init();

        if (GetState() == 0)
            return;

        GET_FUNCTION_PTR(lua_getglobal)(GetState(), TO_STRING_PTR(funcName));

        foreach (var arg in args)
        {
            var type = arg.GetType();

            if (type == typeof(string))
            {
                string str = (string)arg;
                GET_FUNCTION_PTR(lua_pushlstring)(GetState(), TO_STRING_PTR(str), str.Length);
            }
            else if (type == typeof(int))
            {
                GET_FUNCTION_PTR(lua_pushinteger)(GetState(), (int)arg);
            }
            else if (type == typeof(float) || type == typeof(double))
            {
                GET_FUNCTION_PTR(lua_pushnumber)(GetState(), (float)arg);
            }
            else if (type == typeof(bool))
            {
                GET_FUNCTION_PTR(lua_pushboolean)(GetState(), (bool)arg ? 1 : 0);
            }
            else
            {
                Console.WriteLine($"[Lua] Type {type} is not supported...");
            }
        }

        GET_FUNCTION_PTR(lua_pcallk)(GetState(), args.Length, resultCount, 0, 0, 0);
    }

    public void Call(string funcName, params object[] args)
    {
        Call(funcName, 0, args);
    }

    public T Call<T>(string funcName, params object[] args)
    {
        Init();

        if (GetState() == 0)
            return default;

        Call(funcName, 1, args);

        var type = typeof(T);
        var luaType = GET_FUNCTION_PTR(lua_type)(GetState(), -1);

        if (type == typeof(string) && luaType == LUA_TSTRING)
        {
            long ptr = (long)GET_FUNCTION_PTR(lua_tolstring)(GetState(), -1, 0);
            return (T)(object)FROM_STRING_PTR(ptr);
        }
        else if (type == typeof(int) && luaType == LUA_TNUMBER)
        {
            return (T)(object)(int)GET_FUNCTION_PTR(lua_tointegerx)(GetState(), -1, 0);
        }
        else if ((type == typeof(float) || type == typeof(double)) && luaType == LUA_TNUMBER)
        {
            return (T)(object)(float)GET_FUNCTION_PTR(lua_tonumberx)(GetState(), -1, 0);
        }
        else if (type == typeof(bool) && luaType == LUA_TBOOLEAN)
        {
            return (T)(object)(bool)GET_FUNCTION_PTR(lua_toboolean)(GetState(), -1);
        }
        else
        {
            Console.WriteLine($"[Lua] Type {type} is not supported...");
        }

        return default;
    }
}

Library "MathHelpers" by "Hyper"
{
    using System.Collections.Generic;

    public T Clamp<T>(T value, T minValue, T maxValue) where T : IComparable<T>
    {
        if (value.CompareTo(minValue) < 0)
        {
            return minValue;
        }
        else if (value.CompareTo(maxValue) > 0)
        {
            return maxValue;
        }
        else
        {
            return value;
        }
    }

    public T FloatPercentToRange<T>(float value)
    {
        if (typeof(T) == typeof(sbyte))
        {
            return (T)(object)(byte)(value * (sbyte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(byte))
        {
            return (T)(object)(byte)(value * (byte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(short))
        {
            return (T)(object)(short)(value * (short.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ushort))
        {
            return (T)(object)(ushort)(value * (ushort.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(int))
        {
            return (T)(object)(int)(value * (int.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(uint))
        {
            return (T)(object)(uint)(value * (uint.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(long))
        {
            return (T)(object)(long)(value * (long.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ulong))
        {
            return (T)(object)(ulong)(value * (ulong.MaxValue * 1.0f));
        }
        
        return default;
    }
    
    public float Lerp(float start, float end, float time)
    {
        return start + (end - start) * time;
    }
}

Library "Memory" by "Hyper"
{
    using System.Collections.Generic;

    private static Dictionary<IntPtr, List<byte>> _preservedMemory = new();

    public void Preserve(IntPtr location, long length, bool preserveOnce = true)
    {
        if (location == IntPtr.Zero)
            return;

        if (preserveOnce)
        {
            if (_preservedMemory.ContainsKey(location))
                return;
        }
        else
        {
            if (_preservedMemory.ContainsKey(location))
                _preservedMemory.Remove(location);
        }
        
        List<byte> buffer = new();
        for (long i = 0; i < length; i++)
            buffer.Add(Read<byte>(location.ToInt64() + i));

        _preservedMemory.Add(location, buffer);
    }

    public void Preserve(long location, long length, bool preserveOnce = true)
    {
        Preserve(new IntPtr(location), length, preserveOnce);
    }

    public void Restore(IntPtr location)
    {
        if (location == IntPtr.Zero)
            return;

        if (!_preservedMemory.ContainsKey(location))
            return;

        long i = 0;
        foreach (byte b in _preservedMemory[location])
        {
            WriteProtected<byte>(location.ToInt64() + i, b);
            i++;
        }
    }

    public void Restore(long location)
    {
        Restore(new IntPtr(location));
    }

    public long ReadCall(long addr)
    {
        if (addr == 0)
            return 0;

        return addr + Read<int>(addr + 0x01) + 0x05;
    }

    public long ReadEffectiveAddress(long addr)
    {
        if (addr == 0)
            return 0;

        return addr + Read<int>(addr + 0x03) + 0x07;
    }

    public long ReadJump(long addr)
    {
        if (addr == 0)
            return 0;

        sbyte jmpType = -1;
        byte opcode = Read<byte>(addr);

        if ((opcode & 0xF0) == 0x70)
        {
            jmpType = 0;
        }
        else
        {
            switch (opcode)
            {
                case 0xE3:
                case 0xEB:
                    jmpType = 0;
                    break;

                case 0xE9:
                    jmpType = 1;
                    break;

                case 0x0F:
                    jmpType = 2;
                    break;

                case 0xFF:
                    jmpType = 3;
                    break;
            }
        }

        switch (jmpType)
        {
            case 0:
                return addr + Read<byte>(addr + 0x01) + 0x02;

            case 1:
                return addr + Read<int>(addr + 0x01) + 0x05;

            case 2:
                return addr + Read<int>(addr + 0x02) + 0x06;

            case 3:
                return Read<long>(addr + 0x06);
        }

        return 0;
    }

    public long ReadThunk(long addr, long offset = 0)
    {
        return ReadJump(ReadCall(addr) + offset);
    }
}

Library "Reflection" by "Hyper"
{
    #lib "Resources"
    #lib "SonicParameters"

    using System.Collections.Generic;

    private static bool _isInitialised = false;
    private static List<string> _rflPointersQueue = new();
    private static Dictionary<string, object> _rflBackups = new();
    private static Dictionary<string, long> _rflPointers = new();

    public class ReflectionInfo<T>
    {
        public string Name;
        public Type Type;
        public T* pData;

        public ReflectionInfo(string name, T* pData)
        {
            this.Name = name;
            this.Type = typeof(T);
            this.pData = pData;
        }

        public override string ToString()
        {
            return $"{Name} : 0x{((IntPtr)pData).ToString("X16")}";
        }
    }

    private void Init()
    {
    	if (_isInitialised)
    		return;
    	
    	long GetReflectionPtr(string resourceName, string resourceType, long pResourceData)
    	{
    		if (resourceType != "ResReflection")
    			return pResourceData;

    		if (_rflPointersQueue.Contains(resourceName))
    		{
    			long ptr = *(long*)(pResourceData + 0x60);

    			if (_rflPointers.ContainsKey(resourceName))
    			{
    				_rflPointers[resourceName] = ptr;
    			}
    			else
    			{
    				_rflPointers.Add(resourceName, ptr);
    			}
    		}

    		return pResourceData;
    	}

    	Resources.AddResourceDataAction(GetReflectionPtr);

    	_isInitialised = true;
    }

    public T* GetDataPtr<T>(string rflName)
    {
    	Init();

    	if (!_rflPointersQueue.Contains(rflName))
    		_rflPointersQueue.Add(rflName);

    	if (!_rflPointers.ContainsKey(rflName))
    		return null;

        long ptr = _rflPointers[rflName];

        if (ptr == 0)
            return null;

        // Check for BINA signature.
        if (*(int*)(ptr - 0x40) != 0x414E4942)
            return null;

        var result = (T*)ptr;

    	if (result != null && !_rflBackups.ContainsKey(rflName))
            _rflBackups.Add(rflName, *result);

    	return result;
    }

    public ReflectionInfo<T> GetDataInfo<T>(string rflName)
    {
        return new ReflectionInfo<T>(rflName, GetDataPtr<T>(rflName));
    }

    public object GetOriginalData(string rflName)
    {
        if (!_rflBackups.ContainsKey(rflName))
            return null;

        return _rflBackups[rflName];
    }

    public T GetOriginalData<T>(string rflName)
    {
        return (T)GetOriginalData(rflName);
    }
}

Library "ReflectionHelpers" by "Hyper"
{
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "Reflection"
    #lib "Sonic"
    
    #define RFL_GET_PARAM(info, hierarchy) info.pData->hierarchy

    #define RFL_SET_PARAM(info, hierarchy, value) info.pData->hierarchy = value

    #define RFL_RESET_PARAM(info, type, hierarchy) info.pData->hierarchy = Reflection.GetOriginalData<type>(info.Name).hierarchy

    #define RFL_GET_CONTEXTUAL_PLAYER_PARAM(info, hierarchy) \
        (Sonic.IsSideView() \
            ? info.pData->cyberspaceSV.hierarchy \
            : BlackboardStatus.IsCyberSpace() \
                ? info.pData->cyberspace.hierarchy \
                : info.pData->forwardView.hierarchy)

    #define RFL_SET_CONTEXTUAL_PLAYER_PARAM(info, hierarchy, value) \
        if (Sonic.IsSideView()) \
            info.pData->cyberspaceSV.hierarchy = value; \
        else if (BlackboardStatus.IsCyberSpace()) \
            info.pData->cyberspace.hierarchy = value; \
        else \
            info.pData->forwardView.hierarchy = value;

    #define RFL_RESET_CONTEXTUAL_PLAYER_PARAM(info, type, hierarchy) \
        if (Sonic.IsSideView()) \
            info.pData->cyberspaceSV.hierarchy = Reflection.GetOriginalData<type>(info.Name).cyberspaceSV.hierarchy; \
        else if (BlackboardStatus.IsCyberSpace()) \
            info.pData->cyberspace.hierarchy = Reflection.GetOriginalData<type>(info.Name).cyberspace.hierarchy; \
        else \
            info.pData->forwardView.hierarchy = Reflection.GetOriginalData<type>(info.Name).forwardView.hierarchy;
}

Library "Resources" by "Hyper"
{
    #include "Helpers" noemit
    
    #lib "Memory"
    
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    
    private static bool _isInitialised = false;
    
    private static string _currentResourceName = string.Empty;
    private static string _currentResourceType = string.Empty;
    
    public delegate string TResourceNotifyAction(string resourceName, string resourceType);
    private static List<TResourceNotifyAction> _resourceNotifyActions = new();
    
    public delegate long TResourceDataAction(string resourceName, string resourceType, long pResourceData);
    private static List<TResourceDataAction> _resourceDataActions = new();
    
    UNMANAGED_FUNCTION(long, GetResourceInfo, long pResourceName, long pResourceTypeName)
    {
        _currentResourceName = Marshal.PtrToStringAnsi((IntPtr)pResourceName);
        _currentResourceType = Marshal.PtrToStringAnsi((IntPtr)pResourceTypeName);
    
    	foreach (TResourceNotifyAction action in _resourceNotifyActions)
    		pResourceName = (long)Marshal.StringToHGlobalAnsi(action(_currentResourceName, _currentResourceType));
    	
        return pResourceName;
    }
    
    UNMANAGED_FUNCTION(long, GetResourceData, long pResourceData)
    {
    	foreach (TResourceDataAction action in _resourceDataActions)
    		pResourceData = action(_currentResourceName, _currentResourceType, pResourceData);
    
        return pResourceData;
    }
    
    private void Init()
    {
    	if (_isInitialised)
    		return;
    
        /* 0x140C70AE3 */
        long sigLoadResourceCaller = ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x85\xC0\x74\x22\x80\x78\x10\x00",
            "x????xxxxxxxxx"
        );
    
        if (sigLoadResourceCaller == 0)
            return;
    
        WriteAsmHook
        (
            $@"
                sub  rsp, 0xD0
                mov  rdi, r8
                mov  rbx, rdx
                mov  rsi, rcx
                mov  rcx, rdx
                mov  rdx, [rdi]
                mov  rax, {GET_UNMANAGED_FUNCTION_PTR(GetResourceInfo)}
                call rax
                mov  rdx, [rcx]
                mov  rbx, rdx
            ",
    
            /* 0x140DFFB0B */
            ScanSignature
            (
                "\x48\x81\xEC\xD0\x00\x00\x00\x49\x8B\xF8\x48\x8B\xDA",
                "xxxxxxxxxxxxx"
            ),
    
            HookBehavior.Replace
        );
    
        WriteAsmHook
        (
            $@"
                mov  rcx, rax
                mov  rax, {GET_UNMANAGED_FUNCTION_PTR(GetResourceData)}
                call rax
                lea  r11, qword ptr [rsp + 0xD8 + 0xFFFFFFFFFFFFFFF8]
                mov  rbx, qword ptr [r11 + 0x10]
                mov  rsi, qword ptr [r11 + 0x18]
    			mov  rsp, r11
            ",
            
            /* 0x140DFFBE6 */
            Memory.ReadCall(sigLoadResourceCaller) + 0xE6,
    
            HookBehavior.Replace
        );
    
    	// Allow loading open zone asset archive.
    	WriteNop
    	(
    		/* 0x1401C5BDC */
    		ScanSignature
    		(
    			"\x0F\x84\x36\x01\x00\x00\x48\x8D\x15",
    			"xxxxxxxxx"
    		),
    
    		6
    	);
    
    	// Allow loading Cyber Space asset archive.
    	WriteNop
    	(
    		/* 0x1401C5BC7 */
    		ScanSignature
    		(
    			"\x74\x0F\x48\x8D\x15\xCC\xCC\xCC\xCC\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x40\x38\x75\x68",
    			"xxxxx????xxxx????xxxx"
    		),
    
    		2
    	);
    
    	_isInitialised = true;
    }
    
    /*
    	Use notify actions for redirecting resources.
    	Redirected resources must already have their data present in memory loaded from their respective Packfiles.
        
    	Example;
    
    	string NotifyRedirectDashPanelResource(string resourceName, string resourceType)
    	{
    		if (resourceName == "cmn_obj_dashpanel")
    			return "cmnisl_obj_dashpanel";
    
    		return resourceName;
    	}
    
    	Resources.AddResourceNotifyAction(NotifyRedirectDashPanelResource);
    */
    public void AddResourceNotifyAction(TResourceNotifyAction action)
    {
    	Init();
    
    	if (_resourceNotifyActions.Contains(action))
    		return;
    
    	_resourceNotifyActions.Add(action);
    }
    
    public void RemoveResourceNotifyAction(TResourceNotifyAction action)
    {
    	Init();
    
    	if (!_resourceNotifyActions.Contains(action))
    		return;
    
    	_resourceNotifyActions.Remove(action);
    }
        
    /*
    	Use data actions for reading resource data.
        
    	Example;
    
    	SonicParameters.Root* pSonicParameters;
    
    	long GetSonicParametersPointer(string resourceName, string resourceType, long pResourceData)
    	{
    		if (resourceName == "player_common" && resourceType == "ResReflection")
    			pSonicParameters = (SonicParameters.Root*)(*(long*)(pResourceData + 0x60));
    
    		return pResourceData;
    	}
    
    	Resources.AddResourceDataAction(GetSonicParametersPointer);
    */
    public void AddResourceDataAction(TResourceDataAction action)
    {
    	Init();
    
    	if (_resourceDataActions.Contains(action))
    		return;
    
    	_resourceDataActions.Add(action);
    }
    
    public void RemoveResourceDataAction(TResourceDataAction action)
    {
    	Init();
    
    	if (!_resourceDataActions.Contains(action))
    		return;
    
    	_resourceDataActions.Remove(action);
    }
}

Library "Sonic" by "Hyper, NM & Ahremic"
{
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "Collections"
    #lib "GameDocument"
    #lib "GameObject"
    #lib "LevelInfo"
    #lib "Memory"
    #lib "StringMapOperation"

    #load "System.Numerics.dll"

    using System.Collections.Generic;
    using System.Linq;
    using System.Numerics;
    using System.Runtime.InteropServices;

    public long GetSonic()
    {
        return GameDocument.GetGameObject("Sonic");
    }

    public long GetSonicContext(long sonic = 0)
    {
        if (sonic == 0 && (sonic = GetSonic()) == 0)
            return 0;

        return Read<long>(sonic + 0x2E0);
    }

    public bool IsGrounded()
    {
        long playerInfo = LevelInfo.GetPlayerInformation();

        if (playerInfo == 0)
            return false;

        return Read<bool>(playerInfo + 0x2EE);
    }

    public bool IsGroundedSpecial()
    {
        if (BlackboardStatus.Get() == 0)
            return true;

        return IsGrounded() ||
            Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsGrind) ||
            Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsSpringJump) ||
            Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsWallClimb);
    }

    public enum ModePackageType
    {
        ForwardView,
        Water,
        CyberSpace,
        SideView
    }

    public ModePackageType GetModePackageType()
    {
		var pSonic = GetSonic();

		if (pSonic == 0)
			return 0;

		var pPlayerParameter = GameObject.GetGOC(pSonic, "GOCPlayerParameter");

		if (pPlayerParameter == 0)
			return 0;

		return (ModePackageType)(*(int*)(((long)pPlayerParameter) + 0xB8));
    }

    public bool IsSideView()
    {
		return GetModePackageType() == ModePackageType.SideView;
    }

    public bool IsUnderwater()
    {
		return GetModePackageType() == ModePackageType.Water;
    }

    public static class Animation
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate void _tSetAnimation(long gocPlayerVisual, long animationNamePtr, byte a3);
        private static long _sigSetAnimation = 0;

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate void _tSetAnimationParameter(long gocPlayerVisual, long paramNamePtr, float value);
        private static long _sigSetAnimationParameter = 0;

        public static void SetAnimation(string destination)
        {
            if (_sigSetAnimation == 0)
            {
                /* 0x1408122E0 */
                _sigSetAnimation = ScanSignature
                (
                    "\x40\x53\x48\x83\xEC\x20\xF6\x81\x78\x01\x00\x00\x10\x48\x8B\xDA",
                    "xxxxxxxxxxxxxxxx"
                );

                if (_sigSetAnimation == 0)
                    return;
            }

            var fpSetAnimation = Marshal.GetDelegateForFunctionPointer<_tSetAnimation>((IntPtr)_sigSetAnimation);

            if (fpSetAnimation == null)
                return;

            long sonic = GetSonic();

            if (sonic == 0)
                return;

            long gocPlayerVisual = GameObject.GetGOC(sonic, "GOCPlayerVisual");

            if (gocPlayerVisual == 0)
                return;

            fpSetAnimation(gocPlayerVisual, (long)Marshal.StringToHGlobalAnsi(destination), 0xFE);
        }

        public static void SetAnimationParameter(string paramName, float value)
        {
            if (_sigSetAnimationParameter == 0)
            {
                /* 0x140813140 */
                _sigSetAnimationParameter = ScanSignature
                (
                    "\x40\x53\x48\x83\xEC\x30\x48\x8B\x81\x10\x01\x00\x00\x48\x8B\xDA",
                    "xxxxxxxxxxxxxxxx"
                );

                if (_sigSetAnimationParameter == 0)
                    return;
            }

            var fpSetAnimationParameter = Marshal.GetDelegateForFunctionPointer<_tSetAnimationParameter>((IntPtr)_sigSetAnimationParameter);

            if (fpSetAnimationParameter == null)
                return;

            long sonic = GetSonic();

            if (sonic == 0)
                return;

            long gocPlayerVisual = GameObject.GetGOC(sonic, "GOCPlayerVisual");

            if (gocPlayerVisual == 0)
                return;

            fpSetAnimationParameter(gocPlayerVisual, (long)Marshal.StringToHGlobalAnsi(paramName), value);
        }
    }

    public enum CollisionType : byte
    {
        Default,
        Damage = 2,
        DamageHoming = 3
    }

    public static class Collision
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate long _tGetStatePluginCollision(long sonicContext);
        private static long _sigGetStatePluginCollision = 0;

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate long _tSetCollisionSphere(long statePluginCollision, CollisionType type, float radius);
        private static long _sigSetCollisionSphere = 0;

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate void _tToggleEntityCollision(long sonicContext, bool enabled);
        private static long _sigToggleEntityCollision = 0;

        public static long GetPlugin()
        {
            if (_sigGetStatePluginCollision == 0)
            {
                /* 0x14086A0B0 */
                _sigGetStatePluginCollision = ScanSignature
                (
                    "\x40\x56\x48\x83\xEC\x20\x48\x8B\x41\x38\x48\x8B\xB0\x08\x01\x00\x00\x48\x85\xF6\x74\x65\x48\x8B\x46\x20\x48\x89\x5C\x24\x30\x48\x8B\x5E\x18\x48\x89\x7C\x24\x38\x48\x8D\x3C\xC3\x48\x3B\xDF\x74\x19\x48\x8B\x0B\x48\x8B\x01\xFF\x50\xCC\x3D\x8E\xB4\x47\x3B",
                    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx?xxxxx"
                );

                if (_sigGetStatePluginCollision == 0)
                    return 0;
            }

            var fpGetStatePluginCollision = Marshal.GetDelegateForFunctionPointer<_tGetStatePluginCollision>((IntPtr)_sigGetStatePluginCollision);

            if (fpGetStatePluginCollision == null)
                return 0;

            long sonicContext = GetSonicContext();

            if (sonicContext == 0)
                return 0;

            return fpGetStatePluginCollision(sonicContext);
        }

        public static long SetCollisionSphere(CollisionType type, float radius)
        {
            if (_sigSetCollisionSphere == 0)
            {
                /* 0x1408ED200 */
                _sigSetCollisionSphere = ScanSignature
                (
                    "\x40\x53\x48\x83\xEC\x50\x0F\x28\x05\xCC\xCC\xCC\xCC\x48\x8B\xD9\x88\x54\x24\x20",
                    "xxxxxxxxx????xxxxxxx"
                );

                if (_sigSetCollisionSphere == 0)
                    return 0;
            }

            var fpSetCollisionSphere = Marshal.GetDelegateForFunctionPointer<_tSetCollisionSphere>((IntPtr)_sigSetCollisionSphere);

            if (fpSetCollisionSphere == null)
                return 0;

            long statePluginCollision = GetPlugin();

            if (statePluginCollision == 0)
                return 0;

            return fpSetCollisionSphere(statePluginCollision, type, radius);
        }

        public static void ToggleEntityCollision(bool enabled)
        {
            if (_sigToggleEntityCollision == 0)
            {
                /* 0x14BB87C00 */
                _sigToggleEntityCollision = ScanSignature
                (
                    "\x40\x53\x48\x83\xEC\x20\x48\x8B\x41\x50\x0F\xB6\xDA",
                    "xxxxxxxxxxxxx"
                );

                if (_sigToggleEntityCollision == 0)
                    return;
            }

            var fpToggleEntityCollision = Marshal.GetDelegateForFunctionPointer<_tToggleEntityCollision>((IntPtr)_sigToggleEntityCollision);

            if (fpToggleEntityCollision == null)
                return;

            long sonicContext = GetSonicContext();

            if (sonicContext == 0)
                return;
            
            fpToggleEntityCollision(sonicContext, enabled);
        }
    }

    public static class Effect
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool _tPlayAnimationEffect(long pSonicContext, long effectName);
        private static long _sigPlayAnimationEffect = 0;

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate long _tStopAnimationEffects(long sonicContext);
        private static long _sigStopAnimationEffects = 0;

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate long _tPlayEffect(long pStatePluginEffect, uint handleNameHash, long pEffectName);
        private static long _sigPlayEffect = 0;

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate long _tStopEffect(long pStatePluginEffect, uint handleNameHash);
        private static long _sigStopEffect = 0;

        public static void PlayEffect(string handleName, string effectName)
        {
            if (_sigPlayEffect == 0)
            {
                /* 0x1408DF420 */
                _sigPlayEffect = ScanSignature
                (
                    "\x48\x8B\xC4\x48\x89\x58\x08\x48\x89\x68\x18\x48\x89\x70\x20\x57\x48\x81\xEC\xA0\x00\x00\x00\xF3",
                    "xxxxxxxxxxxxxxxxxxxxxxxx"
                );

                if (_sigPlayEffect == 0)
                    return;
            }

            var fpPlayEffect = Marshal.GetDelegateForFunctionPointer<_tPlayEffect>((IntPtr)_sigPlayEffect);

            if (fpPlayEffect == null)
                return;

            long pStatePluginEffect = State.GetStatePlugin("StatePluginEffect");

            if (pStatePluginEffect == 0)
                return;

            fpPlayEffect(pStatePluginEffect, StringMapOperation.ComputeHash(handleName), (long)Marshal.StringToHGlobalAnsi(effectName));
        }

        public static void StopEffect(string handleName)
        {
            if (_sigStopEffect == 0)
            {
                /* 0x14B912E80 */
                _sigStopEffect = ScanSignature
                (
                    "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x8B\x41\x30\x48\x8D",
                    "xxxxxxxxxxxxxxxx"
                );

                if (_sigStopEffect == 0)
                    return;
            }

            var fpPlayEffect = Marshal.GetDelegateForFunctionPointer<_tStopEffect>((IntPtr)_sigStopEffect);

            if (fpPlayEffect == null)
                return;

            long pStatePluginEffect = State.GetStatePlugin("StatePluginEffect");

            if (pStatePluginEffect == 0)
                return;

            fpPlayEffect(pStatePluginEffect, StringMapOperation.ComputeHash(handleName));
        }

        public static void PlayAnimationEffect(string name)
        {
            if (_sigPlayAnimationEffect == 0)
            {
                /* 0x140901E20 */
                _sigPlayAnimationEffect = ScanSignature
                (
                    "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x48\x8B\xF2\x48\x8B\xF9\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD8",
                    "xxxxxxxxxxxxxxxxxxxxxx????xxx"
                );

                if (_sigPlayAnimationEffect == 0)
                    return;
            }

            var fpPlayAnimationEffect = Marshal.GetDelegateForFunctionPointer<_tPlayAnimationEffect>((IntPtr)_sigPlayAnimationEffect);

            if (fpPlayAnimationEffect == null)
                return;

            long sonicContext = GetSonicContext();

            if (sonicContext == 0)
                return;

            fpPlayAnimationEffect(sonicContext, (long)Marshal.StringToHGlobalAnsi(name));
        }

        public static void StopAnimationEffects()
        {
            if (_sigStopAnimationEffects == 0)
            {
                /* 0x14BC65500 */
                _sigStopAnimationEffects = ScanSignature
                (
                    "\x40\x53\x48\x83\xEC\x20\x48\x89\xCB\xE8\xCC\xCC\xCC\xCC\x48\x85\xC0",
                    "xxxxxxxxxx????xxx"
                );

                if (_sigStopAnimationEffects == 0)
                    return;
            }

            var fpStopAnimationEffect = Marshal.GetDelegateForFunctionPointer<_tStopAnimationEffects>((IntPtr)_sigStopAnimationEffects);

            if (fpStopAnimationEffect == null)
                return;

            long sonicContext = GetSonicContext();

            if (sonicContext == 0)
                return;

            fpStopAnimationEffect(sonicContext);
        }
    }

    public enum PlayerActionType
    {
        PlayerJump = 0,             // A
        PlayerCyloop = 1,           // Y
        PlayerAttack = 2,           // X
        PlayerLightDash = 3,        // LS
        PlayerBoost = 4,            // RT
        PlayerDrift = 5,            // Unknown
        PlayerChangeSuperSonic = 6, // Unknown
        PlayerLeftStep = 7,         // LB
        PlayerRightStep = 8,        // RB
        PlayerStomping = 9,         // B
        PlayerAction = 10,          // Unknown
        PlayerActionAlways = 11,    // Unknown
        PlayerSmash = 12,           // Unknown
        CameraGaze = 13,            // RS
        PlayerSonicboom = 14        // LT
    }

    public static class Input
    {
        private enum ButtonState
        {
            Pressed,
            Down,
            Released
        }

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool _tCommonInputDel(long sonicContext, PlayerActionType actionType);

        /* 0x1408F6400 */
        private static long _sigIsPressed = ScanSignature
        (
            "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x63\xFA\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x48\x8B\x5C\x24\x30\x48\x8B\x80\x90\x00\x00\x00\x48\x8B\x48\x78\x0F\xB6\x44\xF9\x07\xD0",
            "xxxxxxxxxxxxxx????xxxx????xxxxxxx????xxxxxxxxxxxxxxxxxxxxxx"
        );
        
        /* 0x1408F65D0 */
        private static long _sigIsDown = ScanSignature
        (
            "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x63\xFA\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x48\x8B\x5C\x24\x30\x48\x8B\x80\x90\x00\x00\x00\x48\x8B\x48\x78\x0F\xB6\x44\xF9\x07\xF6",
            "xxxxxxxxxxxxxx????xxxx????xxxxxxx????xxxxxxxxxxxxxxxxxxxxxx"
        );

        /* 0x1408F6580 */
        private static long _sigIsReleased = ScanSignature
        (
            "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x63\xFA\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x48\x8B\x5C\x24\x30\x48\x8B\x80\x90\x00\x00\x00\x48\x8B\x48\x78\x0F\xB6\x44\xF9\x07\xC0",
            "xxxxxxxxxxxxxx????xxxx????xxxxxxx????xxxxxxxxxxxxxxxxxxxxxx"
        );

        private static bool CheckButtonState(ButtonState buttonState, PlayerActionType actionType)
        {
            long sonicContext = GetSonicContext();

            if (sonicContext == 0)
                return false;

            IntPtr functionPtr = IntPtr.Zero;

            switch (buttonState)
            {
                case ButtonState.Pressed:
                    functionPtr = (IntPtr)_sigIsPressed;
                    break;

                case ButtonState.Down:
                    functionPtr = (IntPtr)_sigIsDown;
                    break;

                case ButtonState.Released:
                    functionPtr = (IntPtr)_sigIsReleased;
                    break;
            }

            return Marshal.GetDelegateForFunctionPointer<_tCommonInputDel>(functionPtr)(sonicContext, actionType);
        }

        public static bool IsPressed(PlayerActionType actionType)
        {
            return CheckButtonState(ButtonState.Pressed, actionType);
        }

        public static bool IsDown(PlayerActionType actionType)
        {
            return !CheckButtonState(ButtonState.Down, actionType);
        }

        public static bool IsReleased(PlayerActionType actionType)
        {
            return CheckButtonState(ButtonState.Released, actionType);
        }
    }

    public class Kinematics
    {
        public Vector3* Position;
        public Quaternion* Rotation;
        public Vector3* Velocity;

        public Kinematics(long gocPlayerKinematicParams)
        {
            Position = (Vector3*)(gocPlayerKinematicParams + 0x80);
            Rotation = (Quaternion*)(gocPlayerKinematicParams + 0x90);
            Velocity = (Vector3*)(gocPlayerKinematicParams + 0xD0);
        }

        public static Kinematics Get()
        {
            long sonic = GetSonic();

            if (sonic == 0)
                return null;

            long gocPlayerKinematicParams = GameObject.GetGOC(sonic, "GOCPlayerKinematicParams");

            if (gocPlayerKinematicParams == 0)
                return null;

            return new Kinematics(gocPlayerKinematicParams);
        }

        public static Vector3 GetForward()
        {
            Kinematics k = Get();

            if (k == null)
                return Vector3.Zero;

            return Vector3.Transform(new Vector3(0.0f, 0.0f, 1.0f), Quaternion.Normalize(*k.Rotation));
        }

        public static float GetHorizontalMagnitude()
        {
            Kinematics k = Get();

            if (k == null)
                return 0.0f;

            Vector3* velocity = k.Velocity;

            if (velocity == null)
                return 0.0f;

            return (float)Math.Sqrt(velocity->X * velocity->X + velocity->Z * velocity->Z);
        }
    }

    public static class Message
    {
        private static bool _initialised = false;
        private static int _currentMessageID = -1;

        private static void Init()
        {
            if (_initialised)
                return;

            fixed (int* p_currentMessageID = &_currentMessageID)
            {
                WriteAsmHook
                (
                    $@"
                        mov    eax, [rdx + 8]
                        mov    r14, {(long)p_currentMessageID}
                        mov    dword ptr [r14], eax
                        mov    r14, rdx
                        movaps xmmword ptr [rsp + 0x260 + 0xFFFFFFFFFFFFFFD0], xmm6
                    ",

                    /* 0x140864C1B */
                    ScanSignature
                    (
                        "\x8B\x42\x08\x4C\x8B\xF2\x0F\x29\xB4\x24\x30\x02\x00\x00",
                        "xxxxxxxxxxxxxx"
                    ),

                    HookBehavior.Replace
                );
            }

            _initialised = true;
        }

        public static int GetMessageID()
        {
            Init();

            return _currentMessageID;
        }
    }

    public static class Sound
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate int* _tPlaySound(long pGOCSound, int* a2, long pSoundName, float a4);
        private static long _sigPlaySound = 0;

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate int* _tStopSound(int* pSoundHandle);
        private static long _sigStopSound = 0;

        public static int PlaySound(string soundName)
        {
            if (_sigPlaySound == 0)
            {
                /* 0x140AE69F0 */
                _sigPlaySound = ScanSignature
                (
                    "\x4C\x8B\xDC\x49\x89\x5B\x08\x57\x48\x81\xEC\x80\x00\x00\x00",
                    "xxxxxxxxxxxxxxx"
                );

                if (_sigPlaySound == 0)
                    return 0;
            }

            var fpPlaySound = Marshal.GetDelegateForFunctionPointer<_tPlaySound>((IntPtr)_sigPlaySound);

            if (fpPlaySound == null)
                return 0;

            long pSonic = GetSonic();

            if (pSonic == 0)
                return 0;

            long pGOCSound = GameObject.GetGOC(pSonic, "GOCSound");

            if (pGOCSound == 0)
                return 0;

            int zero = 0;
            
            return *fpPlaySound(pGOCSound, &zero, (long)Marshal.StringToHGlobalAnsi(soundName), 0.0f);
        }

        public static void StopSound(int* pSoundHandle)
        {
            if (_sigStopSound == 0)
            {
                /* 0x1405A90FF */
                _sigStopSound = ScanSignature
                (
                    "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x33\xD2\x48\x8B\xCF\xF3\x0F\x10\x90\x90\x00\x00\x00",
                    "x????xxxx????xxxxxxxxxxxxx"
                );

                if (_sigStopSound == 0)
                    return;

                _sigStopSound = Memory.ReadCall(_sigStopSound);
            }

            var fpStopSound = Marshal.GetDelegateForFunctionPointer<_tStopSound>((IntPtr)_sigStopSound);

            if (fpStopSound == null)
                return;

            fpStopSound(pSoundHandle);
        }
    }

    public enum StateID : int
    {
        Default = -1,
        StateAcceleCombo1 = 146,           // StateAttackRoot
        StateAcceleCombo2 = 147,           // StateAttackRoot
        StateAquaBallJump = 119,
        StateAquaBallStand = 118,
        StateAquaBallStomping = 120,
        StateAttackRoot = 131,
        StateAuraTrain = 188,
        StateAvoid = 137,
        StateAvoidLocal = 140,
        StateAvoidToTarget = 139,
        StateAvoidUpper = 138,
        StateAwakening = 26,
        StateBallMove = 169,
        StateBaseJump = 101,
        StateBatterBox = 200,
        StateBattleStart = 155,
        StateBoarding = 180,
        StateBossCounter = 156,
        StateBrake = 6,
        StateBrakeNeutral = 7,
        StateBreathe = 43,
        StateBumpJump = 16,
        StateCaught = 164,
        StateChargeAttack = 148,           // StateAttackRoot
        StateClimbing = 99,                // StateWallActionRoot
        StateClimbingEdge = 98,            // StateWallActionRoot
        StateCloudJump = 189,
        StateHomingFinish = 133,           // StateAttackRoot
        StateComboMove = 128,
        StateComboStep = 129,
        StateComboWarp = 130,
        StateCrasher = 150,                // StateAttackRoot
        StateCrossSlash = 152,             // StateAttackRoot
        StateDamage = 28,                  // StateDamageRoot
        StateDamageBlowOff = 30,           // StateDamageRoot
        StateDamageBlowOffHeavy = 31,      // StateDamageRoot
        StateDamageLava = 37,
        StateDamageQuake = 32,             // StateDamageRoot
        StateDamageRoot = 27,
        StateDamageRunning = 33,           // StateDamageRoot
        StateDamageTurnBack = 29,          // StateDamageRoot
        StateDead = 38,
        StateDebuff = 177,
        StateDestination = 185,
        StateDiving = 78,                  // StateDivingRoot
        StateDivingDamage = 80,            // StateDivingRoot
        StateDivingFall = 79,              // StateDivingRoot
        StateDivingRoot = 77,
        StateDivingSpecial = 83,           // StateDivingSpecialRoot
        StateDivingSpecialDamage = 86,     // StateDivingSpecialRoot
        StateDivingSpecialDashRing = 84,   // StateDivingSpecialRoot
        StateDivingSpecialFall = 85,       // StateDivingSpecialRoot
        StateDivingSpecialPush = 87,       // StateDivingSpecialRoot
        StateDivingSpecialRoot = 82,
        StateDivingSpring = 81,            // StateDivingRoot
        StateDrift = 109,
        StateDriftDash = 110,
        StateDriftAir = 111,
        StateDropDash = 112,
        StateFall = 15,
        StateFallWithKodama = 195,
        StateFallWithCannonball = 198,
        StateFallFlip = 22,
        StateFallingDead = 39,
        StateFallSlope = 21,
        StateFan = 168,
        StateFixedGoal = 126,
        StateFloat = 107,
        StateFly = 102,
        StateFlyLocal = 105,
        StateFlyLocal2D = 106,
        StateFlyOnPath = 104,
        StateFlyTurn = 103,
        StateGoal = 124,
        StateGoal2 = 125,
        StateGrind = 46,                   // StateGrindRoot
        StateGrindDamage = 49,             // StateGrindRoot
        StateGrindDamageAir = 50,          // StateGrindRoot
        StateGrindJump = 47,               // StateGrindRoot
        StateGrindDoubleJump = 48,         // StateGrindRoot
        StateGrindRoot = 45,
        StateGrindStep = 51,
        StateGuard = 145,
        StateGuardedFlipBack = 34,         // StateDamageRoot
        StateHangPole = 170,
        StateHangPoleJump = 171,
        StateHoldStand = 159,
        StateHomingAttack = 62,            // StateAttackRoot
        StateHomingAttackRoot = 61,        // StateAttackRoot
        StateHomingAttackInStorm = 63,     // StateAttackRoot
        StateHomingFinished = 64,          // StateAttackRoot
        StateHomingRepelled = 65,
        StateHomingShot = 153,             // StateAttackRoot
        StateImpactGimmick = 182,
        StateJump = 8,
        StateJumpWithKodama = 194,
        StateJumpBoardLaunch = 167,
        StateBounceJump = 11,
        StateRecoveryJump = 12,
        StateSpringJump = 162,
        StateSpringJumpHeadLand = 163,
        StateKickBox = 173,
        StateLavaDead = 44,
        StateLeftStep = 71,
        StateLeftStepRun = 73,
        PlayerStateLevitation = 211,
        StateLightDash = 25,
        StateLoopKick = 149,               // StateAttackRoot
        StateMoveInWarningArea = 186,
        StateMoveToBatterBox = 201,
        StateMoveToBossArea = 187,
        StateMoveToReflexesPanel = 203,
        StateNoisyGoal = 127,
        StateOperateConsole = 181,
        StateParalysis = 36,
        StateParriedFlipBack = 35,
        StateParry = 141,
        StateParryStand = 142,             // StateParry
        StatePipeMove = 165,
        StatePipeOut = 166,
        StatePressDead = 42,
        StatePursuitKick = 132,            // StateAttackRoot
        StatePushBox = 172,
        StateQuickCyloop = 134,            // StateAttackRoot
        StateQuickStep = 67,               // StateQuickStepRoot
        StateQuickStepCrash = 70,          // StateQuickStepRoot
        StateQuickStepJump = 75,
        StateQuickStepDoubleJump = 76,
        StateQuickStepLeft = 68,           // StateQuickStepRoot
        StateQuickStepRight = 69,          // StateQuickStepRoot
        StateQuickStepRoot = 66,
        StateRecoil = 20,
        StateRecovery = 161,
        StateReflexesPanel = 202,
        StateReflexesPanelLeftStep = 204,
        StateReflexesPanelRightStep = 205,
        StateRightStep = 72,
        StateRightStepRun = 74,
        StateRun = 4,
        StateRunWithKodama = 193,
        StateRunWithCannonball = 196,
        StateRunawayBee = 191,
        StateRunningStart = 123,
        StateSandSki = 174,
        StateSandSkiBlow = 175,
        StateSendSignal = 183,
        StateSleep = 0,
        StateSliding = 59,                 // StateSquatRoot
        StateSlidingToStand = 60,
        StateSlingshot = 176,
        StateSmash = 135,                  // StateAttackRoot
        StateSmashSS = 136,                // StateAttackRoot
        StateSonicBoomKick = 151,          // StateAttackRoot
        StateSpin = 113,
        StateSpinAttack = 14,
        StateSpinBoost = 116,
        StateSpinBoostCharge = 115,
        StateSpinMove = 117,
        StateSpinDash = 114,               // StateAttackRoot
        StateSpinSlash = 154,              // StateAttackRoot
        StateSquat = 19,                   // StateSquatRoot
        StateSquatRoot = 18,
        StateStandRoot = 1,
        StateStandWithKodama = 192,
        StateStand = 2,                    // StateStandRoot
        StateStandWithCannonball = 197,
        StateStolenEmerald = 179,
        StateStorm = 178,
        StateSuffocatingDead = 41,
        StateTakeBehind = 143,
        StateTakeBehindSS = 144,
        StateTalkMode = 160,
        StateThrowCannonball = 199,
        StateTreadmill = 190,
        StateTreeJump = 243,
        StateTumble = 17,
        StateTurn = 5,
        StateUpDead = 40,
        StateUpDownPole = 121,
        StateUpDownPoleDamage = 122,
        StateWakeUp = 3,
        StateWarpEnd = 158,
        StateWarpStart = 157,
        StateWaterFall = 184,
        StateAirBoost = 23,
        StateWithAnimalRoot = 206,
        StateFallWithAnimal = 210,         // StateWithAnimalRoot
        StateJumpWithAnimal = 209,         // StateWithAnimalRoot
        StateDoubleJump = 9,
        StateRunWithAnimal = 208,          // StateWithAnimalRoot
        StateStandWithAnimal = 207,        // StateWithAnimalRoot
        StateStomping = 52,                // StateAttackRoot
        StateStompingAttack = 55,          // StateAttackRoot
        StateStompingBounce = 58,          // StateAttackRoot
        StateStompingDown = 54,            // StateAttackRoot
        StateStompingFlip = 53,            // StateAttackRoot
        StateStompingLand = 57,            // StateAttackRoot
        StateStompingPress = 56,           // StateAttackRoot
        StateWallHanging = 90,             // StateWallActionRoot
        StateWallHoming = 92,
        StateWallJump = 96,
        StateWallJumpReady = 97,
        StateWallLanding = 93,             // StateWallActionRoot
        StateWallLeave = 100,
        StateWallReset = 95,               // StateWallActionRoot
        StateWallRest = 91,                // StateWallActionRoot
        StateWallSlideDown = 94,           // StateWallActionRoot
        StateWallActionRoot = 88,
        StateWallMove = 89                 // StateWallActionRoot
    }

    public static class State
    {
        private static bool _initialisedStateRedirector = false;
        private static List<StateID> _discardedStates = new();
        private static Dictionary<StateID, StateID> _redirectedStates = new();
        private static StateID _currentStateID = Sonic.StateID.Default;
        private static Collections.StackList<StateID> _stateStackTrace = new(10);

        public delegate void TStateNotifyAction(StateID stateId, StateID[] stateStackTrace);
        private static List<TStateNotifyAction> _stateNotifyActions = new();

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate int _tSetStateID(int stateId);
        private static _tSetStateID _delSetStateID = new _tSetStateID(SetStateID);
        private static IntPtr _fpSetStateID = Marshal.GetFunctionPointerForDelegate(_delSetStateID);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate long _tGetStatePlugin(long pStatePluginManager, uint pluginNameHash);
        private static long _sigGetStatePlugin = 0;

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate void _tSetState(long gocPlayerHsm, int stateId, int a3);
        private static long _sigSetState = 0;

        private static int SetStateID(int stateId)
        {
            if (stateId != -1)
            {
                _stateStackTrace.Push(_currentStateID);

                _currentStateID = (StateID)stateId;
            }

            foreach (TStateNotifyAction action in _stateNotifyActions)
                action(_currentStateID, _stateStackTrace.ToArray());

            if (_discardedStates.Contains((StateID)stateId))
                return -2;

            if (_redirectedStates.ContainsKey((StateID)stateId))
                return (int)_redirectedStates[(StateID)stateId];

            return stateId;
        }

        private static void InitStateRedirector()
        {
            if (_initialisedStateRedirector)
                return;

            WriteAsmHook
            (
                $@"
                    mov   edx, [rbx + 0x114]
                    mov   ecx, edx
                    mov   rax, {(long)_fpSetStateID}
                    call  rax
                    mov   edx, eax
                    cmp   edx, -2
                    jne   exit
                    mov   r15, qword ptr [rsp + 0x38 + 0xFFFFFFFFFFFFFFE8]
                    add   rsp, 0x28
                    pop   rbp
                    pop   rbx
                    ret
                exit:
                    movzx eax, byte ptr [rbx + 0x11C]
                ",

                /* 0x140802F2D */
                ScanSignature
                (
                    "\x8B\x93\x14\x01\x00\x00\x83\xFA\xFF",
                    "xxxxxxxxx"
                ),

                HookBehavior.Replace
            );

            _initialisedStateRedirector = true;
        }

        public static StateID GetCurrentStateID()
        {
            InitStateRedirector();

            return _currentStateID;
        }

        public static StateID GetPreviousStateID(int stackIndex = 0)
        {
            InitStateRedirector();

            return _stateStackTrace.GetItemAt(stackIndex);
        }

        public static long GetStatePlugin(string pluginName)
        {
            if (_sigGetStatePlugin == 0)
            {
                /* 0x140124200 */
                _sigGetStatePlugin = ScanSignature
                (
                    "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x20\x48\x8B\x59\x18\x8B",
                    "xxxxxxxxxxxxxxxxxxxxxxxxx"
                );

                if (_sigGetStatePlugin == 0)
                    return 0;
            }

            var fpGetStatePlugin = Marshal.GetDelegateForFunctionPointer<_tGetStatePlugin>((IntPtr)_sigGetStatePlugin);

            if (fpGetStatePlugin == null)
                return 0;

            long pSonicContext = GetSonicContext();

            if (pSonicContext == 0)
                return 0;

            return fpGetStatePlugin(*(long*)(*(long*)(pSonicContext + 0x38) + 0x108), StringMapOperation.ComputeHash(pluginName));
        }

        public static void AddStateNotifyAction(TStateNotifyAction action)
        {
            InitStateRedirector();

            if (_stateNotifyActions.Contains(action))
                return;

            _stateNotifyActions.Add(action);
        }

        public static void RemoveStateNotifyAction(TStateNotifyAction action)
        {
            InitStateRedirector();

            if (!_stateNotifyActions.Contains(action))
                return;

            _stateNotifyActions.Remove(action);
        }

        public static void Redirect(StateID source, StateID destination)
        {
            InitStateRedirector();

            if (_redirectedStates.ContainsKey(source))
            {
                _redirectedStates[source] = destination;
                return;
            }

            _redirectedStates.Add(source, destination);
        }

        public static void Discard(StateID source)
        {
            InitStateRedirector();

            if (_discardedStates.Contains(source))
                return;

            _discardedStates.Add(source);
        }

        public static void Restore(StateID source)
        {
            InitStateRedirector();

            if (_discardedStates.Contains(source))
                _discardedStates.Remove(source);
            
            if (_redirectedStates.ContainsKey(source))
                _redirectedStates.Remove(source);
        }

        public static void SetState(StateID destination)
        {
            if (_sigSetState == 0)
            {
                /* 0x140802400 */
                _sigSetState = ScanSignature
                (
                    "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x48\x8B\xD9\x41\x8B\xF8\x48\x81\xC1\x88\x00\x00\x00\x8B\xF2\xE8\xCC\xCC\xCC\xCC\x3B",
                    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx????x"
                );

                if (_sigSetState == 0)
                    return;
            }

            var fpSetState = Marshal.GetDelegateForFunctionPointer<_tSetState>((IntPtr)_sigSetState);

            if (fpSetState == null)
                return;

            long sonicContext = GetSonicContext();

            if (sonicContext == 0)
                return;

            fpSetState(Read<long>(sonicContext + 0x38), (int)destination, 0);
        }
    }
}

Library "StringMapOperation" by "ĐeäTh"
{
    public uint ComputeHash(string key)
    {
        uint hash = key[0];

        for (int i = 1; i < key.Length; i++)
            hash = key[i] + 31 * hash;

        return hash & 0x7FFFFFFF;
    }
}

Library "Time" by "Hyper"
{
    private static bool _initialised = false;
    private static float* _pFrameRate;

    private void Init()
    {
        if (_initialised)
            return;

        fixed (float** p_pFrameRate = &_pFrameRate)
        {
            WriteAsmHook
            (
                $@"
                    movss  xmm0, dword ptr [rcx + 0x14]
                    lea    rdi, qword ptr [rcx + 0x14]
                    movaps xmmword ptr [rsp + 0x58 + 0xFFFFFFFFFFFFFFE8], xmm6
                    mov    r9, {(long)p_pFrameRate}
                    mov    [r9], rcx
                    add    qword ptr [r9], 0x14
                ",

                /* 0x140BB9EDF */
                ScanSignature
                (
                    "\xF3\x0F\x10\x41\x14\x48\x8D\x79\x14",
                    "xxxxxxxxx"
                ),
                
                HookBehavior.Replace
            );
        }

        _initialised = true;
    }

    public float GetFrameRate()
    {
        Init();

        return _pFrameRate == null ? 0.0f : *_pFrameRate;
    }

    public float GetDeltaTime()
    {
        Init();

        return 1.0f / GetFrameRate();
    }
}

Library "VectorHelpers" by "Hyper"
{
    public static Quaternion LookRotation(Vector3 forward, Vector3 upwards)
    {
        forward = Vector3.Normalize(forward);
        upwards = Vector3.Normalize(upwards);

        Vector3 right = Vector3.Cross(upwards, forward);
        upwards = Vector3.Cross(forward, right);

        Matrix4x4 rotationMatrix = new Matrix4x4
        (
            right.X, right.Y, right.Z, 0.0f,
            upwards.X, upwards.Y, upwards.Z, 0.0f,
            forward.X, forward.Y, forward.Z, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f
        );

        return Quaternion.CreateFromRotationMatrix(rotationMatrix);
    }
}

Library "XInput" by "Hyper"
{
    #lib "MathHelpers"

    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Runtime.InteropServices;

    [DllImport("xinput1_4.dll", EntryPoint = "XInputGetState")]
    public extern int XInputGetState(int dwUserIndex, ref State pState);
    
    [DllImport("xinput1_4.dll", EntryPoint = "XInputSetState")]
    public extern int XInputSetState(int dwUserIndex, ref Vibration pVibration);

    public const short XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE = 7849;
    public const short XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE = 8689;

    public static float LeftMotorSpeed = 0.0f;
    public static float RightMotorSpeed = 0.0f;

    [Flags]
    public enum Buttons : ushort
    {
        DPAD_UP        = 0x0001,
        DPAD_DOWN      = 0x0002,
        DPAD_LEFT      = 0x0004,
        DPAD_RIGHT     = 0x0008,
        START          = 0x0010,
        BACK           = 0x0020,
        LEFT_THUMB     = 0x0040,
        RIGHT_THUMB    = 0x0080,
        LEFT_SHOULDER  = 0x0100,
        RIGHT_SHOULDER = 0x0200,
        A              = 0x1000,
        B              = 0x2000,
        X              = 0x4000,
        Y              = 0x8000
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct State
    {
        public int dwPacketNumber;
        public Gamepad Gamepad;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Gamepad
    {
        public Buttons wButtons;
        public byte bLeftTrigger;
        public byte bRightTrigger;
        public short sThumbLX;
        public short sThumbLY;
        public short sThumbRX;
        public short sThumbRY;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Vibration
    {
        public ushort wLeftMotorSpeed;
        public ushort wRightMotorSpeed;

        public Vibration(ushort leftMotorSpeed, ushort rightMotorSpeed)
        {
            wLeftMotorSpeed = leftMotorSpeed;
            wRightMotorSpeed = rightMotorSpeed;

            LeftMotorSpeed = leftMotorSpeed / 65535.0f;
            RightMotorSpeed = rightMotorSpeed / 65535.0f;
        }

        public Vibration(float leftMotorSpeed, float rightMotorSpeed)
        {
            wLeftMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(leftMotorSpeed);
            wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(rightMotorSpeed);

            LeftMotorSpeed = leftMotorSpeed;
            RightMotorSpeed = rightMotorSpeed;
        }

        public Vibration(ushort motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = motorSpeed;
            LeftMotorSpeed = RightMotorSpeed = motorSpeed / 65535.0f;
        }

        public Vibration(float motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(motorSpeed);
            LeftMotorSpeed = RightMotorSpeed = motorSpeed;
        }
    }

    public State? GetState()
    {
        var pState = new State();

        if (XInputGetState(0, ref pState) != 0)
            return null;

        return pState;
    }

    public void SetState(Vibration pVibration)
    {
        XInputSetState(0, ref pVibration);
    }

    public Vector2 GetAnalog(int analogIndex, bool testDeadzone = true)
    {
        var pState = GetState();

        if (pState == null)
            return Vector2.Zero;

        Vector2 v = Vector2.Zero;

        switch (analogIndex)
        {
            case 0:
                v = new Vector2(pState.Value.Gamepad.sThumbLX / 32767.0f, pState.Value.Gamepad.sThumbLY / 32767.0f);
                break;

            case 1:
                v = new Vector2(pState.Value.Gamepad.sThumbRX / 32767.0f, pState.Value.Gamepad.sThumbRY / 32767.0f);
                break;
        }

        if (testDeadzone)
        {
            v = IsAnalogNeutral(analogIndex)
                ? Vector2.Zero
                : v;
        }

        return v;
    }

    // Use Sonic.Input for keyboard parity!
    public bool IsButtonDown(Buttons buttons)
    {
        var pState = GetState();

        if (pState == null)
            return false;

        return (pState.Value.Gamepad.wButtons & buttons) != 0;
    }

    public float GetTrigger(int triggerIndex)
    {
        var pState = GetState();

        if (pState == null)
            return 0;

        switch (triggerIndex)
        {
            case 0:
                return pState.Value.Gamepad.bLeftTrigger / 255.0f;

            case 1:
                return pState.Value.Gamepad.bRightTrigger / 255.0f;
        }

        return 0;
    }

    public bool IsAnalogNeutral(int analogIndex)
    {
        var pState = GetState();

        if (pState == null)
            return true;

        switch (analogIndex)
        {
            case 0:
            {
                short x = pState.Value.Gamepad.sThumbLX;
                short y = pState.Value.Gamepad.sThumbLY;

                return x < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE;
            }

            case 1:
            {
                short x = pState.Value.Gamepad.sThumbRX;
                short y = pState.Value.Gamepad.sThumbRY;

                return x < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE;
            }
        }

        return true;
    }

    public void SetVibration(float value)
    {
        SetState(new Vibration(MathHelpers.FloatPercentToRange<ushort>(value)));
    }

    public void SetVibration(int motorIndex, float value)
    {
        switch (motorIndex)
        {
            case 0:
            {
                SetState(new Vibration(value, RightMotorSpeed));
                break;
            }

            case 1:
            {
                SetState(new Vibration(LeftMotorSpeed, value));
                break;
            }
        }
    }
}

Patch "2x Extended Grass Draw Distance" in "Graphics" by "Hyper" does "Extends the draw distance of the grass past the visible horizon."
//
    static float Range = 3.0f;
//
{
    fixed (float* pRange = &Range)
    {
        WriteAsmHook
        (
            $@"
                push  rax
                mov   rax, {(long)pRange}
                movss xmm0, dword ptr [rax]
                movss dword ptr [rbp + 0x290 + 0xFFFFFFFFFFFFFDD0 + 0x08], xmm2
                pop   rax
            ",

            /* 0x140F1A885 */
            ScanSignature
            (
                "\xF3\x41\x0F\x10\x87\xB8\x02\x00\x00\xF3\x0F\x11\x55\x68",
                "xxxxxxxxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}

Patch "2x Extended Foliage Draw Distance" in "Graphics" by "Hyper" does "Extends the draw distance of foliage (trees, bushes, etc.) past the visible horizon."
//
    static float Range = 3.0f;
//
{
    /* 0x140F16DB7 */
    var sig = ScanSignature
    (
        "\xF3\x41\x0F\x10\x87\xB8\x02\x00\x00\xF3\x0F\x11\x95\x98\x00\x00\x00",
        "xxxxxxxxxxxxxxxxx"
    );

    if (sig == 0)
        return;

    fixed (float* pRange = &Range)
    {
        WriteAsmHook
        (
            $@"
                push  rax
                mov   rax, {(long)pRange}
                movss xmm0, dword ptr [rax]
                movss dword ptr [rbp + 0x290 + 0xFFFFFFFFFFFFFE00 + 0x08], xmm2
                pop   rax
            ",

            sig,

            HookBehavior.Replace
        );
    }
}

Patch "4x Extended Foliage Draw Distance" in "Graphics" by "Hyper" does
/*
Extends the draw distance of foliage (trees, bushes, etc.) past the visible horizon.

WARNING: this will almost definitely cause performance issues, especially if you're already extending the grass draw distance.
*/
//
    static float Range = 5.0f;
//
{
    /* 0x140F16DB7 */
    var sig = ScanSignature
    (
        "\xF3\x41\x0F\x10\x87\xB8\x02\x00\x00\xF3\x0F\x11\x95\x98\x00\x00\x00",
        "xxxxxxxxxxxxxxxxx"
    );

    if (sig == 0)
        return;

    fixed (float* pRange = &Range)
    {
        WriteAsmHook
        (
            $@"
                push  rax
                mov   rax, {(long)pRange}
                movss xmm0, dword ptr [rax]
                movss dword ptr [rbp + 0x290 + 0xFFFFFFFFFFFFFE00 + 0x08], xmm2
                pop   rax
            ",

            sig,

            HookBehavior.Replace
        );
    }
}

Code "Additive Spring Trajectory with Boost" in "Gameplay" by "WasifBoomz" does "Keeps your velocity upon hitting a vertical spring while boosting."
//
    #lib "Sonic"
    #lib "Bitwise"
    #lib "BlackboardStatus"
	
    #load "System.Numerics.dll"
	
    using System;
    using System.Numerics;
    using System.Collections.Generic;
	
    static int framesSinceHit = 0;
    static bool boosting = false;
    static bool isInitialised = false;
    static Vector3 prevVelocity;
//
{
    Sonic.Kinematics kinematics = Sonic.Kinematics.Get();

    if (!isInitialised)
    {
        long aSpringJump = ScanSignature
        (
            "SPRING_JUMP",
            "xxxxxxxxxxx"
        );

        long ChangeAnimLocation = ScanSignature
        (
            "\x40\x53\x48\x83\xEC\x20\xF6\x81\x78\x01\x00\x00\x10\x48\x8B\xDA",
            "xxxxxxxxxxxxxxxx"
        );

        fixed (bool* pBoosting = &boosting)
        fixed (int* pFramesSinceHit = &framesSinceHit)
        {
            WriteAsmHook
            (
                $@"
                    mov  rax, {(long)aSpringJump}
                    cmp  rdx, rax
                    jnz  original
                    mov  rcx, {(long)pBoosting}
                    cmp  byte ptr [rcx], 0
                    jz   original
                    mov  rax, {(long)pFramesSinceHit}
                    mov  byte ptr [rax], 1
                original:
                    mov  r8b, 0FEh
                    mov  rcx, rbx
                    mov  rax, {(long)ChangeAnimLocation}
                    call rax
                    mov  edx, [rbp+0DCh]
                ",
                    
                /* 0x1408C1B02 */
                ScanSignature(
                    "\x41\xB0\xFE\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x8B\x95\xDC\x00\x00\x00",
                    "xxxxxxx????xxxxxx"
                ),
                    
                HookBehavior.Replace
            );
        }

        isInitialised = true;
    }

    if (kinematics == null)
        return;
    
    if (BlackboardStatus.Get() == 0)
        return;

    boosting = Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsBoost);

    switch (framesSinceHit)
    {
        case 0:
            prevVelocity = *kinematics.Velocity;
            break;

        case 1:
            Sonic.State.SetState(Sonic.StateID.StateBumpJump);
            framesSinceHit++;
            break;

        case 2:
        {
            if (Sonic.Kinematics.GetHorizontalMagnitude() < Math.Abs(kinematics.Velocity->Y))
                    *kinematics.Velocity += new Vector3(prevVelocity.X, 0, prevVelocity.Z);

            framesSinceHit = 0;

            break;
        }

        default:
            framesSinceHit = 1;
            break;
    }
}

Code "Adjust Aspect Ratio to Resolution (experimental)" in "Graphics" by "M&M & Hyper" does
/*
Dynamically adjusts the aspect ratio to match the game resolution (recommended for non-16:9 resolutions).

Notes;
- The UI will be stretched automatically for square or portrait resolutions.

Known issues;
- Certain UI effects are rendered at the correct aspect ratio, but will misalign due to the main UI still being 16:9.
- Certain UI elements are still rendered at 16:9 and will misalign or stretch.
- Certain UI elements will be cut off incorrectly at wider aspect ratios. (ex. Jukebox)
- Pre-rendered cutscenes will stretch to your aspect ratio.
- The letterboxing during cutscenes will end up blocking the view at wider aspect ratios, it is highly recommended to use the Disable In-Game Letterboxing code to remove it.
- The expected aspect ratio will only apply to a newly set resolution when you re-enter the resolution list and select the same resolution again.
- Vignette (the circular shadowing effect on the screen) is still rendered at 16:9, it is highly recommended to use the Disable Vignette code to remove it.
*/
//
    #load "System.Drawing.dll"

    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    struct RECT
    {
        public int Left;
        public int Top;
        public int Right;
        public int Bottom;
    }

    [DllImport("user32.dll")]
    static extern bool GetClientRect(IntPtr hWnd, ref RECT lpRect);

    static bool Initialised = false;

    static float AspectRatio = 1920.0f / 1080.0f;
    static float EventFieldOfView = 0.0f;

    static long MainAspectRatioAddr = 0;
    static long SurfRideAspectRatioAddr = 0;
    static long SurfRideAspectRatioJumpAddr = 0;
    static long DVSceneAspectRatioAddr = 0;
//
{
    if (!Initialised)
    {
        long mainAspectRatioInstrAddr = ScanSignature
        (
            /* 0x14014BD46 */
            "\xF3\x0F\x59\x0D\x00\x00\x00\x00\x44\x8B\x84\x24\x00\x00\x00\x00\xF3\x0F\x2C\xD1\xEB\x0C\x8B\x94\x24\x00\x00\x00\x00\xF3\x44\x0F\x2C\xC0\x3B\x54\x24\x34\x75\x07\x44\x3B\x44\x24\x00\x74\x0C\x48\x8B\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xCF",
            "xxxx????xxxx????xxxxxxxxx????xxxxxxxxxxxxxxx?xxxxx????x????xxx"
        );

        /* 0x14126A22C */
        MainAspectRatioAddr = mainAspectRatioInstrAddr + Read<uint>(mainAspectRatioInstrAddr + 4) + 8;

        /* 0x140A4166B */
        SurfRideAspectRatioAddr = ScanSignature
        (
            "\x0F\x84\x98\x00\x00\x00\x48\x8B\x4E\x48",
            "xxxxxxxxxx"
        );

        /* 0x140A41709 */
        SurfRideAspectRatioJumpAddr = SurfRideAspectRatioAddr + Read<int>(SurfRideAspectRatioAddr + 2) + 6;

        /* 0x140C33A2C */
        DVSceneAspectRatioAddr = ScanSignature
        (
            "\xC7\x81\x00\x00\x00\x00\x00\x00\x00\x00\x0F\x28\x05\x00\x00\x00\x00\x0F\x29\x81\x00\x00\x00\x00\x0F\x28\x0D\x00\x00\x00\x00",
            "xx????????xxx????xxx????xxx????"
        );

        fixed (float* pAspectRatio = &AspectRatio)
        fixed (float* pEventFieldOfView = &EventFieldOfView)
        {
            WriteAsmHook
            (
                $@"
                    push   r9

                    ; check if current event aspect ratio has been modified
                    mov    r9, {(long)pAspectRatio}
                    movss  xmm0, dword ptr [r9]
                    movss  xmm1, dword ptr [rbx + 0x58]
                    comiss xmm0, xmm1
                    je     exit

                    ; multiply original aspect ratio by new aspect ratio
                    movss  xmm0, dword ptr [rbx + 0x58]
                    mov    r9, {(long)pAspectRatio}
                    movss  xmm1, dword ptr [r9]
                    divps  xmm0, xmm1
                    movss  xmm1, xmm0

                    ; compute new field of view from aspect ratio difference
                    movss  xmm0, dword ptr [rbx + 0x54]
                    mulps  xmm0, xmm1
                    movss  dword ptr [rbx + 0x54], xmm0
                    mov    r9, {(long)pEventFieldOfView}
                    movss  dword ptr [r9], xmm0

                    ; set new aspect ratio
                    mov    r9, {(long)pAspectRatio}
                    mov    r9d, dword ptr [r9]
                    mov    dword ptr [rbx + 0x58], r9d
                exit:
                    pop    r9
                    movups xmm0, xmmword ptr [rbx + 0x4C]
                    movups xmmword ptr [r13], xmm0
                    movups xmm1, xmmword ptr [rbx + 0x5C]
                    movups xmmword ptr [r13 + 0x10], xmm1
                ",

                /* 0x140FB1CF0 */
                ScanSignature
                (
                    "\x0F\x10\x43\x4C\x41\x0F\x11\x45\x00",
                    "xxxxxxxxx"
                ),

                HookBehavior.Replace
            );
        }

        // Disable letterboxing for square/portrait resolutions.
        WriteNop
        (
            /* 0x14014BD44 */
            ScanSignature
            (
                "\x76\x16\xF3\x0F\x59\x0D",
                "xxxxxx"
            ),

            2
        );

        Initialised = true;
    }

    if (MainAspectRatioAddr == 0)
        return;

    RECT clientRect = new RECT();

    if (!GetClientRect(Process.GetCurrentProcess().MainWindowHandle, ref clientRect))
        return;

    float width  = (float)(clientRect.Right - clientRect.Left);
    float height = (float)(clientRect.Bottom - clientRect.Top);

    AspectRatio = width / height;

    // Set UI stretch mode based on current aspect ratio.
    if (SurfRideAspectRatioAddr != 0 && SurfRideAspectRatioJumpAddr != 0)
    {
        if (AspectRatio < (16.0f / 9.0f))
        {
            WriteNop(SurfRideAspectRatioAddr, 6);
        }
        else
        {
            WriteProtected<byte>(SurfRideAspectRatioAddr, 0x0F, 0x84);
            WriteProtected<int>(SurfRideAspectRatioAddr + 2, (int)(SurfRideAspectRatioJumpAddr - SurfRideAspectRatioAddr) - 6);
        }
    }

    WriteProtected<float>(MainAspectRatioAddr, AspectRatio);

    if (DVSceneAspectRatioAddr != 0)
        WriteProtected<float>(DVSceneAspectRatioAddr + 6, AspectRatio);
}

Code "Air Trick from Rails" in "Gameplay" by "Hyper" does
/*
Allows Sonic to perform Air Tricks when jumping off of grind rails.

Notes;
- Holding the jump button whilst jumping off of a grind rail will keep you in the usual grind jump state until released.
- Releasing the jump button will give you a small frame window where you can perform a double jump.
- Flinging off of a grind rail will automatically begin tricking.
*/
//
    #lib "Sonic"

    static bool BeginFrameCount = false;

    static long GrindJumpReleaseFrameCount = 0;

    static void ResetMembers()
    {
        BeginFrameCount = false;
        GrindJumpReleaseFrameCount = 0;
    }
//
{
    // Current: StateFall, Previous: StateGrind
    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateFall && Sonic.State.GetPreviousStateID() == Sonic.StateID.StateGrind)
    {
        // Enter into StateBumpJump when flinging off of grind rails.
        Sonic.State.SetState(Sonic.StateID.StateBumpJump);
    }

    // StateGrindJump
    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateGrindJump)
    {
        if (Sonic.Input.IsReleased(Sonic.PlayerActionType.PlayerJump))
            BeginFrameCount = true;

        if (BeginFrameCount)
            GrindJumpReleaseFrameCount++;

        // Provide small frame window to allow for StateGrindDoubleJump.
        if (GrindJumpReleaseFrameCount > 12)
        {
            Sonic.State.SetState(Sonic.StateID.StateBumpJump);

            ResetMembers();
        }
    }
    else
    {
        ResetMembers();
    }
}

Code "Allow Attacking from Stomp Bounce" in "Gameplay" by "Hyper"
//
    #lib "Sonic"
//
{
    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateBounceJump)
    {
        if (Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerAttack))
            Sonic.State.SetState(Sonic.StateID.StateFall);
    }
}

Patch "Allow Boost to Damage Objects" in "Gameplay" by "Hyper" does "Allows Sonic to damage enemies and harder physics objects by boosting through them."
//
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "Sonic"

    static bool IsBoostPrevious = false;
//
{
    void NotifyStateRunDamageCollision(Sonic.StateID stateId, Sonic.StateID[] stateStackTrace)
    {
        if (BlackboardStatus.Get() != 0)
        {
            bool isStateRun = stateId == Sonic.StateID.StateRun;
            bool isBoost = Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsBoost);

            if (isStateRun && isBoost)
            {
                Sonic.Collision.SetCollisionSphere(Sonic.CollisionType.Damage, 1.0f);
                Sonic.Collision.ToggleEntityCollision(false);
                IsBoostPrevious = true;
            }
            else if (IsBoostPrevious)
            {
                Sonic.Collision.SetCollisionSphere(Sonic.CollisionType.Default, 1.0f);
                Sonic.Collision.ToggleEntityCollision(true);
                IsBoostPrevious = false;
            }
        }
    }

    Sonic.State.AddStateNotifyAction(NotifyStateRunDamageCollision);
}

Code "Allow Cyclone Kick for Traversal" in "Gameplay" by "WasifBoomz" does "Allows Sonic to use the Cyclone Kick for traversal by pressing the attack button while holding the jump button."
//
    #lib "Sonic"
    #lib "Bitwise"
    #lib "BlackboardStatus"

    static Sonic.StateID[] enableStates =
    {
        Sonic.StateID.StateJump,
        Sonic.StateID.StateBounceJump,
        Sonic.StateID.StateGrind,
        Sonic.StateID.StateSpringJump
    };

    static bool allowChargeAttack = false;
//
{
    if (BlackboardStatus.Get() == 0)
        return;

    var state = Sonic.State.GetCurrentStateID();

    if (Sonic.IsGrounded())
        allowChargeAttack = true;

    if (Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsWallClimb))
        allowChargeAttack = true;

    for (int i = 0; i < enableStates.Length; i++)
    {
        if (state == enableStates[i])
            allowChargeAttack = true;
    }

    if (allowChargeAttack && Sonic.Input.IsDown(Sonic.PlayerActionType.PlayerJump) && Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerAttack))
    {
        Sonic.State.SetState(Sonic.StateID.StateChargeAttack);
        allowChargeAttack = false;
    }
}

Code "Allow Dodging from Homing Shot" in "Gameplay" by "Hyper" does "Allows Sonic to exit from Homing Shot by dodging."
//
    #lib "Sonic"
//
{
    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateHomingShot)
    {
        if (Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerLeftStep) ||
            Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerRightStep))
        {
            // Exit into StateAvoid.
            Sonic.State.SetState(Sonic.StateID.StateAvoid);
        }
    }
}

Patch "Always Allow Unlocking Story Skills" in "Cheats" by "Hyper" does
/*
Allows the skills typically obtained through story progression to be unlocked as regular skills for free.

Affected skills;
- Grand Slam
- Cyclone Kick
- Cross Slash
*/
//
    static int Seek = 0;
//
{
    fixed (int* pSeek = &Seek)
    {
        WriteAsmHook
        (
            $@"
                push  rax
                push  rbx
                mov   rax, {(long)pSeek}
            iterate:
                cmp   dword ptr [rax], 0x3C ; 60 (fixed array size of 20 elements, each are 3 bytes total)
                jge   exit
                mov   ebx, dword ptr [rax]
                add   rbx, rdx
                cmp   byte ptr [rbx], 0xFF  ; check 'unlockPoint' field, 0xFF is reserved for story skills
                jne   notStorySkill         ; not 0xFF, so don't perform any operations on this element
                mov   byte ptr [rbx], 0     ; set 'unlockPoint' to zero, who needs skill points anyway?
                mov   byte ptr [rbx + 2], 0 ; set 'present' field to zero, this'll treat the skill as a normal one
            notStorySkill:
                add   dword ptr [rax], 3    ; increment by three to reach the next element in the next iteration
                jmp   iterate
            exit:
                mov   dword ptr [rax], 0    ; reset incrementation, this code runs every time the skill tree opens, so we'll be back
                pop   rbx
                pop   rax
                movzx edi, byte ptr [r14 + rax * 8 + 0x30]
                movzx ecx, byte ptr [rdx + 1]
                imul  edi, ecx
                add   dil, [rdx]
            ",

            /* 0x1409507C0 */
            ScanSignature
            (
                "\x41\x0F\xB6\x7C\xC6\x30",
                "xxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}

Patch "Allow Spin Dash on Dash Panels" in "Gameplay" by "Hyper" does "Allows Sonic to Spin Dash through dash panels without interruptions."
{
    WriteProtected<byte>
    (
        /* 0x140862428 */
        ScanSignature
        (
            "\x41\x0F\x94\xC4\xD0\xE9",
            "xxxxxx"
        ),

        Assemble("mov r12b, 0; nop")
    );
}

Patch "Always Cloudy on Islands" in "Weather" by "Hyper" does
/*
Forces the weather to Cloudy on supported islands.

Supported islands;
- Kronos
- Ares
- Chaos
- Rhea
- Ouranos
*/
//
    #lib "Memory"
//
{
    void NOP(long addr)
        => WriteProtected<byte>(addr, 0xEB, 0x4E);

    /* 0x1401EE652 */
    long callerFuncAddr = ScanSignature
    (
        "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCB\x8B\xF0\xE8\xCC\xCC\xCC\xCC\x8B\xF8",
        "x????xxxxxx????xx"
    );

    /* 0x1401EE3ED */
    NOP(Memory.ReadCall(callerFuncAddr) + 0x2D);

    /* 0x1401EE4DD */
    NOP(Memory.ReadCall(callerFuncAddr + 0x0A) + 0x2D);
}

Patch "Always Day on Islands" in "Time" by "NM"
{
    /*
        When forcing the hours, minutes, and seconds opcodes to all write static values, the game will freeze shortly after a save is loaded. This is caused by two opcodes that seemingly invoke a loop until two addresses match in value. These two addresses can either be hours or minutes.
        At the moment, NOPing the JNE of these fixes this, and does not seem to cause any other issues.
    */

    /* 0x147E382AB */
    WriteNop
    (
        ScanSignature
        (
            "\x75\x27\x41\x8B\x40\x08\x39\x42\x08\x75\x1B\xF3\x0F\x10\x42\x0C\xF3\x41\x0F\x5C\x40\x0C\x0F\x54\x05\x78\xD7\x23\xF9\x0F\x2F\x05\x69\xD7\x23\xF9\x76\x5C\x45\x39\xD1\x72\x5A\x75\x17\x8B\x42\x08\x41\x3B\x40\x08\x72\x4F\x75\x0C",
            "x?xxx?xx?x?xxxx?xxxxx?xxx????xxx????x?xxxx?x?xx?xxx?x?x?"
        ),

        2
    );

    /* 0x147E382B4 */
    WriteNop
    (
        ScanSignature
        (
            "\x75\x1B\xF3\x0F\x10\x42\x0C\xF3\x41\x0F\x5C\x40\x0C\x0F\x54\x05\x78\xD7\x23\xF9\x0F\x2F\x05\x69\xD7\x23\xF9\x76\x5C\x45\x39\xD1\x72\x5A\x75\x17\x8B\x42\x08\x41\x3B\x40\x08\x72\x4F\x75\x0C\xF3\x41\x0F\x10\x40\x0C\x0F\x2F\x42",
            "x?xxxx?xxxxx?xxx????xxx????x?xxxx?x?xx?xxx?x?x?xxxxx?xxx"
        ),

        2
    );

    WriteAsmHook
    (
        @"
            add dword ptr [rcx], edx
            mov dword ptr [rcx+04h], 8h ; Hours
            mov dword ptr [rcx+08h], 0h ; Minutes
            mov dword ptr [rcx+0x0C], 0h ; Seconds
        ",

        /* 0x147E22D2B */
        ScanSignature
        (
            "\x01\x11\x44\x01\x41\x04\x44\x01\x49\x08\xF3\x0F\x11\x41\x0C\xE9\x91\x12\x1F\xF8",
            "xxxxx?xxx?xxxx?x????"
        ),

        HookBehavior.Replace
    );
}

Code "Always Dodge with Side Step" in "Gameplay" by "Hyper" does "Always makes Sonic dodge left or right instead of side stepping whilst not running."
//
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "Memory"
    #lib "Sonic"

    static bool IsInitialised = false;
    static bool IsAutoRun = false;
    static bool IsCyberSpace = false;
    static bool IsAboveVelocityThreshold = false;
//
{
    if (!IsInitialised)
    {
        fixed (bool* pIsCyberSpace = &IsCyberSpace)
        {
            /* 0x14BB219E0 */
            long sig = ScanSignature
            (
                "\x0F\x29\x7C\x24\x70\x48\x8B\x49\x28",
                "xxxxxxxxx"
            );

            if (sig == 0)
                return;

            // StateStand
            WriteAsmHook
            (
                $@"
                    movaps xmmword ptr [rsp + 0x88 + 0xFFFFFFFFFFFFFFE8], xmm7
                    mov    rcx, qword ptr [rcx + 0x28]
                    mov    edx, 5
                    mov    rax, {(long)pIsCyberSpace}
                    cmp    byte ptr [rax], 0
                    jnz    exit
                    mov    rax, {Memory.ReadJump(sig + 0x15)}
                    jmp    rax
                exit:
                ",

                sig,

                HookBehavior.Replace
            );
            
            /* 0x1408FE17A */
            sig = ScanSignature
            (
                "\x0F\x29\x70\xE8\x48\x8B\x49\x28\xBA\x05\x00\x00\x00\x0F\x29\x78\xD8\xE8\xCC\xCC\xCC\xCC\x84\xC0\x0F\x84\xBD\x02\x00\x00",
                "xxxxxxxxxxxxxxxxxx????xxxxxxxx"
            );

            if (sig == 0)
                return;

            fixed (bool* pIsAutoRun = &IsAutoRun)
            fixed (bool* pIsAboveVelocityThreshold = &IsAboveVelocityThreshold)
            {
                // StateRun
                WriteAsmHook
                (
                    $@"
                        movaps xmmword ptr [rax - 0x18], xmm6
                        mov    rcx, qword ptr [rcx + 0x28]
                        mov    edx, 5
                        movaps xmmword ptr [rax - 0x28], xmm7
                        mov    rax, {(long)pIsCyberSpace}
                        cmp    byte ptr [rax], 0
                        jnz    exit
                        mov    rax, {(long)pIsAutoRun}
                        cmp    byte ptr [rax], 0
                        jnz    exit
                        mov    rax, {(long)pIsAboveVelocityThreshold}
                        cmp    byte ptr [rax], 0
                        jnz    exit
                        mov    rax, {Memory.ReadJump(sig + 0x18)}
                        jmp    rax
                    exit:
                    ",

                    sig,

                    HookBehavior.Replace
                );
            }
        }

        IsInitialised = true;
    }

    if (BlackboardStatus.Get() == 0)
        return;

    IsAutoRun = Bitwise.Test(*BlackboardStatus.GetWorldFlags(), (uint)BlackboardStatus.WorldFlags.IsAutoRun);
    IsCyberSpace = Bitwise.Test(*BlackboardStatus.GetWorldFlags(), (uint)BlackboardStatus.WorldFlags.IsCyberSpace);
    IsAboveVelocityThreshold = Sonic.Kinematics.GetHorizontalMagnitude() >= 15.0f;
}

Patch "Always Have All Abilities" in "Gameplay" by "Hyper" does
/*
Always grants Sonic his abilities (not skills), even when scripted not to have them.

Abilities;
- Boost
- Combos
- Camera Control
- Cyloop
- Homing Attack
- Jump
- Lock-on
- Parry
- Wall Climbing
*/
{
    WriteProtected<byte>
    (
        /* 0x14BF81B71 */
        ScanSignature
        (
            "\x40\x0F\x95\xD5\x84\xD2",
            "xxxxxx"
        ),

        Assemble("mov bpl, 1; nop")
    );
}

Patch "Always Have Phantom Rush" in "Cheats" by "NM"
{
    WriteNop
    (
        /* 0x140779819 */
        ScanSignature
        (
            "\x72\x09\x66\x83\x89\xF0\x00\x00\x00\x40\xC3\x0F\x2F\xC2\x77\x0C\xB8\xBF\xFF\x00\x00\x66\x21\x81\xF0\x00\x00\x00\xC3",
            "x?xxx????xxxxxx?xxxxxxxx????x"
        ),

        2
    );
}

Patch "Always Have Power Boost on Islands" in "Cheats" by "SuperSonic16"
{
    WriteProtected<byte>
    (
        /* 0x1408D27AA */
        ScanSignature
        (
            "\x74\x2A\x0F\xBE\x43\x30\x66\x0F\x6E\xC8\x0F\xBE\x43\x31\x0F\x5B\xC9\x66\x0F\x6E\xC0\x0F\x5B\xC0\xF3\x0F\x5C\xC8\x0F\x54\x0D\xCC\xCC\xCC\xCC\x0F\x2F\x0D\xCC\xCC\xCC\xCC\x77\x15\xBA\x32\x00\x00\x00\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x84\xC0\x74\x04\xB0\x01",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx????xxx????xxxxxxxxxxx????xxxxxx"
        ),

        0xEB
    );
}

Patch "Always Have Power Boost in Cyber Space" in "Cheats" by "Hyper"
{
    WriteNop
    (
        /* 0x1408D27E5 */
        ScanSignature
        (
            "\x74\x04\xB0\x01\xEB\x02\x32\xC0\xF3\x0F\x10\x47\x50",
            "xxxxxxxxxxxxx"
        ),

        2
    );
}

Code "Always Hide Mouse Cursor" in "System" by "Hyper & Sajid" does
/*
Keeps the mouse cursor hidden at all times when the game window is focused.

This prevents the mouse cursor appearing under certain conditions, even if the primary input method is a controller.
*/
//
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    [DllImport("user32.dll")]
    static extern IntPtr GetForegroundWindow();

    [DllImport("user32.dll")]
    static extern int ShowCursor(bool bShow);

    static IntPtr HWND = IntPtr.Zero;
//
{
    if (HWND == IntPtr.Zero)
    {
        HWND = Process.GetCurrentProcess().MainWindowHandle;
    }
    else
    {
        ShowCursor(GetForegroundWindow() != HWND);
    }
}

Patch "Always Play 'One Way Dream' During Credits" in "Audio" by "M&M"
{
    /* v1.30: 0x1401C8AF3 */
    WriteProtected<byte>
    (
        ScanSignature
        (
            "\x3C\x02\x0F\x8D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xD0",
            "xxxx????x????xxx"
        ),

        0xE9, 0xAF, 0x05, 0x00, 0x00
    );

    /* v1.30: 0x14092A2AD */
    WriteNop
    (
        ScanSignature
        (
            "\x3C\x02\x7C\x3C\x0F\x28\x05\x00\x00\x00\x00\x48\x8D\x54\x24\x00",
            "xxxxxxx????xxxx?"
        ),

        4
    );
}

Patch "Always Play 'Vandalize' During Credits" in "Audio" by "M&M"
{
    /* v1.30: 0x1401C8AF3 */
    WriteNop
    (
        ScanSignature
        (
            "\x3C\x02\x0F\x8D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xD0",
            "xxxx????x????xxx"
        ),

        8
    );

    /* v1.30: 0x14092A2AD */
    WriteProtected<byte>
    (
        ScanSignature
        (
            "\x3C\x02\x7C\x3C\x0F\x28\x05\x00\x00\x00\x00\x48\x8D\x54\x24\x00",
            "xxxxxxx????xxxx?"
        ),

        0xEB, 0x3E
    );
}

Patch "Always Rainy on Islands" in "Weather" by "Hyper" does
/*
Forces the weather to Rainy on supported islands.

Supported islands;
- Kronos
- Chaos
- Rhea
- Ouranos
*/
//
    #lib "Memory"
//
{
    void NOP(long addr)
        => WriteProtected<byte>(addr, 0xEB, 0x38);

    /* 0x1401EE652 */
    long callerFuncAddr = ScanSignature
    (
        "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCB\x8B\xF0\xE8\xCC\xCC\xCC\xCC\x8B\xF8",
        "x????xxxxxx????xx"
    );

    /* 0x1401EE3ED */
    NOP(Memory.ReadCall(callerFuncAddr) + 0x2D);

    /* 0x1401EE4DD */
    NOP(Memory.ReadCall(callerFuncAddr + 0x0A) + 0x2D);
}

Patch "Always Respawn Enemies" in "Enemy" by "Hyper" does "Always respawns enemies and guardians when loading back into islands."
{
    WriteProtected<byte>
    (
        /* 0x14922FB24 */
        ScanSignature
        (
            "\x0F\x88\x6D\x01\x00\x00\xE8",
            "xxxxxxx"
        ),

        0xE9, 0x6E, 0x01, 0x00, 0x00
    );
}

Patch "Always Run in the Background" in "System" by "NM" does "Stops the game from pausing when the window is unfocused."
{
    WriteProtected<byte>
    (
        /* 0x140BB8884 */
        ScanSignature
        (
            "\x74\x2D\xC6\x02\x01\x41\xB0\x01\xEB\x1C\x84\xC0\x74\x21\x48\x8B\x53\x08\x48\x85\xD2\x74\x18\x48\x8B\x52\x28\x48\x85\xD2\x74\x0F\xC6\x02\x00\x45\x33\xC0\x48\x8D\x4A\x58\xE8\xFD\x60\x00\x00\x0F\xB7\x8B\x68\x01\x00\x00\xBA\xDF\xFF\x00\x00\x0F\xB7\xC1\x66\x83\xC9\x20\x66\x23\xC2\x83\xFF\x07\x66\x0F\x44\xC8\x33\xC0\x66\x89\x8B\x68\x01\x00\x00\x48\x8B\x5C\x24\x40\x48\x83\xC4\x30\x5F\xC3",
            "x?xxxxxxx?xxx?xxx?xxxx?xxx?xxxx?xxxxxxxxx?x???????????xxxxxxxxxxxxxxxxxxxxxxxxxxx????xxxx?xxxxxx"
        ),

        0xEB
    );
}

Patch "Always Sandstorm on Islands" in "Weather" by "Hyper" does
/*
Forces the weather to Sandstorm on supported islands.

Supported islands;
- Ares
*/
//
    #lib "Memory"
//
{
    void NOP(long addr)
        => WriteProtected<byte>(addr, 0xEB, 0x22);

    /* 0x1401EE652 */
    long callerFuncAddr = ScanSignature
    (
        "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCB\x8B\xF0\xE8\xCC\xCC\xCC\xCC\x8B\xF8",
        "x????xxxxxx????xx"
    );

    /* 0x1401EE3ED */
    NOP(Memory.ReadCall(callerFuncAddr) + 0x2D);

    /* 0x1401EE4DD */
    NOP(Memory.ReadCall(callerFuncAddr + 0x0A) + 0x2D);
}

Patch "Always Sunny on Islands" in "Weather" by "Hyper" does
/*
Forces the weather to Sunny on supported islands.

Supported islands;
- Kronos
- Ares
- Chaos
- Rhea
- Ouranos
*/
//
    #lib "Memory"
//
{
    void NOP(long addr)
        => WriteProtected<byte>(addr, 0xEB);

    /* 0x1401EE652 */
    long callerFuncAddr = ScanSignature
    (
        "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCB\x8B\xF0\xE8\xCC\xCC\xCC\xCC\x8B\xF8",
        "x????xxxxxx????xx"
    );

    /* 0x1401EE3ED */
    NOP(Memory.ReadCall(callerFuncAddr) + 0x2D);

    /* 0x1401EE4DD */
    NOP(Memory.ReadCall(callerFuncAddr + 0x0A) + 0x2D);
}

Patch "Always Trickable Dash Rings" in "Gameplay" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x148CA72A7 */
        ScanSignature
        (
            "\x0F\x44\xC8\x88\x8F\xD0\x02\x00\x00",
            "xxxxxxxxx"
        ),

        Assemble("mov cl, 2; nop")
    );
}

Patch "Always Trickable Jump Boards" in "Gameplay" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x1403C8CFA */
        ScanSignature
        (
            "\x0F\x95\xC1\x88\x8F\x90\x02\x00\x00\x80\xB8\xB8\x00\x00\x00\x00",
            "xxxxxxxxxxxxxxxx"
        ),

        Assemble("mov cl, 1; nop")
    );
}

Patch "Always Trickable Spin Dash Exit" in "Gameplay" by "Hyper" does
/*
Allows Sonic to always trick when exiting out of Spin Dash whilst in the air.

By default, exiting Spin Dash without boosting will make Sonic fall.
*/
{
    WriteProtected<byte>
    (
        /* 0x1408A5B97 */
        ScanSignature
        (
            "\x41\x8D\x50\x04\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\xB0\x01",
            "xxxxxxxx????xx"
        ),

        Assemble("lea edx, dword ptr [r8 + 0x10]")
    );
}

Patch "Always Trickable Springs" in "Gameplay" by "Hyper"
{
    WriteNop
    (
        /* 0x140434C5C */
        ScanSignature
        (
            "\x0F\x44\xC8\x0F\xB6\xC1\x88\x8B\x00\x03\x00\x00",
            "xxxxxxxxxxxx"
        ),

        3
    );
}

Patch "Always Unlocked All Juke Box Songs" in "Cheats" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x1408BCE36 */
        ScanSignature
        (
            "\x74\x34\x8B\xC6\xFF\xC6",
            "xxxxxx"
        ),

        0xEB
    );
}

Patch "Always Unlocked Arcade Mode" in "Cheats" by "Hyper"
{
    WriteNop
    (
        /* 0x1409756D0 */
        ScanSignature
        (
            "\x74\x57\x4C\x8B\x73\x08\xBA\x08\x01\x00\x00\x41\xB8\x08\x00\x00\x00\x49\x8B\xCE",
            "xxxxxxxxxxxxxxxxxxxx"
        ),

        2
    );
}

Patch "Always Unlocked Extreme Difficulty" in "Cheats" by "Hyper"
{
    WriteNop
    (
        /* 0x140A007D9 */
        ScanSignature
        (
            "\x74\x65\x0F\x1F\x44\x00\x00",
            "xxxxxxx"
        ),
        
        2
    );
}

Patch "Always Unlocked Spin Dash" in "Cheats" by "Hyper"
{
    // Unlock various components of Spin Dash.
    WriteAsmHook
    (
        $@"
            mov al, 1
            ret
        ",

        /* 0x140A15CD0 */
        ScanSignature
        (
            "\x48\x8B\x41\x08\x8B\x40\x4C",
            "xxxxxxx"
        ),

        HookBehavior.Replace
    );

    // Force Spin Dash bitflag check to always pass.
    WriteAsmHook
    (
        $@"
            cmp   edx, 0x3B
            jne   exit
            mov   al, 1
            ret
        exit:
            mov   eax, edx
            and   eax, 0x3F
            movzx r8d, al
            mov   eax, edx
            shr   rax, 6
        ",

        /* 0x1407DE270 */
        ScanSignature
        (
            "\x8B\xC2\x83\xE0\x3F\x44\x0F\xB6\xC0\x8B\xC2\x48\xC1\xE8\x06\x48\x8B\x44\xC1\x28",
            "xxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Always Night on Islands" in "Time" by "NM"
{
    /*
        When forcing the hours, minutes, and seconds opcodes to all write static values, the game will freeze shortly after a save is loaded. This is caused by two opcodes that seemingly invoke a loop until two addresses match in value. These two addresses can either be hours or minutes.
        At the moment, NOPing the JNE of these fixes this, and does not seem to cause any other issues.
    */

    /* 0x147E382AB */
    WriteNop
    (
        ScanSignature
        (
            "\x75\x27\x41\x8B\x40\x08\x39\x42\x08\x75\x1B\xF3\x0F\x10\x42\x0C\xF3\x41\x0F\x5C\x40\x0C\x0F\x54\x05\x78\xD7\x23\xF9\x0F\x2F\x05\x69\xD7\x23\xF9\x76\x5C\x45\x39\xD1\x72\x5A\x75\x17\x8B\x42\x08\x41\x3B\x40\x08\x72\x4F\x75\x0C",
            "x?xxx?xx?x?xxxx?xxxxx?xxx????xxx????x?xxxx?x?xx?xxx?x?x?"
        ),

        2
    );

    /* 0x147E382B4 */
    WriteNop
    (
        ScanSignature
        (
            "\x75\x1B\xF3\x0F\x10\x42\x0C\xF3\x41\x0F\x5C\x40\x0C\x0F\x54\x05\x78\xD7\x23\xF9\x0F\x2F\x05\x69\xD7\x23\xF9\x76\x5C\x45\x39\xD1\x72\x5A\x75\x17\x8B\x42\x08\x41\x3B\x40\x08\x72\x4F\x75\x0C\xF3\x41\x0F\x10\x40\x0C\x0F\x2F\x42",
            "x?xxxx?xxxxx?xxx????xxx????x?xxxx?x?xx?xxx?x?x?xxxxx?xxx"
        ),

        2
    );

    WriteAsmHook
    (
        @"
            add dword ptr [rcx], edx
            mov dword ptr [rcx+04h], 0h ; Hours
            mov dword ptr [rcx+08h], 0h ; Minutes
            mov dword ptr [rcx+0x0C], 0h ; Seconds
        ",

        /* 0x147E22D2B */
        ScanSignature
        (
            "\x01\x11\x44\x01\x41\x04\x44\x01\x49\x08\xF3\x0F\x11\x41\x0C\xE9\x91\x12\x1F\xF8",
            "xxxxx?xxx?xxxx?x????"
        ),

        HookBehavior.Replace
    );
}

Patch "Always Sunrise on Islands" in "Time" by "NM"
{
    /*
        When forcing the hours, minutes, and seconds opcodes to all write static values, the game will freeze shortly after a save is loaded. This is caused by two opcodes that seemingly invoke a loop until two addresses match in value. These two addresses can either be hours or minutes.
        At the moment, NOPing the JNE of these fixes this, and does not seem to cause any other issues.
    */

    /* 0x147E382AB */
    WriteNop
    (
        ScanSignature
        (
            "\x75\x27\x41\x8B\x40\x08\x39\x42\x08\x75\x1B\xF3\x0F\x10\x42\x0C\xF3\x41\x0F\x5C\x40\x0C\x0F\x54\x05\x78\xD7\x23\xF9\x0F\x2F\x05\x69\xD7\x23\xF9\x76\x5C\x45\x39\xD1\x72\x5A\x75\x17\x8B\x42\x08\x41\x3B\x40\x08\x72\x4F\x75\x0C",
            "x?xxx?xx?x?xxxx?xxxxx?xxx????xxx????x?xxxx?x?xx?xxx?x?x?"
        ),

        2
    );

    /* 0x147E382B4 */
    WriteNop
    (
        ScanSignature
        (
            "\x75\x1B\xF3\x0F\x10\x42\x0C\xF3\x41\x0F\x5C\x40\x0C\x0F\x54\x05\x78\xD7\x23\xF9\x0F\x2F\x05\x69\xD7\x23\xF9\x76\x5C\x45\x39\xD1\x72\x5A\x75\x17\x8B\x42\x08\x41\x3B\x40\x08\x72\x4F\x75\x0C\xF3\x41\x0F\x10\x40\x0C\x0F\x2F\x42",
            "x?xxxx?xxxxx?xxx????xxx????x?xxxx?x?xx?xxx?x?x?xxxxx?xxx"
        ),

        2
    );

    WriteAsmHook
    (
        @"
            add dword ptr [rcx], edx
            mov dword ptr [rcx+04h], 4h ; Hours
            mov dword ptr [rcx+08h], 0h ; Minutes
            mov dword ptr [rcx+0x0C], 0h ; Seconds
        ",

        /* 0x147E22D2B */
        ScanSignature
        (
            "\x01\x11\x44\x01\x41\x04\x44\x01\x49\x08\xF3\x0F\x11\x41\x0C\xE9\x91\x12\x1F\xF8",
            "xxxxx?xxx?xxxx?x????"
        ),

        HookBehavior.Replace
    );
}

Patch "Always Sunset on Islands" in "Time" by "NM"
{
    /*
        When forcing the hours, minutes, and seconds opcodes to all write static values, the game will freeze shortly after a save is loaded. This is caused by two opcodes that seemingly invoke a loop until two addresses match in value. These two addresses can either be hours or minutes.
        At the moment, NOPing the JNE of these fixes this, and does not seem to cause any other issues.
    */

    /* 0x147E382AB */
    WriteNop
    (
        ScanSignature
        (
            "\x75\x27\x41\x8B\x40\x08\x39\x42\x08\x75\x1B\xF3\x0F\x10\x42\x0C\xF3\x41\x0F\x5C\x40\x0C\x0F\x54\x05\x78\xD7\x23\xF9\x0F\x2F\x05\x69\xD7\x23\xF9\x76\x5C\x45\x39\xD1\x72\x5A\x75\x17\x8B\x42\x08\x41\x3B\x40\x08\x72\x4F\x75\x0C",
            "x?xxx?xx?x?xxxx?xxxxx?xxx????xxx????x?xxxx?x?xx?xxx?x?x?"
        ),

        2
    );

    /* 0x147E382B4 */
    WriteNop
    (
        ScanSignature
        (
            "\x75\x1B\xF3\x0F\x10\x42\x0C\xF3\x41\x0F\x5C\x40\x0C\x0F\x54\x05\x78\xD7\x23\xF9\x0F\x2F\x05\x69\xD7\x23\xF9\x76\x5C\x45\x39\xD1\x72\x5A\x75\x17\x8B\x42\x08\x41\x3B\x40\x08\x72\x4F\x75\x0C\xF3\x41\x0F\x10\x40\x0C\x0F\x2F\x42",
            "x?xxxx?xxxxx?xxx????xxx????x?xxxx?x?xx?xxx?x?x?xxxxx?xxx"
        ),

        2
    );

    WriteAsmHook
    (
        @"
            add dword ptr [rcx], edx
            mov dword ptr [rcx+04h], 14h ; Hours
            mov dword ptr [rcx+08h], 19h ; Minutes
            mov dword ptr [rcx+0x0C], 0h ; Seconds
        ",

        /* 0x147E22D2B */
        ScanSignature
        (
            "\x01\x11\x44\x01\x41\x04\x44\x01\x49\x08\xF3\x0F\x11\x41\x0C\xE9\x91\x12\x1F\xF8",
            "xxxxx?xxx?xxxx?x????"
        ),

        HookBehavior.Replace
    );
}

Patch "Bouncy Jump Ball" in "Animation" by "Hyper" does "Uses bouncy jump ball animations when jumping and double jumping, similar to Sonic Forces."
//
    #lib "Memory"
//
{
    long SPINJUMP = (long)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi("SPINJUMP");

    /* 0x14B4D4603 */
    long playParticleCallerAddr = ScanSignature
    (
        "\xE8\xCC\xCC\xCC\xCC\x48\x8B\x43\x38\x48\x8B\x88\x08\x01\x00\x00\x48\x85\xC9\x74\x14\xBA\x8E\xB4\x47\x3B",
        "x????xxxxxxxxxxxxxxxxxxxxx"
    );

    /* 0x140901E20 */
    long playParticleFuncAddr = Memory.ReadCall(playParticleCallerAddr);

    /* 0x14B4DB1E6 */
    long playAnimationCallerAddr = ScanSignature
    (
        "\xE8\xCC\xCC\xCC\xCC\x41\xB0\x01\x48\x8D\x15\xCC\xCC\xCC\xCC\x48\x89\xF1",
        "x????xxxxxx????xxx"
    );

    /* 0x1408122E0 */
    long playAnimationFuncAddr = Memory.ReadCall(playAnimationCallerAddr);

    // StateJump
    {
        WriteAsmHook
        (
            $@"
                mov  r8b, 0xFE
                mov  rdx, {(long)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi("JUMP_BALL")}
                mov  rcx, rax
                mov  rax, {playAnimationFuncAddr}
                call rax
                mov  r8b, 1
                mov  rdx, {SPINJUMP}
                mov  rcx, rsi
                mov  rax, {playParticleFuncAddr}
                call rax
            ",

            /* 0x14B4DB1D4 */
            ScanSignature
            (
                "\x41\xB0\xFE\x48\x89\xC1\x40\x84\xFF",
                "xxxxxxxxx"
            ),

            HookBehavior.Replace
        );

        WriteNop(playAnimationCallerAddr, 23);
    }

    // StateDoubleJump
    WriteAsmHook
    (
        $@"
            mov  rdx, {SPINJUMP}
            lea  rdx, [rdx]
            mov  rcx, rbx
            mov  rax, {playParticleFuncAddr}
            call rax
        ",

        /* 0x14B4D45F9 */
        ScanSignature
        (
            "\x48\x8D\x15\xCC\xCC\xCC\xCC\x48\x89\xD9\xE8\xCC\xCC\xCC\xCC\x48\x8B\x43\x38",
            "xxx????xxxx????xxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Centre Game Window on Launch" in "System" by "Hyper"
//
    #load "System.Drawing.dll"
    #load "System.Xml.dll"

    using System.Drawing;
    using System.IO;
    using System.Xml.Serialization;

    [XmlRoot(ElementName = "ScreenSetting")]
    public class ScreenSetting
    {
        [XmlAttribute(AttributeName = "left")]
        public int Left { get; set; }

        [XmlAttribute(AttributeName = "top")]
        public int Top { get; set; }

        [XmlAttribute(AttributeName = "width")]
        public int Width { get; set; }

        [XmlAttribute(AttributeName = "height")]
        public int Height { get; set; }

        [XmlAttribute(AttributeName = "resolutionWidth")]
        public int ResolutionWidth { get; set; }

        [XmlAttribute(AttributeName = "resolutionHeight")]
        public int ResolutionHeight { get; set; }

        [XmlAttribute(AttributeName = "fullscreenStyle")]
        public int FullscreenStyle { get; set; }

        [XmlAttribute(AttributeName = "fullscreenState")]
        public int FullscreenState { get; set; }
    }

    [System.Runtime.InteropServices.DllImport("user32.dll")]
    static extern int GetSystemMetrics(int nIndex);

    static Size GetScreenSize()
        => new Size(GetSystemMetrics(0), GetSystemMetrics(1));

    static int GetTitleBarHeight()
        => GetSystemMetrics(31);
//
{
    string xml = Path.Combine
    (
        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
        @"SEGA\SonicFrontiers\steam\x64\screen_setting.xml"
    );

    if (!File.Exists(xml))
    {
        Console.WriteLine($"[Centre Game Window on Launch] Code halted, file not found: {xml}");
        return;
    }

    try
    {
        using (StringReader reader = new StringReader(File.ReadAllText(xml)))
        {
            var screenSetting = (ScreenSetting)new XmlSerializer(typeof(ScreenSetting)).Deserialize(reader);

            Size screen = GetScreenSize();

            int left = (screen.Width / 2) - (screenSetting.Width / 2);
            int top  = ((screen.Height / 2) - (screenSetting.Height / 2)) - GetTitleBarHeight();

            if (left < 0)
            {
                Console.WriteLine("[Centre Game Window on Launch] Invalid X position! Defaulting to zero...");
                left = 0;
            }

            if (top < 0)
            {
                Console.WriteLine("[Centre Game Window on Launch] Invalid Y position! Defaulting to zero...");
                top = 0;
            }

            // Force new left value as default value.
            WriteAsmHook
            (
                $"mov dword ptr [rbx], 0x{left:X}",

                /* 0x150A0F546 */
                ScanSignature
                (
                    "\x4D\x85\xFF\x74\x3A\x48\x85\xF6\x74\x35\x48\x85\xED\x74\x30\x48\x85\xC0\x74\x2B\x4C\x89\xF9\xE8\x00\x00\x00\x00\x48\x89\xF1\x89\x03\xE8\x00\x00\x00\x00\x48\x89\xE9\x89\x43\x04\xE8\x00\x00\x00\x00\x4C\x89\xF1\x89\x43\x08\xE8\x00\x00\x00\x00\x89\x43\x0C\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\x48\x89\xC5\xE8\x00\x00\x00\x00\x4C\x8B\xBC\x24\x00\x00\x00\x00\x48\x89\xC6\x4C\x8B\xB4\x24\x00\x00\x00\x00\x48\x85\xED\x74\x1B\x48\x85\xC0\x74\x16\x48\x89\xE9\xE8\x00\x00\x00\x00\x48\x89\xF1\x89\x43\x10\xE8\x00\x00\x00\x00\x89\x43\x14",
                    "xxxxxxxxxxxxxxxxxxxxxxxx????xxxxxx????xxxxxxx????xxxxxxx????xxxxxxxxx????xxxx????xxxxxx????xxxxxxx????xxxx????xxxxxxx????xxxxxxxxxxxxxx????xxxxxxx????xxx"
                ),

                HookBehavior.Replace
            );

            // Force new top value as default value.
            WriteAsmHook
            (
                $"mov dword ptr [rbx + 4], 0x{top:X}",

                /* 0x150A0F555 */
                ScanSignature
                (
                    "\x48\x85\xC0\x74\x2B\x4C\x89\xF9\xE8\x00\x00\x00\x00\x48\x89\xF1\x89\x03\xE8\x00\x00\x00\x00\x48\x89\xE9\x89\x43\x04\xE8\x00\x00\x00\x00\x4C\x89\xF1\x89\x43\x08\xE8\x00\x00\x00\x00\x89\x43\x0C\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\x48\x89\xC5\xE8\x00\x00\x00\x00\x4C\x8B\xBC\x24\x00\x00\x00\x00\x48\x89\xC6\x4C\x8B\xB4\x24\x00\x00\x00\x00\x48\x85\xED\x74\x1B\x48\x85\xC0\x74\x16\x48\x89\xE9\xE8\x00\x00\x00\x00\x48\x89\xF1\x89\x43\x10\xE8\x00\x00\x00\x00\x89\x43\x14",
                    "xxxxxxxxx????xxxxxx????xxxxxxx????xxxxxxx????xxxxxxxxx????xxxx????xxxxxx????xxxxxxx????xxxx????xxxxxxx????xxxxxxxxxxxxxx????xxxxxxx????xxx"
                ),

                HookBehavior.Replace
            );
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[Centre Game Window on Launch] {ex}");
        return;
    }

    // Kill XML value reading for left.
    WriteNop
    (
        /* 0x150A0F565 */
        ScanSignature
        (
            "\x89\x03\xE8\x00\x00\x00\x00\x48\x89\xE9\x89\x43\x04\xE8\x00\x00\x00\x00\x4C\x89\xF1\x89\x43\x08\xE8\x00\x00\x00\x00\x89\x43\x0C\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\x48\x89\xC5\xE8\x00\x00\x00\x00\x4C\x8B\xBC\x24\x00\x00\x00\x00\x48\x89\xC6\x4C\x8B\xB4\x24\x00\x00\x00\x00\x48\x85\xED\x74\x1B\x48\x85\xC0\x74\x16\x48\x89\xE9\xE8\x00\x00\x00\x00\x48\x89\xF1\x89\x43\x10\xE8\x00\x00\x00\x00\x89\x43\x14\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x48\x8B\xB4\x24\x00\x00\x00\x00\x48\x8B\xAC\x24\x00\x00\x00\x00\x48\x85\xC0\x74\x0B\x48\x89\xC1\xE8\x00\x00\x00\x00\x89\x43\x20\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x48\x85\xC0\x74\x0B\x48\x89\xC1\xE8\x00\x00\x00\x00\x89\x43\x24\x48\x8D\x4C\x24\x00\xB3\x01\xE8\x00\x00\x00\x00\x0F\xB6\xC3\x48\x81\xC4\x00\x00\x00\x00\x5F\x5B\xC3",
            "xxx????xxxxxxx????xxxxxxx????xxxxxxxxx????xxxx????xxxxxx????xxxxxxx????xxxx????xxxxxxx????xxxxxxxxxxxxxx????xxxxxxx????xxxxxxxxx????xxxx????xxxx????xxxx????xxxxxxxxx????xxxxxxxxx????xxxx????xxxxxxxxx????xxxxxxx?xxx????xxxxxx????xxx"
        ),

        7
    );

    // Kill XML value reading for top.
    WriteNop
    (
        /* 0x150A0F56F */
        ScanSignature
        (
            "\x89\x43\x04\xE8\x00\x00\x00\x00\x4C\x89\xF1\x89\x43\x08\xE8\x00\x00\x00\x00\x89\x43\x0C\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\x48\x89\xC5\xE8\x00\x00\x00\x00\x4C\x8B\xBC\x24\x00\x00\x00\x00\x48\x89\xC6\x4C\x8B\xB4\x24\x00\x00\x00\x00\x48\x85\xED\x74\x1B\x48\x85\xC0\x74\x16\x48\x89\xE9\xE8\x00\x00\x00\x00\x48\x89\xF1\x89\x43\x10\xE8\x00\x00\x00\x00\x89\x43\x14\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x48\x8B\xB4\x24\x00\x00\x00\x00\x48\x8B\xAC\x24\x00\x00\x00\x00\x48\x85\xC0\x74\x0B\x48\x89\xC1\xE8\x00\x00\x00\x00\x89\x43\x20\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x48\x85\xC0\x74\x0B\x48\x89\xC1\xE8\x00\x00\x00\x00\x89\x43\x24\x48\x8D\x4C\x24\x00\xB3\x01\xE8\x00\x00\x00\x00\x0F\xB6\xC3\x48\x81\xC4\x00\x00\x00\x00\x5F\x5B\xC3",
            "xxxx????xxxxxxx????xxxxxxxxx????xxxx????xxxxxx????xxxxxxx????xxxx????xxxxxxx????xxxxxxxxxxxxxx????xxxxxxx????xxxxxxxxx????xxxx????xxxx????xxxx????xxxxxxxxx????xxxxxxxxx????xxxx????xxxxxxxxx????xxxxxxx?xxx????xxxxxx????xxx"
        ),

        3
    );
}

Patch "Disable Air Tricks from Terrain" in "Gameplay" by "Hyper" does
/*
Disables the ability to air trick when flinging off terrain.

This also applies to boosting out of Spin Dash in the air.
*/
{
    WriteProtected<byte>
    (
        /* 0x14B3E755A */
        ScanSignature
        (
            "\x74\x19\x41\xB0\x01\x8B\x0D",
            "xxxxxxx"
        ),

        0xEB
    );
}

Patch "Disable Air Tricks from Traversal Objects" in "Gameplay" by "Hyper" does "Disables the ability to air trick when using Dash Rings, Jump Boards and Springs."
{
    WriteNop
    (
        /* 0x14084AA0F */
        ScanSignature
        (
            "\xB0\x01\x88\x46\x3E",
            "xxxxx"
        ),

        2
    );
}

Patch "Disable Boost Replenishment from Timer" in "Gameplay" by "Hyper" does "Prevents the boost gauge from refilling over time."
{
    WriteNop
    (
        /* 0x1408D468C */
        ScanSignature
        (
            "\xF3\x0F\x11\x4F\x3C\xEB\x4E",
            "xxxxxxx"
        ),

        5
    );
}

Patch "Disable Birthday Party Decorations" in "UI" by "Hyper" does "Disables the birthday party decorations on the HUD when using the Party Details option for Island Appearance in Extras."
{
    WriteProtected<byte>
    (
        /* 0x140968F33 */
        ScanSignature
        (
            "\x74\x0E\xE8\xCC\xCC\xCC\xCC\x48\x8D\x0D\xCC\xCC\xCC\xCC\xEB\x0C",
            "xxx????xxx????xx"
        ),

        0xEB
    );

    WriteProtected<byte>
    (
        /* 0x140969157 */
        ScanSignature
        (
            "\x74\x04\x80\x4F\x28\x04",
            "xxxxxx"
        ),

        0xEB
    );
}

Patch "Disable Boost Replenishment from Rings" in "Gameplay" by "Hyper" does "Prevents the boost gauge from refilling when collecting rings."
{
    WriteAsmHook
    (
        $@"
            xorps    xmm1, xmm1
            xor      r8d, r8d
            cvtsi2ss xmm1, rcx
            mov      rcx, rbx
            mov      dword ptr [rax + 0x14], 0
            mulss    xmm1, dword ptr [rax + 0x14]
        ",

        /* 0x140863E19 */
        ScanSignature
        (
            "\x41\x8B\x4E\x24\x0F\x57\xC9\x45\x33\xC0\xF3\x48\x0F\x2A\xC9",
            "xxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Disable Camera Shake" in "Camera" by "Hyper" does "Disables camera shake during combat."
{
    WriteProtected<byte>
    (
        /* 0x1400B51E2 */
        ScanSignature
        (
            "\x0F\x85\x08\x03\x00\x00\x48\x8B\x41\x28",
            "xxxxxxxxxx"
        ),

        0xE9, 0x09, 0x03, 0x00, 0x00
    );
}

Patch "Disable Caterpillar (experimental)" in "Enemy" by "Hyper" does
/*
Disables the Caterpillar guardian on Ouranos Island.

Known issues;
- This also affects Battle Rush and causes a softlock.
*/
{
    WriteNop
    (
        /* 0x1405AEE3B */
        ScanSignature
        (
            "\x75\x2A\x45\x33\xC0\x33\xD2\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCE",
            "xxxxxxxxxxx????xxx"
        ),

        2
    );
}

Patch "Disable Challenge Marker Scanner (experimental)" in "Gameplay" by "Hyper" does
/*
Disables the scanning event and map transition after completing challenges.

Known issues;
- Map completion percentage does not increase after completing challenges.
- The option to place markers on the map will not appear after completing your first challenge (use Disable Menu Restrictions as a workaround).
*/
{
    WriteProtected<byte>
    (
        /* 0x1493E9B82 */
        ScanSignature
        (
            "\x74\x1E\x41\x83\xF8\x01\x75\x7E",
            "xxxxxxxx"
        ),

        0xE9, 0x81, 0x00, 0x00, 0x00
    );
}

Patch "Disable Challenge Rails" in "Gameplay" by "Hyper" does
/*
Disables the white rails that appear after completing challenges.

Your progress will still be saved, so disabling this code after completing challenges will still unlock their respective rails.
*/
{
    WriteAsmHook
    (
        @"
            add rsp, 0x40
            pop rdi
            ret
        ",

        /* 0x148E533EF */
        ScanSignature
        (
            "\x48\x89\xD3\x48\x89\xCF\xE8\xCC\xCC\xCC\xCC\x48\x89\xC2\x48\x89\xF9\xE8\xCC\xCC\xCC\xCC\x48\x89\xDA",
            "xxxxxxx????xxxxxxx????xxx"
        ),

        HookBehavior.Replace
    );

    /* 0x14033E730 */
    long addr = ScanSignature
    (
        "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x60\x8B\xDA\x48",
        "xxxxxxxxxxxxx"
    );

    if (addr != 0)
        WriteNop(addr + 0x5F, 5);
}

Patch "Disable Chromatic Aberration" in "Graphics" by "Luig & Hyper" does "Disables the RGB separation effect at edges of the screen in certain scenarios."
{
    WriteNop
    (
        /* 0x140B428ED */
        ScanSignature
        (
            "\x0F\x11\x43\x0C\x41\x0F\x10\x8E\x00\x00\x00\x00\x0F\x11\x4B\x1C\x41\x8B\x86\x00\x00\x00\x00\x89\x43\x2C\xE8\x00\x00\x00\x00\x48\x8B\xD8\x4D\x8D\xA6\x00\x00\x00\x00\x48\x8B\x08\x48\x85\xC9\x74\x0E\x4C\x8B\x09\x4C\x8D\x40\x10\x49\x8B\xD4\x41\xFF\x51\x08\x41\x0F\x28\x04\x24\x49\x8B\xCD\x0F\x29\x43\x10\x41\x0F\x28\x4C\x24\x00\x0F\x29\x4B\x20\x41\x0F\x28\x44\x24\x00\x0F\x29\x43\x30\x41\x0F\x28\x4C\x24\x00\x0F\x29\x4B\x40\x41\x0F\x28\x44\x24\x00\x0F\x29\x43\x50\x41\x0F\x28\x4C\x24\x00\x0F\x29\x4B\x60\x41\x0F\x28\x44\x24\x00\x0F\x29\x43\x70\x41\x0F\x28\x4C\x24\x00\x0F\x29\x8B\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x84\xC0\x0F\x85\x00\x00\x00\x00\xB9\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xD8\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x0F\x28\x05\x00\x00\x00\x00\x49\x8B\xCD\x0F\x28\x0D\x00\x00\x00\x00",
            "xxxxxxxx????xxxxxxx????xxxx????xxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxx????x????xxxx????x????x????xxxxxxxx????xxx????xxxxxx????"
        ),

        4
    );
}

Patch "Disable Color Correction LUTs" in "Graphics" by "M&M" does "Prevents the game from using the color corrected LUTs stored in each stage's trr_cmn pac."
{
    WriteProtected<byte>
    (
        ScanSignature
        (
            "%s_rgb_table%d",
            "xxxxxxxxxxxxxx"
        ),

        System.Text.Encoding.UTF8.GetBytes("ColorGradingLUT_default\0")
    );
}

Patch "Disable Corruption Animations" in "Animation" by "Hyper" does "Disables the animations for when Sonic becomes increasingly more corrupted in the later islands."
{
    // LANDING_CORRUPTION_WEAK
    WriteProtected<byte>
    (
        /* v1.10: 0x140830C7D */
        ScanSignature
        (
            "\x74\x15\xB8\x04\x00\x00\x00\x48\x8B\x5C\x24\x30",
            "xxxxxxxxxxxx"
        ),

        0xEB
    );

    // LANDING_CORRUPTION_STRONG
    WriteNop
    (
        /* v1.10: 0x140830CA8 */
        ScanSignature
        (
            "\xBA\x05\x00\x00\x00\x0F\x45\xCA\x8B\xC1",
            "xxxxxxxxxx"
        ),

        8
    );

    // IDLE_CORRUPTION_WEAK_LOOP
    WriteProtected<byte>
    (
        /* v1.10: 0x140830DB4 */
        ScanSignature
        (
            "\x74\x15\xB8\x0B\x00\x00\x00",
            "xxxxxxx"
        ),

        0xEB
    );

    // IDLE_CORRUPTION_STRONG_LOOP
    WriteProtected<byte>
    (
        /* v1.10: 0x140830DDA */
        ScanSignature
        (
            "\x74\x15\xB8\x0C\x00\x00\x00",
            "xxxxxxx"
        ),

        0xEB
    );
}

Patch "Disable Cyber Space CRT Effects" in "Graphics" by "Hyper & PTKickass" does "Disables the CRT scanline effect on distant terrain models in Cyber Space."
{
    WriteProtected<byte>
    (
        /* 0x1401DDC5E */
        ScanSignature
        (
            "\x0F\x84\x00\x00\x00\x00\x41\x0F\x29\x73\x00\x48\xBF\x00\x00\x00\x00\x00\x00\x00\x00\x0F\x57\xF6\x66\x66\x0F\x1F\x84\x00\x00\x00\x00\x00\xF3\x0F\x10\x4B\x00\x32\xC9\x0F\x28\xC1\x41\x0F\x54\xC1\x41\x0F\x2F\xC0\x0F\x86\x00\x00\x00\x00\xF3\x41\x0F\x59\xCA\xC7\x84\x24\x00\x00\x00\x00\x00\x00\x00\x00\x44\x89\xA4\x24\x00\x00\x00\x00\xF3\x0F\x58\x4B\x00\x0F\x2F\xCF\xF3\x0F\x11\x8C\x24\x00\x00\x00\x00\x76\x05\x0F\x28\xC7\xEB\x1B\x0F\x2F\xCE\x48\x8D\x84\x24\x00\x00\x00\x00\x48\x8D\x94\x24\x00\x00\x00\x00\x48\x0F\x43\xC2\xF3\x0F\x10\x00\xF3\x0F\x11\x43\x00\xC7\x86\x00\x00\x00\x00\x00\x00\x00\x00\xF3\x0F\x10\x43\x00\x0F\x2F\xC6\x73\x0A\x44\x0F\x2F\x43\x00\x0F\x93\xC1\xEB\x1D\x76\x1B\xF3\x0F\x10\x43\x00\xF3\x0F\x5C\xC7\x41\x0F\x54\xC1\x41\x0F\x2F\xC0\x77\x08\x48\xC7\x43\x00\x00\x00\x00\x00\x8B\x43\x58\x85\xC0\x78\x14\x83\xE8\x01\x89\x43\x58\x79\x0C\xC7\x86\x00\x00\x00\x00\x00\x00\x00\x00\xEB\x04\x84\xC9\x74\x45\x48\xFF\x4E\x30",
            "xx????xxxx?xx????????xxxxxxxxx????xxxx?xxxxxxxxxxxxxxx????xxxxxxxx????????xxxx????xxxx?xxxxxxxx????xxxxxxxxxxxxxx????xxxx????xxxxxxxxxxxx?xx????????xxxx?xxxxxxxxx?xxxxxxxxxxx?xxxxxxxxxxxxxxxxx?????xxxxxxxxxxxxxxxxx????????xxxxxxxxxx"
        ),

        0xE9, 0xDA, 0x02, 0x00, 0x00
    );
}

Patch "Disable TAA Sharpness" in "Graphics" by "Hyper" does "Disables the sharpening filter applied when TAA is enabled."
{
    WriteProtected<byte>
    (
        /* 0x140F2B602 */
        ScanSignature
        (
            "\x0F\x83\x86\x02\x00\x00",
            "xxxxxx"
        ),

        0xE9, 0x87, 0x02, 0x00, 0x00
    );
}

Patch "Disable Thorn Cylinders" in "Gameplay" by "Hyper" does "Disables the cylindrical thorn objects placed at the most inconvenient locations in Cyber Space."
{
    WriteProtected<byte>
    (
        /* 0x1404119C4 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x48\x8D\x15\xCC\xCC\xCC\xCC\x48\x8B\xCB\x4C\x8B\xF0\xE8\xCC\xCC\xCC\xCC\x49\x0F\xBE\x16",
            "x????xxxxxxx????xxx????xxxxxxx????xxxx"
        ),

        0xE9, 0x4A, 0x04, 0x00, 0x00
    );
}

Patch "Enable Flinging from Terrain in Cyber Space" in "Gameplay" by "WasifBoomz" does
/*
Allows Sonic to fling off of terrain in Cyber Space.

Notes;
- This does not allow Sonic to perform Air Tricks from terrain, use the 'Enable Air Tricks in Cyber Space' code to do so.
*/
{
    long CheckTumbleFuncAddress = ScanSignature
    (
        "\x48\x89\x5C\x24\x10\x48\x89\x74\x24\x18\x55\x48\x8B\xEC",
        "xxxxxxxxxxxxxx"
    );

    WriteAsmHook
    (
        $@"
            mov  rdx, rax
            mov  rcx, rbx
            mov  rax, {(long)CheckTumbleFuncAddress}
            call rax
            cmp  byte ptr [rax], 0
            jnz  end
            mov  byte ptr [rax], 1
            mov  dword ptr [rax+4h],  0x41700000
            mov  dword ptr [rax+1Ch], 0x40000000
            mov  dword ptr [rax+20h], 0x40000000
            mov  dword ptr [rax+24h], 0x42480000
            mov  dword ptr [rax+28h], 0x42B40000
            mov  dword ptr [rax+2Ch], 0x42200000
            mov  dword ptr [rax+30h], 0x42A00000
            mov  dword ptr [rax+34h], 0x41A00000
            mov  dword ptr [rax+40h], 0x41A00000
            mov  dword ptr [rax+4Ch], 0x41400000
        end:
            cmp  byte ptr [rax], 0
        ",

        /* 0x1408FD0C5 */
        ScanSignature
        (
            "\x48\x8B\xD0\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x80\x38\x00\x74\x7D",
            "xxxxxxx????xxxxx"
        ),
                
        HookBehavior.Replace
    );
}

Code "Enable Air Tricks in Cyber Space" in "Gameplay" by "WasifBoomz" does
/*
Allows Sonic to use the Air Trick skill in Cyber Space.

Notes;
- This will only work for traversal objects, use the 'Enable Flinging from Terrain in Cyber Space' code to allow Sonic to fling off of terrain.
*/
//
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "Memory"

    static bool isCyber = false;
    static bool isInitialised = false;
//
{
    if (!isInitialised)
    {
        fixed (bool* pIsCyber = &isCyber)
        {
            /* 0x14BB55230 */
            long CallAddress1 = ScanSignature
            (
                "\x40\x53\x48\x83\xEC\x20\x48\x8B\x41\x38\x0F\xB6\xDA\x48\x8B\x88\x08\x01\x00\x00\x48\x85\xC9\x74\x1F\xBA\xFF\x9E\x82\x22",
                "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
            );

            /* 0x1408F62C0 */
            long CallAddress2 = ScanSignature
            (
                "\x40\x53\x48\x83\xEC\x20\xBA\x1A\x00\x00\x00",
                "xxxxxxxxxxx"
            );
            
            /* Handling the Tumble State */
            WriteAsmHook
            (
                $@"
                    mov rbx, {(long)pIsCyber}
                    cmp byte ptr [rbx], 1
                    jz  cyber
                    
                original:
                    mov  rcx, rdi
                    mov  rbx, {(long)CallAddress1}
                    call rbx
                                    
                    mov  rcx, rdi
                    mov  rax, {(long)CallAddress2}
                    call rax
                    jmp  end

                cyber:
                    mov  al, 1
                end:
                ",
                
                /* 0x14B3E7548 */
                ScanSignature
                (
                    "\x48\x89\xF9\xE8\xCC\xCC\xCC\xCC\x48\x89\xF9\xE8\xCC\xCC\xCC\xCC\x84\xC0",
                    "xxxx????xxxx????xx"
                ),
                
                HookBehavior.Replace
            );
    
            /* 0x14B74C5F6 */
            long HandleAddress = ScanSignature
            (
                "\x80\x79\x3D\x00\x48\x89\xCB",
                "xxxxxxx"
            );
            
            WriteNop(HandleAddress, 0x1E);
            
            /* 0x1408F9C10 */
            long ChangeFlagAddress = Memory.ReadCall
            (
                /* 0x140866188 */
                ScanSignature
                (
                    "\xE8\xCC\xCC\xCC\xCC\xBA\x06\x00\x00\x00\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x84\xC0",
                    "x????xxxxxxxxx????xx"
                )
            );
            
            /* Handling Springs, Jump Boards, and Dash Rings */
            WriteAsmHook
            (
                $@"
                    mov rax, {(long)pIsCyber}
                    cmp byte ptr [rax], 1
                    jz  cyberJump

                originalCheck:
                    cmp  byte ptr [rcx+3Dh], 0
                    mov  rbx, rcx
                    jz   end
                
                cyberJump:
                    mov  rcx, [rcx+20h]
                    mov  r8b, 1
                    mov  edx, 28h
                    mov  rax, {(long)ChangeFlagAddress}
                    call rax
                    mov  byte ptr [rbx+3Dh], 0
                end:
                ",
                
                HandleAddress,
                
                HookBehavior.Replace
            );
        }

        isInitialised = true;
    }

    if (BlackboardStatus.Get() == 0)
        return;

    isCyber = Bitwise.Test(*BlackboardStatus.GetWorldFlags(), (uint)BlackboardStatus.WorldFlags.IsCyberSpace);
}

Patch "Hide Drift Input Prompt" in "UI" by "Hyper" does "Hides the input prompt that covers up Sonic when using drift dash panels."
{
    WriteNop
    (
        /* 0x14081E868 */
        ScanSignature
        (
            "\xE8\x00\x00\x00\x00\x48\x8D\x4C\x24\x00\xE8\x00\x00\x00\x00\x4C\x8D\x05\x00\x00\x00\x00\x48\x8B\xD6\x48\x8D\x8C\x24\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8D\x8D\x00\x00\x00\x00\x48\x8B\xD0\xE8\x00\x00\x00\x00\x41\xB0\x01\xBA\x00\x00\x00\x00\x48\x8B\xCE\xE8\x00\x00\x00\x00\xBA\x00\x00\x00\x00\x48\x8B\xCE\xE8\x00\x00\x00\x00\xB2\x01\x48\x8B\xCE\x48\x8B\x9C\x24\x00\x00\x00\x00\x48\x81\xC4\x00\x00\x00\x00\x41\x5E\x5E\x5D\xE9\x00\x00\x00\x00",
            "x????xxxx?x????xxx????xxxxxxx????x????xxx????xxxx????xxxx????xxxx????x????xxxx????xxxxxxxxx????xxx????xxxxx????"
        ),

        5
    );
}

Patch "Disable Cyloop Aura" in "Graphics" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x14080F16D */
        ScanSignature
        (
            "\x74\x16\x3C\x08\x74\x12",
            "xxxxxx"
        ),

        0xEB
    );
}

Patch "Disable Cyloop Camera" in "Camera" by "Hyper"
{
    WriteNop
    (
        /* 0x1408577FE */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x4C\x8D\x05\xCC\xCC\xCC\xCC\x48\x8B\xD3\x48\x8D\x4D\x40",
            "x????xxx????xxxxxxx"
        ),

        5
    );
}

Patch "Disable Damage (experimental)" in "Cheats" by "Hyper" does
/*
Disables damage completely and makes Sonic invulnerable.

Known issues;
- Asura will softlock when Sonic is supposed to take damage after taking out one of the arms.
*/
{
    WriteProtected<byte>
    (
        /* 0x1407EE68A */
        ScanSignature
        (
            "\x0F\x84\x2C\x01\x00\x00\x83\xEA\x02",
            "xxxxxxxxx"
        ),

        0xE9, 0x1A, 0x02, 0x00, 0x00
    );
}

Patch "Disable Decelerate Collision" in "Physics" by "Hyper" does
/*
Disables the collision flag that kills all horizontal velocity when jumping.

Example usage;
- The bridge in Kronos above the river.
- The cliffsides in Ares.
*/
//
    static int Seek = 0;
//
{
    fixed (int* pSeek = &Seek)
    {
        WriteAsmHook
        (
            $@"
                mov  r14, qword ptr [rsp + 0x48 + 0xFFFFFFFFFFFFFFD8]
                mov  rdi, qword ptr [rsp + 0x48 + 0xFFFFFFFFFFFFFFE0]
                mov  rsi, qword ptr [rsp + 0x48 + 0xFFFFFFFFFFFFFFE8]
                push rbx
                push rcx
                push rdx
                push r11
                push r15
                mov  rdx, {(long)pSeek}
                mov  rbx, rax
                mov  rbx, [rbx]               ; dereference pointer to collision info map [int64, int32]
                test rbx, rbx                 ; check if null
                jz   exit
                mov  ecx, dword ptr [rbx + 8] ; store vertex count
                imul ecx, 4                   ; multiply vertex count by 4 to get an appropriate iteration size
                mov  rbx, [rbx]               ; dereference pointer to collision info
            iterate:
                cmp  dword ptr [rdx], ecx     ; iterate through vertices to set info for each
                jge  exit
                mov  r15d, dword ptr [rdx]    ; store current iteration
                mov  r11, rbx
                add  r11, r15                 ; add offset to address
                mov  r15d, dword ptr [r11]    ; store current collision info for modification
                and  r15d, 0xFFFFFDFF         ; clear 9th bit
                mov  dword ptr [r11], r15d    ; store modified collision info in original array
                add  dword ptr [rdx], 4       ; increment by 4 (32-bit integers)
                jmp  iterate
            exit:
                mov  dword ptr [rdx], 0       ; reset incrementation
                pop  r15
                pop  r11
                pop  rdx
                pop  rcx
                pop  rbx
            ",

            /* 0x140A9FBF3 */
            ScanSignature
            (
                "\x4C\x8B\x74\x24\x20\x48\x8B\x7C\x24\x28\x48\x8B\x74\x24\x30\x48\x8B\x00",
                "xxxxxxxxxxxxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}

Patch "Disable Drift Dash Panels" in "Gameplay" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x140482A6E */
        ScanSignature
        (
            "\x48\x8B\xC2\x48\x8B\xF9\x48\x8B\xC8\x48\x8D\x15\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x4C\x8B\xF8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x4C\x8B\xE8",
            "xxxxxxxxxxxx????x????xxxx????xxxxxxx????xxx"
        ),

        0xE9, 0x24, 0x03, 0x00, 0x00
    );
}

Patch "Disable Drop Dash" in "Gameplay" by "Hyper"
{
    // Disable drop dash charge from StateDoubleJump.
    WriteProtected<byte>
    (
        /* 0x14B52AAA7 */
        ScanSignature
        (
            "\x0F\x84\x94\x00\x00\x00\x48\x89\xF9",
            "xxxxxxxxx"
        ),

        0xE9, 0x95, 0x00, 0x00, 0x00
    );

    // Disable drop dash from StateDoubleJump.
    WriteProtected<byte>
    (
        /* 0x14B4C1A03 */
        ScanSignature
        (
            "\x74\x14\xF3\x0F\x10\x8F\xB4\x00\x00\x00",
            "xxxxxxxxxx"
        ),

        0xEB
    );

    // Disable drop dash charge from StateRecoveryJump.
    WriteProtected<byte>
    (
        /* 0x1408A0A37 */
        ScanSignature
        (
            "\x0F\x84\xB7\x00\x00\x00\x80\xBE\xC4\x00\x00\x00\x00",
            "xxxxxxxxxxxxx"
        ),

        0xE9, 0xB8, 0x00, 0x00, 0x00
    );
}

Patch "Disable Drop Dash Camera Delay" in "Camera" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x140843092 */
        ScanSignature
        (
            "\x73\x2A\xF3\x0F\x10\x05\xCC\xCC\xCC\xCC\x45\x33\xC9",
            "xxxxxx????xxx"
        ),

        0xEB
    );
}

Patch "Disable Drop Dash Turning Delay" in "Physics" by "Hyper" does "Disables the out of control timer that determines when Sonic can start turning whilst drop dashing."
{
    WriteNop
    (
        /* 0x14084323B */
        ScanSignature
        (
            "\x73\x19\x48\x8B\x47\x40",
            "xxxxxx"
        ),

        2
    );
}

Patch "Disable Dropped Rings" in "Gameplay" by "Hyper" does "Removes the bouncing rings when taking damage."
{
    WriteNop
    (
        /* 0x14089024B */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x4C\x8D\x05\xCC\xCC\xCC\xCC\x48\x8B\xD7\x48\x8D\x4D\x77",
            "x????xxx????xxxxxxx"
        ),

        5
    );
}

Patch "Hide Fixed Camera Notifications" in "UI" by "Hyper" does "Hides the fixed camera icon at the top-right of the screen, as well as the tutorial about it at the beginning of the game."
{
    // Disable fixed camera UI element.
    WriteProtected<byte>
    (
        /* 0x1408FA3DB */
        ScanSignature
        (
            "\x0F\x84\xEB\x00\x00\x00\x83\xF8\xFD\x0F\x84\x89\x00\x00\x00",
            "xxxxxxxxxxxxxxx"
        ),

        0xEB, 0x0D
    );

    // Disable guide regarding fixed camera.
    WriteProtected<byte>
    (
        /* 0x148BBC22A */
        ScanSignature
        (
            "\x0F\x84\x5D\x01\x00\x00\x4C\x89\xB4\x24\x88\x00\x00\x00",
            "xxxxxxxxxxxxxx"
        ),

        0xE9, 0x5E, 0x01, 0x00, 0x00
    );
}

Patch "Disable Bullet Time" in "Gameplay" by "Hyper" does
/*
Disables the slow-mo sequences when performing certain actions.

Notes;
- This only applies to sequences that apply the bullet time filter, other actions like QTEs will remain unchanged.
*/
{
    // Disable bullet time for bosses and parry.
    WriteProtected<byte>
    (
        /* 0x1402193E0 */
        ScanSignature
        (
            "\x40\x53\x48\x83\xEC\x50\x0F\x29\x74\x24\x40\x48\x8B\xD9\x0F\x29\x7C\x24\x30\x0F\x28\xF1",
            "xxxxxxxxxxxxxxxxxxxxxx"
        )
        + 0x06,

        0xEB, 0x40
    );

    // Disable bullet time audio for parry.
    WriteProtected<byte>
    (
        /* 0x1408CF3BF */
        ScanSignature
        (
            "\x4C\x8D\x05\xCC\xCC\xCC\xCC\x48\x8B\xD7\x48\x8D\x4C\x24\x60\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4E\x58",
            "xxx????xxxxxxxxx????xxxx"
        ),

        0xEB, 0x40
    );

    // Disable bullet time for Giganto dash rings.
    WriteProtected<byte>
    (
        /* 0x1402A1C4F */
        ScanSignature
        (
            "\x48\x8D\x4D\x97\x0F\x28\xF9",
            "xxxxxxx"
        ),

        0xE9, 0xCC, 0x00, 0x00, 0x00
    );

    // Disable bullet time for Ninja.
    WriteProtected<byte>
    (
        /* 0x1405A7E7B */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4E\x3C\xE8\xCC\xCC\xCC\xCC\x84\xC0\x75\x37",
            "x????xxxxx????xxxx"
        ),

        0xEB, 0x77
    );
}

Patch "Disable Bullet Time Filter" in "Graphics" by "Hyper" does "Disables the greyscale filter applied when entering bullet time from a parry."
{
    WriteNop
    (
        /* 0x140219623 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCB\xFF\x15\xCC\xCC\xCC\xCC\x4C\x8D\x9C\x24\xB0\x00\x00\x00",
            "x????xxxxx????xxxxxxxx"
        ),

        5
    );
}

Patch "Disable Fishing Jingle" in "Audio" by "Hyper" does "Disables the jingle that plays when successfully reeling in a fish."
{
    WriteNop
    (
        /* 0x1406D82AA */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x8B\x8E\x78\x02\x00\x00\xE8\xCC\xCC\xCC\xCC\x84\xC0\x74\x0F",
            "x????xxxxxxx????xxxx"
        ),

        5
    );
}

Patch "Disable Forced Time" in "Time" by "Hyper" does "Disables the time being forced to specific values during events, sequences and bosses."
{
    WriteProtected<byte>
    (
        /* 0x1401D56DA */
        ScanSignature
        (
            "\x48\x8B\xF9\x45\x0F\xB6\xF0\x48\x81\xC1\x88\x00\x00\x00",
            "xxxxxxxxxxxxxx"
        ),

        0xE9, 0xB4, 0x00, 0x00, 0x00
    );

    WriteProtected<byte>
    (
        /* 0x1401D5797 */
        ScanSignature
        (
            "\x74\x0B\x0F\xB6\xD3\x48\x8B\xCF",
            "xxxxxxxx"
        ),

        0xEB
    );

    // Disable time pausing.
    WriteProtected<byte>
    (
        /* 0x14BD4C70E */
        ScanSignature
        (
            "\x74\x15\x45\x31\xC0\xE8",
            "xxxxxx"
        ),

        0xEB
    );
}

Patch "Disable Forced Weather for Bosses" in "Weather" by "Hyper" does "Disables the weather being forced to Sunny for Giganto and Supreme."
{
    // Giganto
    WriteProtected<byte>
    (
        /* 0x14024E456 */
        ScanSignature
        (
            "\x74\x0A\x33\xD2\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x8B\x46\x18\x48\x8B\x48\x28\x48\x8B\x59\x48\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD8",
            "xxxxxxxx????xxxxxxxxxxxxx????xxxxxxx????xxx"
        ),

        0xEB
    );

    // Supreme
    WriteProtected<byte>
    (
        /* 0x1402AFE04 */
        ScanSignature
        (
            "\x74\x0A\x33\xD2\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x8B\x46\x18\x48\x8B\x48\x28\x48\x8B\x59\x48\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x45\x33\xFF",
            "xxxxxxxx????xxxxxxxxxxxxx????xxxxxxx????xxx"
        ),

        0xEB
    );
}

Patch "Disable Fortress (experimental)" in "Enemy" by "Hyper" does
/*
Disables the Fortress guardian on Chaos Island.

Known issues;
- This also affects Battle Rush and causes a softlock.
*/
{
    WriteNop
    (
        /* 0x140677B6D */
        ScanSignature
        (
            "\x75\x2B\x45\x33\xC0\x33\xD2\x48\x8B\xCB",
            "xxxxxxxxxx"
        ),

        2
    );
}

Patch "Disable Framerate Limiter (experimental)" in "Graphics" by "NM & M&M" does
/*
Disables the framerate limiter, allowing the game to run above its targeted 30/60 FPS limit.

Known issues;
- The game speed can fluctuate.
- The final QTE for Wyvern takes a long time to show up.
- The falling platforms in Cyber Space levels 2-5, 2-7, and 3-3 will activate more quickly.
- The spawn point in Cyber Space 4-3 will throw you into an invisible wall.
- The light dash may disconnect from the path in some cases.
*/
{
    /*
        At the moment, this is the best method I have found for uncapping FPS.
        There are **most likely** much better ways of removing the FPS cap, and there is definitely room for improvement within this script.
        This script utilizes two steps to eliminate the cap, all of which will be outlined below.
    */

    /*
        Frontiers seemingly utilizes a sleep function when limiting FPS, and so we must first prevent that function from being called.
        By NOPing these opcodes and not changing anything else, however, the game will speed up.
    */
    WriteNop
    (
        /* 0x140BB9FB0 */
        ScanSignature
        (
            "\xE8\x00\x00\x00\x00\x48\x8D\x4C\x24\x00\xE8\x00\x00\x00\x00\x48\x8B\x4C\x24\x00\x48\x8B\x43\x20",
            "x????xxxx?x????xxxx?xxxx"
        ),

        5
    );

    /*
        The change in speed is seemingly caused by the cap not being in sync with the current FPS. To fix this, we must first uncap the value of a current FPS address.
        The cap is controlled by the opcode "cmova rax, rdi," where RAX is the calculated current FPS and RDI is the user's set FPS cap. To remove this, we will be scanning for the opcode before it.
        From 0x140BBA081 to 0x140BBA08A, there are 15 bytes. This will allow us to successfully write the hook, which is 14 bytes long.
    */
    WriteAsmHook
    (
        /*
            To get rid of the opcode which enforces the cap, we simply do not include it. We can also remove "comiss xmm1, dword ptr [rdi]," which invokes the comparison.
            With the current FPS address' value uncapped (EAX), we can now write it to the FPS cap address, which is stored in RDI. This will sync the FPS cap with the actual FPS, fixing the speedup issue.
        */
        @"
            mov eax, dword ptr [rax]
            mov dword ptr [rbx+00000144h], eax
            mov dword ptr [rdi], eax
        ",

        /* 0x140BBA081 */
        ScanSignature
        (
            "\x0F\x2F\x0F\x48\x0F\x47\xC7\x8B\x00\x89\x83\x00\x00\x00\x00",
            "xxxxxxxxxxx????"
        ),

        HookBehavior.Replace
    );

    /*
        This removes the framerate limiting code for cutscenes.
    */
    long instrAddr = ScanSignature
    (
        /* 0x140126D90 */
        "\x0F\xB7\x88\x00\x00\x00\x00\x66\xC1\xE9\x0E\xF6\xC1\x01\x74\x23\x48\x8B\x05\x00\x00\x00\x00\xF3\x0F\x10\x0D\x00\x00\x00\x00\xC6\x40\x10\x01\x48\x8B\x0D\x00\x00\x00\x00\x48\x83\xC4\x28\xE9\x00\x00\x00\x00",
        "xxx????xxxxxxxxxxxx????xxxx????xxxxxxx????xxxxx????"
    );

    if (instrAddr != 0)
        WriteProtected<byte>(instrAddr, 0xEB, 0x31);

    /*
        Frontiers limits the monitor refresh rate to 60hz and forces VSync when in fullscreen.
        To prevent the game from doing this, we set both of these bytes to 0.
    */
    instrAddr = ScanSignature
    (
        /* 0x140F4198E */
        "\xC7\x45\xF8\x3C\x00\x00\x00\xC7\x45\xFC\x01\x00\x00\x00\x41\x8B\x04\x24\x41\x0F\xB6\x4C\x24\x14\x41\x0F\xB6\x7C\x24\x1C\x89\x45\xF0\x41\x8B\x44\x24\x04\x89\x45\xF4\xE8\xCC\xCC\xCC\xCC\x40\x84\xFF\x74\x05\x8B\x40\x18\xEB\x03",
        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxx"
    );

    WriteProtected<byte>(instrAddr + 3, 0);
    WriteProtected<byte>(instrAddr + 10, 0);
}

Patch "Disable Framerate Limiter in Cutscenes (experimental)" in "Graphics" by "M&M" does
/*
Disables the framerate limiter for (most) cutscenes, allowing them to run at 60 FPS.

Known issues;
- Certain cutscenes will still operate at 30 FPS due to how this game syncs cutscene audio.
*/
{
    long instrAddr = ScanSignature
    (
        /* 0x140126D90 */
        "\x0F\xB7\x88\x00\x00\x00\x00\x66\xC1\xE9\x0E\xF6\xC1\x01\x74\x23\x48\x8B\x05\x00\x00\x00\x00\xF3\x0F\x10\x0D\x00\x00\x00\x00\xC6\x40\x10\x01\x48\x8B\x0D\x00\x00\x00\x00\x48\x83\xC4\x28\xE9\x00\x00\x00\x00",
        "xxx????xxxxxxxxxxxx????xxxx????xxxxxxx????xxxxx????"
    );

    if (instrAddr != 0)
        WriteProtected<byte>(instrAddr, 0xEB, 0x31);
}

Patch "Disable FidelityFX Super Resolution (experimental)" in "Graphics" by "Hyper" does
/*
Disables the upsampling post-processing applied to the game.

This will reduce sharpening artefacts like subtle haloing around geometry.

Known issues;
- The game will be blurry when anything other than TAA is used.
*/
{
    WriteProtected<byte>
    (
        /* 0x140EFCEB7 */
        ScanSignature
        (
            "\x41\x0F\xBE\x56\x0D",
            "xxxxx"
        ),

        Assemble("mov edx, 0")
    );
}

Patch "Disable Grass" in "Graphics" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x140F1A7C0 */
        ScanSignature
        (
            "\x0F\x84\xE4\x12\x00\x00",
            "xxxxxx"
        ),

        0xE9, 0xE5, 0x12, 0x00, 0x00
    );
}

Patch "Disable Guardian Introductions" in "Enemy" by "Hyper" does "Disables the sequence that zooms the camera into guardians and displays their name."
{
    // Asura
    WriteProtected<byte>
    (
        /* 0x14053025E */
        ScanSignature
        (
            "\x74\x0A\xBA\x00\x00\x00\x00\xE9\x00\x00\x00\x00\x48\x8B\x5E\x18",
            "xxx????x????xxxx"
        )
        + 2,

        Assemble("mov edx, 7")
    );

    // Ninja
    WriteProtected<byte>
    (
        /* 0x14056EA88 */
        ScanSignature
        (
            "\xBA\x02\x00\x00\x00\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x8B\x5F\x18\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x48\x8B\xC8",
            "xxxxxxxxx????xxxxx????xxxxxxx????xxx"
        ),

        Assemble("mov edx, 3")
    );

    // Caterpillar
    WriteProtected<byte>
    (
        /* 0x14057528B */
        ScanSignature
        (
            "\xBA\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\x5E\x18\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\x9C\x24\x00\x00\x00\x00\x84\xC0\x75\x12\x48\x8B\xCE\xE8\x00\x00\x00\x00\x33\xD2\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\xB4\x24\x00\x00\x00\x00\x32\xC0\x48\x83\xC4\x78\xC3\x32\xC0\x48\x83\xC4\x78\xC3\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\x48\x8B\xC4",
            "x????xxxx????xxxxx????xxxxxxx????xxxx????xxxx????xxxxxxxx????xxxxxx????xxxx????xxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        Assemble("mov edx, 3")
    );

    // Tower
    WriteProtected<byte>
    (
        /* 0x14059E877 */
        ScanSignature
        (
            "\x0F\x84\x00\x00\x00\x00\x48\x8B\x5E\x18\x0F\x29\x74\x24\x00\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\x88\x00\x00\x00\x00",
            "xx????xxxxxxxx?x????xxxxxxx????xxx????"
        ),

        0xE9, 0xC7, 0x00, 0x00, 0x00
    );

    // Squid
    WriteProtected<byte>
    (
        /* 0x1405B19AC */
        ScanSignature
        (
            "\xBA\x00\x00\x00\x00\xEB\x2A\x48\x8B\x5E\x18",
            "x????xxxxxx"
        ),

        Assemble("mov edx, 3")
    );

    // Shark
    WriteProtected<byte>
    (
        /* 0x1405E68D8 */
        ScanSignature
        (
            "\x0F\x85\x94\x01\x00\x00\x48\x89\x58\x08",
            "xxxxxxxxxx"
        ),

        0xE9, 0x80, 0x01, 0x00, 0x00
    );

    // Spider
    WriteProtected<byte>
    (
        /* 0x1405E4186 */
        ScanSignature
        (
            "\xBA\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\x5E\x18\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x84\xC0\x75\x12\x48\x8B\xCE\xE8\x00\x00\x00\x00\x33\xD2\x48\x8B\xC8\xE8\x00\x00\x00\x00\x0F\x28\x74\x24\x00\x4C\x8D\x5C\x24\x00\x49\x8B\x5B\x10\x32\xC0\x49\x8B\x73\x18\x49\x8B\xE3\x5F\xC3\xCC\xCC\x48\x89\x5C\x24\x00\x48\x89\x6C\x24\x00",
            "x????xxxx????xxxxx????xxxxxxx????xxxx????xxxxxxxx????xxxxxx????xxxx?xxxx?xxxxxxxxxxxxxxxxxxxxx?xxxx?"
        ),

        Assemble("mov edx, 3")
    );

    // Strider
    WriteProtected<byte>
    (
        /* 0x1405FE226 */
        ScanSignature
        (
            "\xBA\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\x5E\x18\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x84\xC0\x75\x15",
            "x????xxxx????xxxxx????xxxxxxx????xxxx????xxxx"
        ),

        Assemble("mov edx, 2")
    );

    // Sumo
    WriteProtected<byte>
    (
        /* 0x140633416 */
        ScanSignature
        (
            "\x74\x15\x48\x8B\xCE\xE8\x00\x00\x00\x00\xBA\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\x5E\x18\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x84\xC0\x75\x12\x48\x8B\xCE\xE8\x00\x00\x00\x00\x33\xD2\x48\x8B\xC8\xE8\x00\x00\x00\x00\x0F\x28\x74\x24\x00\x4C\x8D\x5C\x24\x00\x49\x8B\x5B\x10\x32\xC0\x49\x8B\x73\x18\x49\x8B\xE3\x5F\xC3\xCC\xCC\x48\x89\x5C\x24\x00\x48\x89\x74\x24\x00",
            "xxxxxx????x????xxxx????xxxxx????xxxxxxx????xxxx????xxxxxxxx????xxxxxx????xxxx?xxxx?xxxxxxxxxxxxxxxxxxxxx?xxxx?"
        )
        + 0x0A,

        Assemble("mov edx, 8")
    );

    // Tank
    WriteProtected<byte>
    (
        /* 0x14065B0FB */
        ScanSignature
        (
            "\xBA\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\x5E\x18\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\x9C\x24\x00\x00\x00\x00\x84\xC0\x75\x12\x48\x8B\xCE\xE8\x00\x00\x00\x00\x33\xD2\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\xB4\x24\x00\x00\x00\x00\x32\xC0\x48\x83\xC4\x78\xC3\x32\xC0\x48\x83\xC4\x78\xC3\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\x40\x56",
            "x????xxxx????xxxxx????xxxxxxx????xxxx????xxxx????xxxxxxxx????xxxxxx????xxxx????xxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        Assemble("mov edx, 4")
    );
}

Patch "Disable Guardian Music (experimental) (v1.20)" in "! Incompatible - awaiting fixes for v1.30" by "Hyper" does
/*
Disables the music specific to each guardian on the islands.

Known issues;
- Jukebox will persist during Battle Rush if you previously used it on the islands before entering it.
*/
{
    // Original category: Audio

    /* 0x140927340 */
    long fpGetBgmInfo = ScanSignature
    (
        "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x63\xDA\x48\x8B\xF9\x48\x8B\x49\x10",
        "xxxxxxxxxxxxxxxxxxxx"
    );

    WriteAsmHook
    (
        $@"
            push r13
            push r14
            push r15

            mov  edx, [rdi]
            mov  rcx, rbx
            mov  rax, {fpGetBgmInfo}
            call rax

            cmp  qword ptr [rax], 0       ; check if cue name is null
            jz   exit
            mov  r13, qword ptr [rax]     ; store pointer to cue name

            ; world's fastest strcmp
            mov  r14, qword ptr [r13 + 4] ; read cue name without prefix (8 characters)
            mov  r15, 0x73736F62696E696D  ; miniboss
            cmp  r14, r15
            je   setBgmInfo
            mov  r15, 0x655F656C676E696A  ; jingle_e
            cmp  r14, r15
            je   setBgmInfo
            mov  r14d, dword ptr [r13 + 4] ; read cue name without prefix (4 characters)
            mov  r15d, 0x6D656E65          ; enem
            cmp  r14d, r15d
            je   setBgmInfo
            jmp  exit

        setBgmInfo:
            mov  byte ptr [rax + 0x39], 1  ; set isOverlapPlay to 1
            mov  byte ptr [rax + 0x3A], -1 ; set priority to -1
            mov  byte ptr [rax + 0x3B], -1 ; set interruptType to -1

        exit:
            cmp  byte ptr [rax + 0x39], 0
            pop  r13
            pop  r14
            pop  r15
        ",

        /* 0x140926520 */
        ScanSignature
        (
            "\x8B\x17\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x80\x78\x39\x00",
            "xxxxxx????xxxx"
        ),

        HookBehavior.Replace
    );

    // Fix Sumo stopping music playback when damaged.
    WriteProtected<byte>
    (
        /* 0x14066A4CA */
        ScanSignature
        (
            "\x75\x05\x40\x84\xFF\x74\x19",
            "xxxxxxx"
        ),

        0xEB, 0x1E
    );
}

Patch "Disable Hit Stop" in "Gameplay" by "Hyper" does "Disables the slow motion effect after performing attacks."
{
    WriteAsmHook
    (
        $@"
            xorps  xmm3, xmm3
            movaps xmm7, xmm3
            mov    r8, [rcx + 0xB0]
            mov    esi, edx
            add    rax, r8
        ",

        /* 0x147689E7F */
        ScanSignature
        (
            "\x0F\x28\xFB\x4C\x8B\x81\xB0\x00\x00\x00",
            "xxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Disable Idle Kocos" in "Gameplay" by "Hyper" does "Disables the Kocos appearing in front of Sonic when idle."
{
    WriteNop
    (
        /* 0x1406B8199 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\x5C\x24\x50\x48\x8B\x6C\x24\x68",
            "x????xxxxxxxxxx"
        ),

        5
    );
}

Patch "Disable Idle Music Volume Reduction" in "Audio" by "Hyper" does "Disables the timer that lowers the game's music volume when idle for too long."
{
    WriteNop
    (
        /* 0x1408BEE05 */
        ScanSignature
        (
            "\x89\x03\x8B\x41\x04",
            "xxxxx"
        ),

        2
    );
}

Patch "Disable In-Game Letterboxing (experimental)" in "Graphics" by "Hyper" does
/*
Disables letterboxing for in-game cutscenes and Training Simulator.

Known issues;
- This does not work for pre-rendered cutscenes.
- Filter 7 in Photo Mode utilises this letterbox element, so it doesn't show up there.
*/
{
    WriteProtected<byte>
    (
        /* 0x14C9B8FA4 */
        ScanSignature
        (
            "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x48\x89\x7C\x24\x18\x55\x48\x8D\x6C\x24\xA9\x48\x81\xEC\x90\x00\x00\x00\x48\x8D\x05\xCC\xCC\xCC\xCC\x48\xC7",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx????xx"
        )
        + 0x124,

        0xEB
    );
}

Patch "Disable Jump Board Paths on Islands" in "Gameplay" by "Hyper" does "Stops Sonic locking to a path when hitting jump boards, allowing him to fling off them like ramps."
//
    #lib "Memory"

    static bool IsWorldIsland = false;
//
{
    fixed (bool* pIsWorldIsland = &IsWorldIsland)
    {
        /* This hook checks if we're on an island
            and stores that in a boolean. */
        WriteAsmHook
        (
            $@"
                push rdx

                ; Restore original code.
                mov qword ptr [rsp + 0x38 + 0x08], rdi
                lea rbx, qword ptr [rsi + 0x50]
                mov qword ptr [rsp + 0x28 + 0x10], r14

                ; Check field for stage type.
                test byte ptr [rcx + 0xB8], 0x2E
                setz al

                ; Store result in our local boolean.
                mov rdx, {(long)pIsWorldIsland}
                mov byte ptr [rdx], al

                pop rdx
            ",

            /* 0x149122469 */
            ScanSignature
            (
                "\x48\x89\x7C\x24\x30\x48\x8D\x5E\x50\x4C\x89\x74\x24\x38\x4C\x89\x7C\x24\x40\xE8\xCC\xCC\xCC\xCC\xBF\x03\x00\x00\x00\x84\xC0\x74\x64",
                "xxxxxxxxxxxxxxxxxxxx????xxxxxxxxx"
            ),

            HookBehavior.Replace
        );

        /* 0x149127E03 */
        long callerFuncAddr = ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x80\x7D\xE5\x00\x0F\x84\xE4\x00\x00\x00",
            "x????xxxxxxxxxx"
        );

        /* 0x140DDDE40 */
        long sendMsgFunc = Memory.ReadCall(callerFuncAddr);

        /* This hook checks if we're on an island and calls
           the message sender to enter Sonic into the jump
           board path if we're in Cyber Space. */
        WriteAsmHook
        (
            $@"
                ; Check if we're on an island.
                mov rbx, {(long)pIsWorldIsland}
                cmp byte ptr [rbx], 0

                ; Non-zero value means we're on an island - jump to end.
                jnz ret

                ; Set up message sender function call.
                lea r8, qword ptr [rbp + 0x57 + 0xFFFFFFFFFFFFFF40]
                lea rdx, qword ptr [rbp + 0x57 + 0x10]
                mov ecx, [rax]
                mov dword ptr [rbp + 0x57 + 0x10], ecx
                mov rcx, rsi

                ; We're not on an island - call message sender.
                mov  r9, {(long)sendMsgFunc}
                call r9

            ret:
            ",

            /* 0x149127DF7 */
            ScanSignature
            (
                "\x48\x8D\x55\x67\x8B\x08\x89\x4D\x67\x48\x89\xF1",
                "xxxxxxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}

Patch "Disable Keyboard Input" in "System" by "Hyper" does "Disables input from the keyboard."
{
    WriteProtected<byte>
    (
        /* 0x140E11CC6 */
        ScanSignature
        (
            "\x0F\x84\x9C\x00\x00\x00\x48\x8B\xB7\xB8\x01\x00\x00",
            "xxxxxxxxxxxxx"
        ),

        0xE9, 0x9D, 0x00, 0x00, 0x00
    );
}

Code "Disable Lava Instant Death" in "Gameplay" by "Hyper" does "Disables Sonic instantly drowning in lava and makes him jump up from the heat until running out of rings."
//
    #lib "BlackboardItem"
    #lib "Memory"

    static bool IsInitialised = false;

    static int RingCount = 0;
//
{
    if (!IsInitialised)
    {
        fixed (int* pRingCount = &RingCount)
        {
            /* 0x1408D78F7 */
            long sig = ScanSignature
            (
                "\xF6\x43\x54\x40\x0F\x84\xD0\x00\x00\x00",
                "xxxxxxxxxx"
            );

            WriteAsmHook
            (
                $@"
                    mov rcx, {(long)pRingCount}
                    cmp dword ptr [rcx], 0
                    jnz exit
                    mov rdx, {Memory.ReadJump(sig + 0x04)}
                    jmp rdx
                exit:
                    lea edx, dword ptr [rax - 0x03]
                    mov r8d, 0x800000
                ",

                sig,

                HookBehavior.Replace
            );
        }

        IsInitialised = true;
    }

    RingCount = BlackboardItem.GetRingCount();
}

Patch "Disable Loop Kick on Slide" in "Gameplay" by "Hyper"
{
    WriteNop
    (
        /* 0x14082EB20 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x48\x8B\xC8\x45\x33\xC0\xB2\x1C",
            "x????xxxx????xxxxxxxx"
        ),

        5
    );
}

Patch "Disable Menu Restrictions" in "UI" by "Hyper" does
/*
Removes restrictions from accessing certain menu screens and options.

Notes;
- This grants you the full pause menu, including the Skills and Save Data menus, within reasonable areas (e.g. the tutorial).
- This grants you permission to save and load anywhere, including during combat.
- This will allow you to open the map screen during combat.
- This will allow you to place map markers before having completed any challenges.
- This will allow you to enter Photo Mode during inaccessible parts of the game where Photo Mode is usually accessible.
*/
{
    // Disable save/load deny.
    WriteProtected<byte>
    (
        /* 0x14D01D0E1 */
        ScanSignature
        (
            "\x74\x19\x8B\x0D\xCC\xCC\xCC\xCC\x81\xF1\x49\x8D\x64\x24",
            "xxxx????xxxxxx"
        ),

        0xEB
    );

    // Disable "SetHUDEnabled" callback function.
    WriteProtected<byte>
    (
        /* 0x14BE36C85 */
        ScanSignature
        (
            "\x0F\x84\xE0\x00\x00\x00\x44\x0F\xBE\xC0",
            "xxxxxxxxxx"
        ),

        0xE9, 0xE1, 0x00, 0x00, 0x00
    );

    // Disable map screen restriction during combat.
    WriteProtected<byte>
    (
        /* 0x1408E735D */
        ScanSignature
        (
            "\x0F\x94\x44\x24\x48\x89\x5C\x24\x44",
            "xxxxxxxxx"
        ),

        Assemble("mov byte ptr [rsp + 0x58 + 0xFFFFFFFFFFFFFFF0], 1")
    );

    // Disable map marker lock.
    WriteProtected<byte>
    (
        /* 0x1409CFB91 */
        ScanSignature
        (
            "\xF6\x87\x1C\x04\x00\x00\x02\x74\x29",
            "xxxxxxxxx"
        ),

        Assemble("mov byte ptr [rsi + 0x41C], 2; nop; nop")
    );

    // Disable "Unlock Cyloop" tutorial to prevent softlock.
    WriteNop
    (
        /* 0x14091E0B6 */
        ScanSignature
        (
            "\x0F\x44\xD9\xBA\x3D\x23\x00\x00",
            "xxxxxxxx"
        ),

        3
    );

    // Disable Photo Mode check.
    WriteProtected<byte>
    (
        /* 0x1409BF7A2 */
        ScanSignature
        (
            "\x0F\x84\xED\x00\x00\x00\x48\x8B\x5F\x18\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x33\xD2",
            "xxxxxxxxxxx????xxxxxxx????xx"
        ),

        0xE9, 0xEE, 0x00, 0x00, 0x00
    );
}

Patch "Disable Monologue Restrictions" in "Audio" by "WasifBoomz" does
/*
Removes restrictions for random monologue playback during gameplay.

Notes;
- This allows monologues to play anywhere, rather than only on heightmap terrain.
*/
{
    WriteProtected<byte>
    (
        /* 0x1401CA016 */
        ScanSignature
        (
            "\x74\x0E\x8B\x47\x48",
            "xxxxx"
        ),

        0xEB
    );
}

Code "Disable Mouse Input" in "System" by "Hyper" does
/*
Disables input from the mouse and unhooks the cursor from the game window.

Notes;
- This is mainly useful for debugging, to prevent the game stealing focus from debuggers (e.g. Cheat Engine) when modal windows are opened.
- This code is incompatible with Always Hide Mouse Cursor, but the cursor will no longer be in inconvenient locations whilst visible.
*/
//
    [System.Runtime.InteropServices.DllImport("user32.dll")]
    static extern int ShowCursor(bool bShow);

    static bool IsInitialised = false;
//
{
    /* There's way too many calls to this in the game,
       I'm just gonna force ShowCursor() every frame. */
    ShowCursor(true);

    if (IsInitialised)
        return;

    // Disable pointing for menus.
    WriteProtected<byte>
    (
        /* 0x140E37536 */
        ScanSignature
        (
            "\x74\x6C\x48\x8D\x4C\x24\x48",
            "xxxxxxx"
        ),

        0xEB
    );

    // Disable mouse axis mapping.
    WriteProtected<byte>
    (
        /* 0x140E36EB0 */
        ScanSignature
        (
            "\x81\xC2\x00\x00\xFC\xFF\x83\xFA\x0C",
            "xxxxxxxxx"
        ),

        Assemble("xorps xmm0, xmm0; ret")
    );

    // Disable mouse cursor hook.
    WriteProtected<byte>
    (
        /* 0x140E2B6D9 */
        ScanSignature
        (
            "\x0F\x28\xF1\x48\x85\xDB\x74\x6C",
            "xxxxxxxx"
        ),

        0xE9, 0x8D, 0x00, 0x00, 0x00
    );

    // Disable mouse cursor clipping.
    WriteProtected<byte>
    (
        /* 0x140C7D7F0 */
        ScanSignature
        (
            "\x0F\x84\x63\xFF\xFF\xFF\x48\x8D\x55\xC8",
            "xxxxxxxxxx"
        ),

        0xE9, 0x64, 0xFF, 0xFF, 0xFF
    );

    // Disable mouse cursor position override on focus change.
    WriteProtected<byte>
    (
        /* 0x140C7D725 */
        ScanSignature
        (
            "\x74\x24\x48\x8B\x08\x48\x8D\x55\xC8",
            "xxxxxxxxx"
        ),

        0xEB
    );

    /* 0x140C7D725 */
    long sig = ScanSignature
    (
        "\x48\x85\xC9\x74\x1B\x48\x8D\x54\x24\x20",
        "xxxxxxxxxx"
    );

    // Disable mouse cursor position override on foreground window change.
    WriteProtected<byte>(sig, Assemble("xor rcx, rcx"));
    WriteProtected<byte>(sig + 0x03, 0xEB);

    IsInitialised = true;
}

Patch "Disable Parry Targeting" in "Gameplay" by "Hyper" does "Disables Sonic automatically targeting the nearest enemy when parrying."
{
    WriteNop
    (
        /* 0x14087B767 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\x46\x38\xBA\x01\x02\x8F\x12",
            "x????xxxxxxxxx"
        ),

        5
    );
}

Patch "Disable Photo Mode Camera Collision" in "Camera" by "Hyper"
{
    // Camera position
    WriteProtected<byte>
    (
        /* 0x1400A6BD2 */
        ScanSignature
        (
            "\x0F\x84\x1D\x02\x00\x00\xF3\x0F\x10\x0D",
            "xxxxxxxxxx"
        ),

        0xE9, 0x1E, 0x02, 0x00, 0x00
    );

    // Camera rotation
    WriteProtected<byte>
    (
        /* 0x1400A639E */
        ScanSignature
        (
            "\x0F\x84\xAA\x01\x00\x00\x0F\x28\x8D\x80\x00\x00\x00",
            "xxxxxxxxxxxxx"
        ),

        0xE9, 0xAB, 0x01, 0x00, 0x00
    );

    // Camera position (water)
    WriteProtected<byte>
    (
        /* 0x1400A6EC6 */
        ScanSignature
        (
            "\x73\x33\x48\x8D\x55\x80",
            "xxxxxx"
        ),

        0xEB
    );

    // Camera rotation (water)
    WriteProtected<byte>
    (
        /* 0x1400A661E */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\xF3\x0F\x10\x40\x14\x0F\x2F\xC7\x73\x04",
            "x????xxxxxxxxxx"
        ),

        0xEB, 0x11
    );
}

Patch "Disable Photo Mode Distance Limit" in "Camera" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x1400A6B33 */
        ScanSignature
        (
            "\x76\x79\x0F\x10\x23",
            "xxxxx"
        ),

        0xEB
    );
}

Patch "Disable Photo Mode Tilt Limit" in "Camera" by "Hyper"
{
    /* 0x1400A5F66 */
    var addr = ScanSignature
    (
        "\x72\x1D\x41\x0F\x2F\xC2",
        "xxxxxx"
    );

    WriteNop(addr, 2);
    WriteProtected<byte>(addr + 0x16, Assemble("mov rax, rcx; nop"));
}

Patch "Disable Photo Mode Zoom Limit" in "Camera" by "Hyper"
{
    /* 0x1400A5D69 */
    var addr = ScanSignature
    (
        "\x72\x1C\x41\x0F\x2F\xF0",
        "xxxxxx"
    );

    WriteNop(addr, 2);
    WriteProtected<byte>(addr + 0x16, Assemble("mov rax, rcx; nop"));
}

Patch "Disable Photo Mode Orbit Camera (experimental)" in "Camera" by "Hyper" does
/*
Makes the camera in Photo Mode control more like a first-person camera, rather than orbiting a specific point.

Known issues;
- The camera will always point up in Supreme's arena.
*/
//
    static float Distance = 0.1f;
//
{
    fixed (float* pDistance = &Distance)
    {
        WriteAsmHook
        (
            $@"
                push  rax
                mov   rcx, rsi
                lea   rcx, [rsi + 0x50]
                mov   rax, {(long)pDistance}
                movss xmm7, dword ptr [rax]
                pop   rax
            ",

            /* 0x1400A55CB */
            ScanSignature
            (
                "\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4E\x50\xF3\x0F\x10\x78\x2C",
                "xxxx????xxxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}

Patch "Disable Power Boost" in "Gameplay" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x1408D27AA */
        ScanSignature
        (
            "\x74\x2A\x0F\xBE\x43\x30\x66\x0F\x6E\xC8\x0F\xBE\x43\x31\x0F\x5B\xC9\x66\x0F\x6E\xC0\x0F\x5B\xC0\xF3\x0F\x5C\xC8\x0F\x54\x0D\xCC\xCC\xCC\xCC\x0F\x2F\x0D\xCC\xCC\xCC\xCC\x77\x15\xBA\x32\x00\x00\x00\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x84\xC0\x74\x04\xB0\x01",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx????xxx????xxxxxxxxxxx????xxxxxx"
        ),

        0xEB, 0x3F
    );
}

Patch "Disable Power Boost Audio" in "Audio" by "Hyper"
{
    // Activation SFX
    WriteNop
    (
        /* 0x1408D2B23 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\xBA\x5F\x23\x00\x00\x48\x8D\x4C\x24\x68",
            "x????xxxxxxxxxx"
        ),

        5
    );

    // Trail SFX
    WriteProtected<byte>
    (
        /* 0x141413C68 */
        ScanSignature
        (
            "sn_powerboost\0",
            "xxxxxxxxxxxxxx"
        ),

        System.Text.Encoding.UTF8.GetBytes("sn_boost_run\0")
    );
}

Patch "Disable Ring Loss" in "Cheats" by "M&M"
{
    WriteProtected<byte>
    (
        /* 0x140799210 */
        ScanSignature
        (
            "\x4C\x8B\x49\x30\x44\x8B\xC2\x41\xF7\xD8\x45\x85\xC0\x7E\x1B\x41\x8B\x41\x24\x41\x2B\x41\x28\x44\x3B\xC0\x44\x0F\x4D\xC0\x45\x03\x41\x28\x41\x8B\xC0\x45\x89\x41\x28\xC3\x41\x8B\x49\x20\x41\x2B\x49\x28\x41\x3B\xC8\x44\x0F\x4D\xC1\x45\x03\x41\x28\x41\x8B\xC0\x45\x89\x41\x28\xC3",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        0xC3
    );
}

Patch "Disable Running Fall" in "Animation" by "Hyper" does "Disables the animation where Sonic continues running when falling off a platform, forcing him into the proper falling animation."
{
    WriteNop
    (
        /* 0x14B556BE2 */
        ScanSignature
        (
            "\xF3\x0F\x10\x40\x30\xF3\x0F\x59\x05\xCC\xCC\xCC\xCC\x0F\x2F\xF0\x0F\x28\x74\x24\x40\x73\x14",
            "xxxxxxxxx????xxxxxxxxxx"
        ),

        5
    );
}

Patch "Disable Sequence Colliders" in "Cheats" by "Hyper" does "Disables invisible walls that are usually removed by specific events. This will not remove invisible walls surrounding the islands."
{
    WriteProtected<byte>
    (
        ScanSignature
        (
            /* v1.01: 0x1496E4D08 */
            "\x0F\x84\x00\x00\x00\x00\x83\xE9\x01\x0F\x84\x00\x00\x00\x00\x83\xF9\x01\x0F\x85\x00\x00\x00\x00\x8A\x0D\x00\x00\x00\x00\x80\xF1\x9F\x88\xCA\x48\x8D\x4D\xE7\xE8\x00\x00\x00\x00\xF3\x0F\x10\x47\x00\x48\x8D\x57\x10\xF3\x0F\x10\x4F\x00\x48\x8D\x4D\xE7\xF3\x0F\x11\x45\x00\xF3\x0F\x11\x4D\x00\xE8\x00\x00\x00\x00\x80\x7F\x38\x00\xB8\x00\x00\x00\x00\xB9\x00\x00\x00\x00\xC7\x45\x00\x00\x00\x00\x00\x66\x0F\x45\xC1\xC6\x45\xE8\x00\x66\x89\x45\xEB\xB8\x00\x00\x00\x00\x66\x09\x45\xED\xE8\x00\x00\x00\x00\x48\x89\xC2\x48\x89\xD9\xE8\x00\x00\x00\x00\x48\x89\xC6\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x48\x8D\x55\xE7\x48\x89\xC1\xE8\x00\x00\x00\x00\xE9\x00\x00\x00\x00",
            "xx????xxxxx????xxxxx????xx????xxxxxxxxxx????xxxx?xxxxxxxx?xxxxxxxx?xxxx?x????xxxxx????x????xx?????xxxxxxxxxxxxx????xxxxx????xxxxxxx????xxxxxxxx????xxxxxxxx????x????",

            /* v1.10: 0x149520288 */
            "\x0F\x84\x00\x00\x00\x00\x83\xE9\x01\x0F\x84\x00\x00\x00\x00\x83\xF9\x01\x0F\x85\x00\x00\x00\x00\xB2\x02\x48\x8D\x4D\xE7\xE8\x00\x00\x00\x00\xF3\x0F\x10\x47\x00\x48\x8D\x57\x10\xF3\x0F\x10\x4F\x00\x48\x8D\x4D\xE7\xF3\x0F\x11\x45\x00\xF3\x0F\x11\x4D\x00\xE8\x00\x00\x00\x00\x80\x7F\x38\x00\xB8\x00\x00\x00\x00\xB9\x00\x00\x00\x00\xC7\x45\x00\x00\x00\x00\x00\x66\x0F\x45\xC1\xC6\x45\xE8\x00\x66\x89\x45\xEB\xB8\x00\x00\x00\x00\x66\x09\x45\xED\xE8\x00\x00\x00\x00\x48\x89\xC2\x48\x89\xD9\xE8\x00\x00\x00\x00\x48\x89\xC6\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x48\x8D\x55\xE7\x48\x89\xC1\xE8\x00\x00\x00\x00\xE9\x00\x00\x00\x00",
            "xx????xxxxx????xxxxx????xxxxxxx????xxxx?xxxxxxxx?xxxxxxxx?xxxx?x????xxxxx????x????xx?????xxxxxxxxxxxxx????xxxxx????xxxxxxx????xxxxxxxx????xxxxxxxx????x????"
        ),

        0xEB, 0x16
    );
}

Patch "Disable Shadow Angle Limit" by "Hyper & GamingLeroy" in "Graphics" does
/*
Disables the limit that prevents long shadows from being drawn against parallel global light.

In simpler terms, shadows will line up correctly with the sun and moon.

This will be particularly noticeable during sunrise and sunset hours.

RFL research by GamingLeroy.
*/
{
    /*
        The game has a strange optimisation that loads the RFL struct
        we're modifying into the FPU as xmmwords, so 16 bytes at a time.

        This hook is a *hack* that checks the last entry in the xmmword
        before it gets written to the xmm0 register, which we then replace
        with zero if equal to 50.0f.

        The value in RAX is different per cycle of this function (it is
        run every frame), so we must check this value first to verify
        we're modifying the right struct before writing to it.

        All islands use a value of 50.0f for "minLightElevationAngle",
        so checking for this is not an issue (other than when people
        change this value for their own use, but it's better not to
        force this change for user values anyway).
    */

    WriteAsmHook
    (
        $@"
            cmp dword ptr [rax + 0x0C], 0x42480000
            jne exit

            mov dword ptr [rax + 0x0C], 0

        exit:
            ; Restore original code.
            movups xmm0, xmmword ptr [rax]
            movups xmm1, xmmword ptr [rax + 0x10]
            lea    rax, [rax + 0x80]
        ",

        /* 0x140B83937 */
        ScanSignature
        (
            "\x0F\x10\x00\x0F\x10\x48\x10\x48\x8D\x80\x80\x00\x00\x00\x0F\x11\x41\x80\x0F\x10\x40\xA0\x0F\x11\x49\x90\x0F\x10\x48\xB0\x0F\x11\x41\xA0\x0F\x10\x40\xC0\x0F\x11\x49\xB0\x0F\x10\x48\xD0\x0F\x11\x41\xC0\x0F\x10\x40\xE0\x0F\x11\x49\xD0\x0F\x10\x48\xF0\x0F\x11\x41\xE0\x0F\x11\x49\xF0\x48\x83\xEA\x01\x75\xAD\x0F\x10\x00\x0F\x10\x48\x10\x0F\x11\x01\x0F\x10\x40\x20\x0F\x11\x49\x10\x0F\x10\x48\x30\x0F\x11\x41\x20\x0F\x10\x40\x40\x0F\x11\x49\x30\x0F\x11\x41\x40",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Disable Shadows" in "Graphics" by "Luig & Hyper"
{
    WriteProtected<byte>
    (
        /* 0x148236DF5 */
        ScanSignature
        (
            "\x0F\xB6\x42\x01\x88\x41\x01\x0F\xB6\x42\x02\x88\x41\x02\x0F\xB6\x42\x03\x88\x41\x03\x0F\xB6\x42\x04\x88\x41\x04\x0F\xB6\x42\x05\x88\x41\x05\x0F\xB6\x42\x06\x88\x41\x06\x8B\x42\x08\x89\x41\x08\x8B\x42\x0C\x89\x41\x0C\x8B\x42\x10\x89\x41\x10\x8B\x42\x14\x89\x41\x14\x8B\x42\x18\x89\x41\x18\x8B\x42\x1C\x89\x41\x1C\x8B\x42\x20\x89\x41\x20\x8B\x42\x24\x89\x41\x24\x8B\x42\x28\x89\x41\x28\x8B\x42\x2C\x89\x41\x2C\x8B\x42\x30\x89\x41\x30\x8B\x42\x34\x89\x41\x34\x8B\x42\x38\x89\x41\x38\x8B\x42\x3C\x89\x41\x3C\x8B\x42\x40\x89\x41\x40\x8B\x42\x44\x89\x41\x44\x8B\x42\x48\x89\x41\x48\x8B\x42\x4C\x89\x41\x4C\x8B\x42\x50\x89\x41\x50\x8B\x42\x54\x89\x41\x54\x8B\x42\x58\x89\x41\x58\x8B\x42\x5C\x89\x41\x5C\x8B\x42\x60\x89\x41\x60\x8B\x42\x64\x89\x41\x64\x8B\x42\x68\x89\x41\x68\x8B\x42\x6C\x89\x41\x6C\x8B\x42\x70\x89\x41\x70",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        0xC6, 0x41, 0x01, 0x00, 0x90, 0x90, 0x90
    );
}

Patch "Disable Skill Camera Events" in "Camera" by "Hyper" does
/*
Disables the camera events for skills.

The "Dramatic Battle Skill Camera" option in the game settings must be enabled for this code to work.

This code behaves the same as the option described above, but keeps the camera events for performing special attacks on titans, as well as the Quick Cyloop camera.

Affected skills;
- Cross Slash
- Cyclone Kick
- Grand Slam
- Homing Shot
- Loop Kick
- Recovery Smash
- Sonic Boom
- Spin Slash
- Stomp Attack
- Wild Rush
*/
{
    WriteProtected<byte>
    (
        /* 0x1408D5986 */
        ScanSignature
        (
            "\x0F\x84\x83\x00\x00\x00\x44\x38\x36",
            "xxxxxxxxx"
        ),

        0xE9, 0x84, 0x00, 0x00, 0x00
    );

    WriteNop
    (
        /* 0x14087F9E9 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x41\xC7\x86\xAC\x00\x00\x00\x03\x00\x00\x00",
            "x????xxxxxxxxxxx"
        ),

        5
    );
}

Patch "Disable Soldier Eggs" in "Enemy" by "Hyper" does "Disables the egg spawners for the Soldier enemy, allowing them to spawn instantly."
{
    WriteNop
    (
        /* 0x1404C542D */
        ScanSignature
        (
            "\x75\x07\x44\x88\xA5\x50\x04\x00\x00",
            "xxxxxxxxx"
        ),

        2
    );
}

Patch "Disable Spin Charge Camera" in "Camera" by "Hyper" does "Disables the zoom camera when charging a Spin Dash."
{
    WriteNop
    (
        /* 0x1408A67DC */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x48\x8B\xC8\x45\x33\xC0\xB2\x24",
            "x????xxxx????xxxxxxxx"
        ),

        5
    );
}

Patch "Disable Spin Slash on Drop Dash" in "Gameplay" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x14BBB68A6 */
        ScanSignature
        (
            "\x74\x79\xBA\x2E\x00\x00\x00",
            "xxxxxxx"
        ),

        0xEB
    );
}

Patch "Disable Starfall Cutscene" in "Gameplay" by "Hyper" does "Disables the cutscene that occurs before Starfall."
{
    /* 0x1403A5330 */
    var addr = ScanSignature
    (
        "\xE8\xCC\xCC\xCC\xCC\x33\xC9\xC6\x84\x24\x10\x01\x00\x00\x02",
        "x????xxxxxxxxxx"
    );

    WriteNop(addr, 5);
    WriteNop(addr + 0x38, 5);
}

Patch "Disable Stomp Flip" in "Gameplay" by "Hyper" does
/*
Disables the flip Sonic does when performing a stomp attack under certain conditions.

Notes;
- This will allow you to stomp and land firmly on guardians and titans.
- This will allow you to stomp bounce to kill enemies with the shockwave without doing a flip.
*/
{
    byte[] asm = Assemble("lea edx, [r8 + 0x39]");

    // Flip for collision types (e.g. Asura body)
    WriteProtected<byte>
    (
        /* 0x1408ADA9E */
        ScanSignature
        (
            "\x41\x8D\x50\x3A\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4D\x17",
            "xxxxx????xxxx"
        ),

        asm
    );

    // Flip for stomp shockwave kill
    {
        /* 0x14B6E56E1 */
        var sig = ScanSignature
        (
            "\x41\x8D\x50\x3A\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4C\x24\x20\xC6\x87\xB8\x00\x00\x00\x01",
            "xxxxx????xxxxxxxxxxxx"
        );

        WriteProtected<byte>(sig, asm);
        WriteNop(sig + 14, 7);
    }
}

Patch "Disable Subsurface Scattering" in "Graphics" by "Hyper"
{
    WriteAsmHook
    (
        $@"
            mov    dword ptr [rbx + 4], 0x461C4000 ; okay well it's not really disabled otherwise we get some messy colour banding, so lets just make the width gigantic so it's practically gone
            movups xmm0, xmmword ptr [rbx]
            lea    rbx, [rbx + 0x80]
            movups xmmword ptr [rax - 0x80], xmm0
        ",

        /* 0x140B84139 */
        ScanSignature
        (
            "\x0F\x10\x03\x48\x8D\x9B\x80\x00\x00\x00\x0F\x11\x40\x80\x0F\x10\x4B\x90\x0F\x11\x48\x90\x0F\x10\x43\xA0\x0F\x11\x40\xA0\x0F\x10\x4B\xB0\x0F\x11\x48\xB0\x0F\x10\x43\xC0\x0F\x11\x40\xC0\x0F\x10\x4B\xD0\x0F\x11\x48\xD0\x0F\x10\x43\xE0\x0F\x11\x40\xE0\x0F\x10\x4B\xF0\x0F\x11\x48\xF0\x48\x83\xE9\x01\x75\xAD\x0F\x10\x03\x48\x8B\xCE",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Disable Time Velocity Multiplier" in "Time" by "Hyper" does "Disables the time rate increasing based on how fast Sonic is moving."
{
    WriteNop
    (
        /* 0x1401D4B64 */
        ScanSignature
        (
            "\xF3\x0F\x10\x78\x04\xF3\x0F\x59\x75\x04",
            "xxxxxxxxxx"
        ),

        5
    );
}

Patch "Disable Telemetry" in "System" by "M&M & Still" does
/*
Prevents the game from sending telemetry and crash data to SEGA.

This data can include, but is not limited to;
- motherboard information
- HWID
- OS product version
- Steam user ID
- CPU name
- RAM
- game open time
- game close time
*/
{
    /* 0x14007A440 [SGAAS: Open] */
    long sgaasOpen = ScanSignature
    (
        "\x40\x55\x53\x56\x57\x48\x8D\xAC\x24\x00\x00\x00\x00\x48\x81\xEC\x00\x00\x00\x00\x48\x8B\xD9\xC6\x05\x00\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\x49\x8B\xF0\x48\x8B\xFA\xFF\x15\x00\x00\x00\x00\xB9\x00\x00\x00\x00\x48\x89\x1D\x00\x00\x00\x00\x48\x89\x3D\x00\x00\x00\x00\x48\x89\x35\x00\x00\x00\x00",
        "xxxxxxxxx????xxx????xxxxx?????xxx????xxxxxxxx????x????xxx????xxx????xxx????"
    );

    if (sgaasOpen != 0) // To prevent conflict with Quick Boot.
        WriteProtected<byte>(sgaasOpen, 0xC3);

    /* 0x140079F20 [SGAAS: Heartbeat] */
    WriteProtected<byte>
    (
        ScanSignature
        (
            "\x48\x89\x5C\x24\x00\x48\x89\x7C\x24\x00\x55\x48\x8D\xAC\x24\x00\x00\x00\x00\x48\x81\xEC\x00\x00\x00\x00\x66\x0F\x6F\x05\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x66\x0F\x6F\xC8\x66\x0F\x7F\x45\x00\x41\xB8\x00\x00\x00\x00\xC6\x44\x24\x00\x00",
            "xxxx?xxxx?xxxxx????xxx????xxxx????xxx????xxxxxxxx?xx????xxx??"
        ),

        0xC3
    );

    /* 0x14007B7E0 [SGAAS: Close] */
    WriteProtected<byte>
    (
        ScanSignature
        (
            "\x48\x8B\xC4\x55\x48\x8D\xA8\x00\x00\x00\x00\x48\x81\xEC\x00\x00\x00\x00\x80\x3D\x00\x00\x00\x00\x00\x0F\x84\x00\x00\x00\x00\x66\x0F\x6F\x05\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x48\x89\x58\x10\x48\x8D\x4C\x24\x00\x66\x0F\x6F\xC8\x48\x89\x78\x18\x41\xB8\x00\x00\x00\x00",
            "xxxxxxx????xxx????xx?????xx????xxxx????xxx????xxxxxxxx?xxxxxxxxxx????"
        ),

        0xC3
    );

    /* 0x14007DFC0 [Crashpad: Folder] */
    WriteProtected<byte>
    (
        ScanSignature
        (
            "\x40\x53\x48\x81\xEC\x00\x00\x00\x00\x48\x8B\xD9\xE8\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8D\x4C\x24\x00\xC7\x44\x24\x00\x00\x00\x00\x00\x48\x89\x4C\x24\x00\x48\x8D\x54\x24\x00",
            "xxxxx????xxxx????xxxx????xxxx?xxx?????xxxx?xxxx?"
        ),

        0xC3
    );

    /* 0x14007EA30 [Crashpad: Data] */
    WriteProtected<byte>
    (
        ScanSignature
        (
            "\x40\x55\x53\x56\x57\x41\x55\x48\x8D\xAC\x24\x00\x00\x00\x00\xB8\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x2B\xE0\x45\x33\xED\x4C\x89\xA4\x24\x00\x00\x00\x00\x4C\x89\x6D\xA0\x41\x8D\x4D\x60\xE8\x00\x00\x00\x00\x66\x0F\x6F\x05\x00\x00\x00\x00\x48\x89\x00",
            "xxxxxxxxxxx????x????x????xxxxxxxxxx????xxxxxxxxx????xxxx????xxx"
        ),

        0xC3
    );
}

Patch "Disable Traversal Objects in Chests" in "Gameplay" by "Hyper" does
/*
Disables the hidden traversal objects in chests that require cyloop to reveal, making them always accessible.

Affected objects;
- Dash Panels
- Jump Boards
- Springs
*/
{
    // Dash Panels
    WriteAsmHook
    (
        $@"
            mov byte ptr [rsi + 0xB8], 0
            movaps xmm2, xmm3
            mulps  xmm2, xmm3
            movaps xmm1, xmm2
            shufps xmm1, xmm2, 0x99
            addss  xmm2, xmm1
        ",

        /* 0x14037D693 */
        ScanSignature
        (
            "\x0F\x28\xD3\x0F\x59\xD3\x0F\x28\xCA\x0F\xC6\xCA\x99\xF3\x0F\x58\xD1\x0F\x28\xC1\x0F\xC6\xC1\x55\xF3\x0F\x58\xD0\x0F\x57\xC0\x0F\xC6\xD2\x00\x0F\x51\xCA\x0F\xC2\x15\xCC\xCC\xCC\xCC\xCC\x0F\x5E\xD9\x0F\xC2\xC8\x04\x0F\x54\xD9\xF3\x0F\x10\x0D\xCC\xCC\xCC\xCC\x0F\x54\xDA\x0F\x55\x15\xCC\xCC\xCC\xCC\x0F\x56\xDA\x0F\x29\x9D\x90\x00\x00\x00",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx?????xxxxxxxxxxxxxx????xxxxxx????xxxxxxxxxx"
        ),

        HookBehavior.Replace
    );

    // Jump Boards
    {
        /* 0x1403C8D03 */
        long instrAddr = ScanSignature
        (
            "\x80\xB8\xB8\x00\x00\x00\x00\x74\x12",
            "xxxxxxxxx"
        );

        WriteProtected<byte>(instrAddr, Assemble("mov byte ptr [rax + 0xB8], 0"));

        /* 0x1403C8D0A */
        WriteProtected<byte>(instrAddr + 0x07, 0xEB);
    }

    // Springs
    WriteProtected<byte>
    (
        /* 0x140434C08 */
        ScanSignature
        (
            "\x0F\x44\xD0\x88\x93\x00\x03\x00\x00\x0F\xB6\xC2\x24\xF7",
            "xxxxxxxxxxxxxx"
        ),

        Assemble("mov dl, 1; nop")
    );
}

Patch "Disable Water Audio Filter" in "Audio" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x1408B5626 */
        ScanSignature
        (
            "\x74\x65\x84\xC9\x0F\x85\x31\x01\x00\x00",
            "xxxxxxxxxx"
        ),

        0xEB
    );
}

Patch "Disable Tutorial Messages" in "Gameplay" by "Hyper" does "Disables all intrusive tutorial messages that appear under certain conditions for the first time."
{
    // Hide hint rings.
    WriteProtected<byte>
    (
        /* 0x14910B23F */
        ScanSignature
        (
            "\x48\x89\xCF\xB2\x01\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\xB2\x01\x48\x89\x47\x38\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x48\x89\x47\x40",
            "xxxxxxxx????x????xxxxxxxxx????x????xxxx"
        ),

        0xEB, 0x63
    );

    WriteAsmHook
    (
        @"
            ; Restore original code.
            mov qword ptr [rsp + 0x08], rbx
            mov qword ptr [rsp + 0x10], rbp
            mov qword ptr [rsp + 0x18], rsi

            push rax

            ; Checks the overlay type, expected 1.
            mov eax, dword ptr [rdx + 0x18]
            cmp eax, 1
            jne ret

            ; Checks if the string field is null.
            mov rax, qword ptr [rdx + 0x48]
            cmp rax, 0
            jz  end

            ; Checks the first two characters of the input string.
            mov ax, word ptr [rax]
            cmp ax, 0x7574 ; tu (endian-swapped)
            jne ret

            ; Exclusions, in the event that a softlock occurs.
            mov rax, qword ptr [rdx + 0x48]
            mov eax, dword ptr [rax + 0x07]
            cmp eax, 0x303032 ; tu1000_200
            je  ret
            cmp eax, 0x303335 ; tu1000_530
            je  ret
            cmp eax, 0x303735 ; tu1000_570
            je  ret
            cmp eax, 0x303935 ; tu1000_590
            je  ret

            ; Exclude DLC messages.
            mov rax, qword ptr [rdx + 0x48]
            mov eax, dword ptr [rax + 0x06]
            cmp eax, 0x5F636C64 ; dlc_
            je ret

        end:
            pop rax
            ret

        ret:
            pop rax
        ",

        /* v1.10: 0x14093AFB0 */
        /* v1.20: 0x14096E8A0 */
        ScanSignature
        (
            "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x41\x56\x41\x57\x48\x83\xEC\x20\x4C\x8B\xF1\x48\x8B\xEA",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Disable Umbrella Camera Lock-On" in "Camera" by "Hyper" does "Disables the lock-on camera when the Umbrella enemy in Ares jumps into the sky."
{
    WriteProtected<byte>
    (
        /* 0x1404EC078 */
        ScanSignature
        (
            "\x75\x08\x48\x8B\xCE\xE8\x00\x00\x00\x00\x45\x33\xC0\x48\x8B\xCE\x41\x8D\x50\x01\xE8\x00\x00\x00\x00\x41\xB0\x01\x33\xD2\x48\x8B\xCE\x48\x8B\x5C\x24\x00\x48\x8B\x74\x24\x00\x48\x83\xC4\x20\x5F\xE9\x00\x00\x00\x00",
            "xxxxxx????xxxxxxxxxxx????xxxxxxxxxxxx?xxxx?xxxxxx????"
        ),

        0xEB
    );

    WriteNop
    (
        /* 0x1404ED414 */
        ScanSignature
        (
            "\xE8\x00\x00\x00\x00\x48\x8B\xCF\xE8\x00\x00\x00\x00\xBA\x00\x00\x00\x00\x48\x8B\xCF\xE8\x00\x00\x00\x00\xC6\x46\x50\x01\x80\x7E\x50\x00\x74\x2E\x0F\x28\xD6\x33\xD2\x48\x8B\xCF\xE8\x00\x00\x00\x00\x84\xC0\x74\x1D\x48\x8B\xCF\xE8\x00\x00\x00\x00\xBA\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\xCF\xE8\x00\x00\x00\x00\x48\x8B\x5C\x24\x00\x32\xC0\x48\x8B\x6C\x24\x00\x48\x8B\x74\x24\x00\x0F\x28\x74\x24\x00\x48\x83\xC4\x30\x5F\xC3",
            "x????xxxx????x????xxxx????xxxxxxxxxxxxxxxxxxx????xxxxxxxx????x????xxxx????xxxx????xxxx?xxxxxx?xxxx?xxxx?xxxxxx"
        ),

        5
    );
}

Patch "Disable Vignette" in "Graphics" by "Hyper"
{
    WriteNop
    (
        /* 0x140B42934 */
        ScanSignature
        (
            "\x0F\x29\x43\x10\x41\x0F\x28\x4C\x24\x00\x0F\x29\x4B\x20\x41\x0F\x28\x44\x24\x00\x0F\x29\x43\x30\x41\x0F\x28\x4C\x24\x00\x0F\x29\x4B\x40\x41\x0F\x28\x44\x24\x00\x0F\x29\x43\x50\x41\x0F\x28\x4C\x24\x00\x0F\x29\x4B\x60\x41\x0F\x28\x44\x24\x00\x0F\x29\x43\x70\x41\x0F\x28\x4C\x24\x00\x0F\x29\x8B\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x84\xC0\x0F\x85\x00\x00\x00\x00\xB9\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xD8\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x0F\x28\x05\x00\x00\x00\x00\x49\x8B\xCD\x0F\x28\x0D\x00\x00\x00\x00",
            "xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxxxxxxxx?xxx????x????xxxx????x????x????xxxxxxxx????xxx????xxxxxx????"
        ),

        4
    );
}

Patch "Disable Wolf (experimental)" in "Enemy" by "Hyper" does
/*
Disables the Wolf enemy on Ouranos Island.

Known issues;
- This also affects Battle Rush and causes a softlock.
*/
{
    WriteNop
    (
        /* 0x140540E0E */
        ScanSignature
        (
            "\x75\x28\x45\x33\xC0\x33\xD2\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x45\x33\xC0\x48\x8B\xCF\x41\x8D\x50\x01\x48\x81\xC4\x88\x01\x00\x00",
            "xxxxxxxxxxx????xxxxxxxxxxxxxxxxx"
        ),

        2
    );
}

Patch "Drop Dash on Double Jump" in "Gameplay" by "Hyper" does "Allows you to drop dash immediately after double jumping, making it require only two presses."
{
    /* 0x14B52AB4D */
    var sig = ScanSignature
    (
        "\x74\x45\x48\x89\xF9\xE8",
        "xxxxxx"
    );

    WriteNop(sig, 2);
    WriteProtected<byte>(sig + 0x0F, 0xEB);
}

Code "Fix Air Boost Reset" in "Fixes" by "Hyper" does "Allows Sonic to perform another Air Boost after previously using it before performing a homing attack, stomp, or using a spring."
//
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "Sonic"

    static Sonic.StateID[] AirBoostStates =
    {
        Sonic.StateID.StateStompingFlip,
        Sonic.StateID.StateStompingBounce,
        Sonic.StateID.StateHomingFinished,
        Sonic.StateID.StateSpringJump
    }

    static bool IsRestoredAirBoost = false;
//
{
    void NotifyAirBoostReset(Sonic.StateID stateId, Sonic.StateID[] stateStackTrace)
    {
        // Reset flag for StateAirBoost or StateSpinBoost.
        if (stateId == Sonic.StateID.StateAirBoost || stateId == Sonic.StateID.StateSpinBoost)
        {
            IsRestoredAirBoost = false;
            return;
        }

        foreach (var restoreState in AirBoostStates)
        {
            if (restoreState == stateId)
                IsRestoredAirBoost = true;
        }
    }

    Sonic.State.AddStateNotifyAction(NotifyAirBoostReset);

    if (BlackboardStatus.Get() != 0)
    {
        // Disable restored air boost for Super Sonic.
        if (BlackboardStatus.IsSuper())
            IsRestoredAirBoost = false;

        // Disable restored air boost for diving.
        if (Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsDiving))
            IsRestoredAirBoost = false;
    }

    if (Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerBoost) && !Sonic.IsGroundedSpecial() && IsRestoredAirBoost)
    {
        // Exit into StateAirBoost.
        Sonic.State.SetState(Sonic.StateID.StateAirBoost);
    }
}

Patch "Fix Damage from Jumping into Enemies" in "Fixes" by "Hyper" does "Fixes Sonic taking damage when jumping into enemies within a small frame window."
//
    #lib "Sonic"

    static bool IsJumpPrevious = false;
//
{
    void NotifyJumpDamageCollision(Sonic.StateID stateId, Sonic.StateID[] stateStackTrace)
    {
        bool isJump = stateId == Sonic.StateID.StateJump ||
            stateId == Sonic.StateID.StateDoubleJump ||
            stateId == Sonic.StateID.StateGrindDoubleJump;

        if (isJump)
        {
            Sonic.Collision.SetCollisionSphere(Sonic.CollisionType.Damage, 1.0f);
            Sonic.Collision.ToggleEntityCollision(false);
            IsJumpPrevious = true;
        }
        else if (IsJumpPrevious)
        {
            Sonic.Collision.SetCollisionSphere(Sonic.CollisionType.Default, 1.0f);
            Sonic.Collision.ToggleEntityCollision(true);
            IsJumpPrevious = false;
        }
    }

    Sonic.State.AddStateNotifyAction(NotifyJumpDamageCollision);
}

Patch "Fix Quick Cyloop Lock-On" in "Fixes" by "WasifBoomz & The Duck Dealer" does "Fixes the lock-on target changing whenever Sonic performs a Quick Cyloop, allowing for consistent attacks during combat."
{
    WriteProtected<byte>
    (
        /* 0x14088D334 */
        ScanSignature
        (
            "\x76\x12\x8B\x46\x28\x48\x8D\x55\x97\x48\x8B\xCB\x89\x45\x97\xE8\xCC\xCC\xCC\xCC\x48\x8B\x47\x38",
            "xxxxxxxxxxxxxxxx????xxxx"
        ),

        0xEB
    );
}

Patch "Fix Rail Switching Animation" in "Fixes" by "WasifBoomz & Sails" does "Stops the rail switching animation from ending abruptly."
{
    WriteAsmHook
    (
        $@"
            ; Check if (unknown float) is equal to 40
            cmp   dword ptr [r15+14h], 0x42200000
            jz    setSpeed
            jmp   originalCode
			
        setSpeed:
            mov   dword ptr [r15+18h], 0x3F266666
			
        originalCode:
            movss xmm1, dword ptr [r15+18h]
            subss xmm0, dword ptr [rbx+r12*8]
            andps xmm1, xmm9
        ",
			
        /* 0x140DA61A5 */
        ScanSignature
        (
            "\xF3\x41\x0F\x10\x4F\x18\xF3\x42\x0F\x5C\x04\xE3",
            "xxxxxxxxxxxx"
        ),
			
        HookBehavior.Replace
    );
}

Patch "Fix Empty Messages" in "Fixes" by "Hyper" does "Removes the empty messages that occur when the game is in an unsafe state."
{
    WriteAsmHook
    (
        @"
            push rax

            ; Checks the overlay type, expected 1.
            mov eax, dword ptr [rdx + 0x18]
            cmp eax, 1
            jne ret

            ; Checks if the string field is null.
            mov rax, qword ptr [rdx + 0x48]
            cmp rax, 0
            jnz ret

            ; Immediately return if the string field is null.
            pop rax
            ret

        ret:
            pop rax

            ; Restore original code.
            push rdi
            push r14
            push r15
            sub  rsp, 0x20
            mov  r14, rcx
            mov  rbp, rdx
        ",

        /* 0x14093AFBF */
        ScanSignature
        (
            "\x57\x41\x56\x41\x57\x48\x83\xEC\x20\x4C\x8B\xF1\x48\x8B\xEA",
            "xxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Fix Grind Leaning" in "Fixes" by "Hyper" does "Fixes the grind leaning animations always leaning left and ending prematurely when leaning right."
//
    static float Bias = 1.0f;
//
{
    fixed (float* pBias = &Bias)
    {
        WriteAsmHook
        (
            $@"
                mov   rdx, {(long)pBias}
                movss xmm2, dword ptr [rdx]
                movss dword ptr [rsi + 0xD8], xmm0
                mov   rdx, {(long)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi("SPEED_RATIO")}
            ",

            /* 0x14084AD71 */
            ScanSignature
            (
                "\x0F\x28\xD0\xF3\x0F\x11\x86\xD8\x00\x00\x00",
                "xxxxxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}

Patch "Fix Photo Mode Camera Collision" in "Fixes" by "Hyper" does "Allows the camera in Photo Mode to slide against collision, rather than freezing in place."
{
    WriteNop
    (
        /* 0x1400A6D0F */
        ScanSignature
        (
            "\x73\x3B\x0F\x28\x64\x24\x40",
            "xxxxxxx"
        ),

        2
    );
}

Patch "Fix RenderDoc Captures (v1.30)" in "Fixes" by "Skyth" does "Fixes RenderDoc being unable to hook to the game for capturing the graphics device."
{
    WriteProtected<long>(0x141123B40, Read<long>(0x156300168));
    WriteProtected<long>(0x141123B50, Read<long>(0x156300188));
}

Patch "Fix Resolution Resetting on Launch" in "Fixes" by "Hyper" does "Fixes a bug that causes the internal resolution to reset to 1280x720 if the game is unfocused during boot."
//
    #load "System.Xml.dll"

    using System.IO;
    using System.Xml.Serialization;

    [XmlRoot(ElementName = "ScreenSetting")]
    public class ScreenSetting
    {
        [XmlAttribute(AttributeName = "left")]
        public int Left { get; set; }

        [XmlAttribute(AttributeName = "top")]
        public int Top { get; set; }

        [XmlAttribute(AttributeName = "width")]
        public int Width { get; set; }

        [XmlAttribute(AttributeName = "height")]
        public int Height { get; set; }

        [XmlAttribute(AttributeName = "resolutionWidth")]
        public int ResolutionWidth { get; set; }

        [XmlAttribute(AttributeName = "resolutionHeight")]
        public int ResolutionHeight { get; set; }

        [XmlAttribute(AttributeName = "fullscreenStyle")]
        public int FullscreenStyle { get; set; }

        [XmlAttribute(AttributeName = "fullscreenState")]
        public int FullscreenState { get; set; }
    }
//
{
    string xml = Path.Combine
    (
        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
        @"SEGA\SonicFrontiers\steam\x64\screen_setting.xml"
    );

    if (!File.Exists(xml))
    {
        Console.WriteLine($"[Fix Resolution Resetting on Launch] Code halted, file not found: {xml}");
        return;
    }

    try
    {
        using (StringReader reader = new StringReader(File.ReadAllText(xml)))
        {
            var screenSetting = (ScreenSetting)new XmlSerializer(typeof(ScreenSetting)).Deserialize(reader);

            if (screenSetting.ResolutionWidth <= 0 || screenSetting.ResolutionHeight <= 0)
            {
                Console.WriteLine("[Fix Resolution Resetting on Launch] Invalid screen parameters! Defaulting to 1280x720...");

                screenSetting.ResolutionWidth  = 1280;
                screenSetting.ResolutionHeight = 720;
            }

            // Force resolutionWidth from XML as default value.
            WriteProtected<byte>
            (
                /* 0x140BB66B4 */
                ScanSignature
                (
                    "\xC7\x81\x00\x00\x00\x00\x00\x00\x00\x00\x48\x8B\x4B\x20\x41\xB7\x01\x83\xB9\x00\x00\x00\x00\x00\x75\x41\x41\xB8\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\x4B\x20\x89\x81\x00\x00\x00\x00\x48\x8B\x4B\x20\x83\xB9\x00\x00\x00\x00\x00\x75\x0E\xC7\x81\x00\x00\x00\x00\x00\x00\x00\x00\x48\x8B\x4B\x20\x41\xB7\x01",
                    "xx????????xxxxxxxxx?????xxxx????xxx????xxx????x????xxxxxx????xxxxxx?????xxxx????????xxxxxxx"
                ),

                Assemble($"mov dword ptr [rcx + 0xF0], 0x{screenSetting.ResolutionWidth:X}")
            );

            // Force resolutionHeight from XML as default value.
            WriteProtected<byte>
            (
                /* 0x140BB66FE */
                ScanSignature
                (
                    "\xC7\x81\x00\x00\x00\x00\x00\x00\x00\x00\x48\x8B\x4B\x20\x41\xB7\x01\x41\x0F\xB6\xC7\x34\x01\x88\x81\x00\x00\x00\x00\x48\x8B\x4B\x20\x83\xB9\x00\x00\x00\x00\x00\x75\x40\x41\xB8\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\x4B\x20\x89\x81\x00\x00\x00\x00\x48\x8B\x4B\x20\x83\xB9\x00\x00\x00\x00\x00\x75\x10\x8B\x81\x00\x00\x00\x00\x89\x81\x00\x00\x00\x00\x48\x8B\x4B\x20",
                    "xx????????xxxxxxxxxxxxxxx????xxxxxx?????xxxx????xxx????xxx????x????xxxxxx????xxxxxx?????xxxx????xx????xxxx"
                ),

                Assemble($"mov dword ptr [rcx + 0xF4], 0x{screenSetting.ResolutionHeight:X}")
            );
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[Fix Resolution Resetting on Launch] {ex}");
        return;
    }

    // Kill XML value reading for resolutionWidth and resolutionHeight.
    WriteProtected<byte>
    (
        /* 0x150A0F5C2 */
        ScanSignature
        (
            "\x74\x1B\x48\x85\xC0\x74\x16\x48\x89\xE9\xE8\x00\x00\x00\x00\x48\x89\xF1\x89\x43\x10\xE8\x00\x00\x00\x00\x89\x43\x14\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x48\x8B\xB4\x24\x00\x00\x00\x00\x48\x8B\xAC\x24\x00\x00\x00\x00\x48\x85\xC0\x74\x0B\x48\x89\xC1\xE8\x00\x00\x00\x00\x89\x43\x20\x45\x31\xC0\x48\x8D\x15\x00\x00\x00\x00\x48\x89\xF9\xE8\x00\x00\x00\x00\x48\x85\xC0\x74\x0B\x48\x89\xC1\xE8\x00\x00\x00\x00\x89\x43\x24\x48\x8D\x4C\x24\x00\xB3\x01\xE8\x00\x00\x00\x00\x0F\xB6\xC3\x48\x81\xC4\x00\x00\x00\x00\x5F\x5B\xC3",
            "xxxxxxxxxxx????xxxxxxx????xxxxxxxxx????xxxx????xxxx????xxxx????xxxxxxxxx????xxxxxxxxx????xxxx????xxxxxxxxx????xxxxxxx?xxx????xxxxxx????xxx"
        ),

        0xEB
    );

    // Always pass resolutionWidth -1 check so we can force new value.
    WriteProtected<byte>
    (
        /* 0x140BB6682 */
        ScanSignature
        (
            "\x75\x41\x41\xB8\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\x4B\x20\x89\x81\x00\x00\x00\x00\x48\x8B\x4B\x20\x83\xB9\x00\x00\x00\x00\x00\x75\x0E\xC7\x81\x00\x00\x00\x00\x00\x00\x00\x00\x48\x8B\x4B\x20\x41\xB7\x01\x83\xB9\x00\x00\x00\x00\x00\x75\x41\x41\xB8\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\x4B\x20\x89\x81\x00\x00\x00\x00\x48\x8B\x4B\x20\x83\xB9\x00\x00\x00\x00\x00\x75\x0E\xC7\x81\x00\x00\x00\x00\x00\x00\x00\x00\x48\x8B\x4B\x20\x41\xB7\x01",
            "xxxx????xxx????xxx????x????xxxxxx????xxxxxx?????xxxx????????xxxxxxxxx?????xxxx????xxx????xxx????x????xxxxxx????xxxxxx?????xxxx????????xxxxxxx"
        ),

        0xEB, 0x30
    );

    // Always pass resolutionHeight -1 check so we can force new value.
    WriteProtected<byte>
    (
        /* 0x140BB66CC */
        ScanSignature
        (
            "\x75\x41\x41\xB8\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\x4B\x20\x89\x81\x00\x00\x00\x00\x48\x8B\x4B\x20\x83\xB9\x00\x00\x00\x00\x00\x75\x0E\xC7\x81\x00\x00\x00\x00\x00\x00\x00\x00\x48\x8B\x4B\x20\x41\xB7\x01\x41\x0F\xB6\xC7\x34\x01\x88\x81\x00\x00\x00\x00\x48\x8B\x4B\x20\x83\xB9\x00\x00\x00\x00\x00\x75\x40\x41\xB8\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\x4B\x20\x89\x81\x00\x00\x00\x00\x48\x8B\x4B\x20\x83\xB9\x00\x00\x00\x00\x00\x75\x10\x8B\x81\x00\x00\x00\x00\x89\x81\x00\x00\x00\x00\x48\x8B\x4B\x20",
            "xxxx????xxx????xxx????x????xxxxxx????xxxxxx?????xxxx????????xxxxxxxxxxxxxxx????xxxxxx?????xxxx????xxx????xxx????x????xxxxxx????xxxxxx?????xxxx????xx????xxxx"
        ),

        0xEB, 0x30
    );
}

Patch "Fix Shadow Stutter" in "Fixes" by "Hyper" does "Fixes shadows not interpolating smoothly when time passes."
{
    WriteProtected<byte>
    (
        /* 0x1480F8D71 */
        ScanSignature
        (
            "\x0F\xB6\x42\x74\x88\x41\x74\x8B\x42\x78",
            "xxxxxxxxxx"
        ),

        Assemble("mov byte ptr [rcx + 0x74], 0; nop; nop; nop")
    );
}

Code "Fix Stomp Reset" in "Fixes" by "Hyper" does "Fixes the stomp attack only resetting once you hit the ground, allowing you to perform multiple stomps whilst still airborne."
//
    #lib "Sonic"

    static bool IsInitialised = false;
//
{
    if (!IsInitialised)
    {
        WriteNop
        (
            /* 0x1408FF6C0 */
            ScanSignature
            (
                "\x74\x1C\x45\x33\xC0\x48\x8B\xCB\x41\x8D\x50\x36",
                "xxxxxxxxxxxx"
            ),

            2
        );

        IsInitialised = true;
    }
    
    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateBounceJump)
    {
        if (Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerStomping))
            Sonic.State.SetState(Sonic.StateID.StateStompingDown);
    }
}

Patch "Fix Upreel Grip Position" in "Fixes" by "ĐeäTh" does
/*
Adjusts Sonic's grip position on the Upreel object's handle so that it lines up with the actual object.
*/
{
    IntPtr gripOffsetPtr = System.Runtime.InteropServices.Marshal.AllocHGlobal(16);
    *((float*)gripOffsetPtr + 0) = 0.0f;
    *((float*)gripOffsetPtr + 1) = -1.025f;
    *((float*)gripOffsetPtr + 2) = 0.0f;
    *((float*)gripOffsetPtr + 3) = 0.0f;

    WriteAsmHook
    (
        $@"
            mov rax, {(long)gripOffsetPtr}
            movups xmm15, [rax]
            mulps xmm0, xmm15
            lea rdx, [rsp + 0x60]
            lea rcx, [rsp + 0x30]
        ",

        /* v1.10: 0x1498C86A7 */
        /* v1.30: 0x14983C900 */
        ScanSignature
        (
            "\x0F\x59\x05\xCC\xCC\xCC\xCC\x48\x8D\x54\x24\x60\x48\x8D\x4C\x24\x30",
            "xxx????xxxxxxxxxx"
        ),

        HookBehavior.Replace
    );

    WriteAsmHook
    (
        $@"
            mov rax, {(long)gripOffsetPtr}
            movups xmm15, [rax]
            mulps xmm0, xmm15
            lea rdx, [rbp - 0x10]
            lea rcx, [rbp - 0x30]
        ",

        /* v1.20: 0x1403973ED */
        /* v1.30: 0x1403C7A3C */
        ScanSignature
        (
            "\x0F\x59\x05\xCC\xCC\xCC\xCC\x48\x8D\x55\xF0\x48\x8D\x4D\xD0",
            "xxx????xxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Flail Falling" in "Animation" by "Hyper" does "Replaces the spinning animation when flinging off terrain with a flailing animation."
{
    WriteProtected<byte>
    (
        ScanSignature
        (
            "BUMP_JUMP_START",
            "xxxxxxxxxxxxxxx"
        ),

        System.Text.Encoding.UTF8.GetBytes("BUMP_JUMP\0")
    );
}

Patch "Force 4K Video Playback" in "Graphics" by "Hyper" does "Forces the game to use the pre-rendered cutscenes encoded at 4K, regardless of game resolution."
{
    WriteNop
    (
        /* v1.20: 0x14012405B */
        ScanSignature
        (
            "\x0F\x85\x00\x00\x00\x00\x48\x85\xC9\x74\x05\xE8\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x45\x33\xC9\x48\x89\x44\x24\x00\x48\x8D\x55\x37\x48\xC7\x44\x24\x00\x00\x00\x00\x00\x48\x8D\x4D\x17\x45\x8D\x41\x20\xE8\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x4C\x89\x7D\x17\x48\x8D\x4D\x17\xE8\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x48\x8D\x4D\x17\xE8\x00\x00\x00\x00\x48\x8D\x77\x70\x4C\x8B\xC6\x48\x8D\x15\x00\x00\x00\x00\x48\x8D\x4D\x17\xE8\x00\x00\x00\x00\x48\x8B\x0D\x00\x00\x00\x00\x48\x8D\x55\x17\x48\x8B\x01\xFF\x90\x00\x00\x00\x00\x48\x8D\x4D\x17\x0F\xB6\xD8\xE8\x00\x00\x00\x00\x84\xDB\x74\x1A\x81\x8F\x00\x00\x00\x00\x00\x00\x00\x00\xEB\x0E",
            "xx????xxxxxx????x????xxxxxxx?xxxxxxxx?????xxxxxxxxx????xxx????xxxxxxxxx????xxx????xxxxx????xxxxxxxxxx????xxxxx????xxx????xxxxxxxxx????xxxxxxxx????xxxxxx????????xx"
        ),

        6
    );

    WriteProtected<byte>
    (
        /* v1.20: 0x140967E09 */
        ScanSignature
        (
            "\x48\x0F\x45\xD9\xE8\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8D\x4D\xD8\xC7\x45\x00\x00\x00\x00\x00\x48\x89\x4D\xC0\x48\x8D\x15\x00\x00\x00\x00\x45\x33\xF6\x48\x89\x45\xD0\x48\x8D\x4D\xC0\x44\x89\x75\xC8\x4C\x8B\xC3\xE8\x00\x00\x00\x00\xF3\x0F\x10\x0D\x00\x00\x00\x00\x4C\x8D\x05\x00\x00\x00\x00\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\x48\xC7\x44\x24\x00\x00\x00\x00\x00\x48\x89\x44\x24\x00\x4C\x8D\x4C\x24\x00\x89\x44\x24\x78\x48\x8D\x95\x00\x00\x00\x00\xB8\x00\x00\x00\x00\x44\x89\x74\x24\x00\x66\x89\x45\x98\x0F\x57\xC0\xB8\x00\x00\x00\x00\xC6\x44\x24\x00\x00\x66\x44\x23\xF0\xF3\x0F\x11\x4D\x00\x48\x8B\x47\x08\x66\x41\x83\xCE\x00\x83\x7D\xC8\x00\x49\x8B\xCF\x66\x0F\x7F\x45\x00\x4C\x0F\x45\x45\x00\xC7\x45\x00\x00\x00\x00\x00\x48\xC7\x45\x00\x00\x00\x00\x00\xC7\x45\x00\x00\x00\x00\x00\xC7\x45\x00\x00\x00\x00\x00\x66\x44\x89\x75\x00\x48\x89\x44\x24\x00\xE8\x00\x00\x00\x00\x48\x8D\x8F\x00\x00\x00\x00\x48\x8B\xD0\xE8\x00\x00\x00\x00",
            "xxxxx????xxxx????xxxxxx?????xxxxxxx????xxxxxxxxxxxxxxxxxxx????xxxx????xxx????xx????????xxxx?????xxxx?xxxx?xxxxxxx????x????xxxx?xxxxxxxx????xxx??xxxxxxxx?xxxxxxxx?xxxxxxxxxxx?xxxx?xx?????xxx?????xx?????xx?????xxxx?xxxx?x????xxx????xxxx????"
        ),

        0x48, 0x89, 0xCB, 0x90
    );
}

Code "Force Cyber Space Objects on Islands" in "Graphics" by "Hyper" does
/*
Replaces all supported objects on the islands with their Cyber Space counterparts.

Unsupported objects;
- Jump Selectors (Generations-style)
*/
//
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "GameMode"
    #lib "Resources"

    using System.Collections.Generic;

    private static List<string> _objects = new()
    {   
        "cmnisl_obj_balloonB",                   "cmnisl_obj_balloonG",                   "cmnisl_obj_balloonR",                "cmnisl_obj_balloonY",                   "cmnisl_obj_dashpanel",
        "cmnisl_obj_dashpanel_arrow",            "cmnisl_obj_dashpanel_belt",             "cmnisl_obj_dashring",                "cmnisl_obj_dashring_body",              "cmnisl_obj_dashroller",
        "cmnisl_obj_dashroller_GR",              "cmnisl_obj_dashroller_SV",              "cmnisl_obj_fan_fly",                 "cmnisl_obj_fan_ground",                 "cmnisl_obj_fan_top",
        "cmnisl_obj_grindbooster",               "cmnisl_obj_grindbooster_arrow",         "cmnisl_obj_grindbooster_arrow_stop", "cmnisl_obj_grindbooster_light_stop",    "cmnisl_obj_jumppanel_arrow",
        "cmnisl_obj_jumppanel_belt",             "cmnisl_obj_jumppanel30L",               "cmnisl_obj_jumppanel30M",            "cmnisl_obj_jumppanel30S",               "cmnisl_obj_jumpselector",
        "cmnisl_obj_jumpselector@correct",       "cmnisl_obj_jumpselector@miss",          "cmnisl_obj_jumpselector_arrow",      "cmnisl_obj_jumpselector_gauge_correct", "cmnisl_obj_jumpselector_gauge_in",
        "cmnisl_obj_jumpselector_gauge_miss",    "cmnisl_obj_laserfence",                 "cmnisl_obj_pole_fvA",                "cmnisl_obj_pole_fvB",                   "cmnisl_obj_pole_guide",
        "cmnisl_obj_pole_guide_meter",           "cmnisl_obj_pole_guide_meterB",          "cmnisl_obj_pole_svA",                "cmnisl_obj_pole_svB",                   "cmnisl_obj_pole_svC",
        "cmnisl_obj_pole_svD",                   "cmnisl_obj_propellerspring_body_limit", "cmnisl_obj_propellerspring_bottom",  "cmnisl_obj_propellerspring_top",        "cmnisl_obj_pulley",
        "cmnisl_obj_pulleystandA",               "cmnisl_obj_pulleystandB",               "cmnisl_obj_pulleystandC",            "cmnisl_obj_rainbowring",                "cmnisl_obj_rainbowring_body",
        "cmnisl_obj_spring",                     "cmnisl_obj_springair_bottom",           "cmnisl_obj_springair_top",           "cmnisl_obj_springC",                    "cmnisl_obj_springC_red",
        "cmnisl_obj_springC_yellow",             "cmnisl_obj_springegg",                  "cmnisl_obj_springpole",              "cmnisl_obj_springpole_L",               "cmnisl_obj_springpole_M",
        "cmnisl_obj_springpole_S",               "cmnisl_obj_upreel_handle",              "cmnisl_obj_upreel_stand",            "cmnisl_obj_upreel_wire",                "cmnisl_obj_walljumpblock01",
        "cmnisl_obj_walljumpblock02",            "cmnisl_obj_walljumpblock03",            "cmnisl_obj_widespring",              "cmnisl_obj_wjblock_arrow"
    };
//
{
    string NotifyRedirectIslandObjects(string resourceName, string resourceType)
    {
        switch (resourceType)
        {
            case "ResEffect":
            {
                if (resourceName == "ef_ob_dashring02")
                    return "ef_ob_dashring01";

                break;
            }

            case "ResModel":
            case "ResSkeleton":
            {
                if (resourceName == "cmnisl_obj_switchusual")
                    return "cmn_obj_switch";

                break;
            }

            case "ResAnimation":
            {
                if (resourceName == "cmnisl_obj_switchusual_on")
                    return "cmn_obj_switch_on";

                break;
            }

            case "ResPhysicsMesh":
            {
                switch (resourceName)
                {
                    case "cmnisl_obj_jumppanel30S":
                        return "cmn_obj_jumppanel30S_col";

                    case "cmnisl_obj_jumppanel30M":
                        return "cmn_obj_jumppanel30M_col";

                    case "cmnisl_obj_jumppanel30L":
                        return "cmn_obj_jumppanel30L_col";

                    case "col_cmnisl_obj_switchusual":
                        return "col_cmn_obj_switch";
                }

                break;
            }

            case "ResAnimTexSrt":
            {
                if (resourceName == "cmnisl_obj_switchusual03_on")
                    return "cmn_obj_switch03_on";

                break;
            }

            case "ResAnimMaterial":
            {
                if (resourceName == "cmnisl_obj_switchusual03")
                    return "cmn_obj_switch03";

                break;
            }
        }

        if (_objects.Contains(resourceName))
            return resourceName.Replace("cmnisl_obj_", "cmn_obj_");

        return resourceName;
    }

    if (GameMode.GetName() == "GameModeStage" || GameMode.GetTutorialDestination() == GameMode.DestinationMode.GameModeStage)
    {
        Resources.AddResourceNotifyAction(NotifyRedirectIslandObjects);
    }
    else
    {
        Resources.RemoveResourceNotifyAction(NotifyRedirectIslandObjects);
    }
}

Patch "Force Depth of Field" in "Graphics" by "WasifBoomz & Dicey" does "Forces Depth of Field to render, blurring near and distant geometry."
{
    // FxDOFParameter
    WriteAsmHook
    (
        $@"
            ; Enable DOF
            mov  byte ptr [r8], 1

            ; Set foreground bokeh depth to end at 3 and start at 0
            mov  dword ptr [r8+4], 0x40400000
            mov  dword ptr [r8+8], 0x00000000

            ; Set background bokeh depth to start at 4000 and end at 50
            mov  dword ptr [r8+12], 0x42480000
            mov  dword ptr [r8+16], 0x457A0000

            ; Increase sample count to 20
            mov  dword ptr [r8+32], 20

            ; Set render target size to full
            mov  byte ptr [r8+48], 0
        ",

        /* 0x1482689B8 */
        ScanSignature
        (
            "\x45\x0F\x10\x08\x89\x84\x24\x90\x00\x00\x00",
            "xxxxxxxxxxx"
        ),

        HookBehavior.After
    );

    // FxRenderTargetSetting
    WriteAsmHook
    (
        $@"
            ; Original code
            lea rbp, [rsp-400h]
            sub rsp, 500h
            mov r15, rcx

            ; Set render target size to full
            mov dword ptr [rdx], 0
        ",

        /* 0x140B83134 */
        ScanSignature
        (
            "\x48\x8D\xAC\x24\x00\xFC\xFF\xFF\x48\x81\xEC\x00\x05\x00\x00\x4C\x8B\xF9",
            "xxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Force Higher Detail Reflections" in "Graphics" by "Hyper" does "Forces real-time local reflections to render at a higher resolution and reduces artefacting around Sonic and other nearby objects."
{
    WriteAsmHook
    (
        $@"
            mov byte ptr [r14 + 0x269], 1           ; enable traceSky to fix reflections for near objects (e.g. Sonic)
            mov byte ptr [r14 + 0x26C], 0           ; disable useQuat for full resolution reflections
            mov byte ptr [r14 + 0x26D], 1           ; enable useNormal to apply normal maps to reflections
            mov dword ptr [r14 + 0x270], 0x44000000 ; set rayMarchingCount to 512.0f to improve reflection quality
            mov dword ptr [r14 + 0x280], 0x3FC00000 ; set overrideRatio to 1.5f to reduce artefacting
            mov dword ptr [r14 + 0x28C], 0x3E800000 ; set uvOffsetScale to 0.25f to improve reflection quality whilst retaining normal map detail

            ; Restore original code.
            movups xmm0, xmmword ptr [r14 + 0x268]
            mov    rcx, rsi
            movups xmmword ptr [rbx + 0x0C], xmm0
        ",

        /* 0x140B83CF1 */
        ScanSignature
        (
            "\x41\x0F\x10\x86\x68\x02\x00\x00\x48\x8B\xCE",
            "xxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Code "Force Island Objects in Cyber Space" in "Graphics" by "Hyper" does
/*
Replaces all supported objects in Cyber Space with their island counterparts.

Unsupported objects;
- Checkpoints
- Up-reel Carriers
*/
//
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "GameMode"
    #lib "Resources"

    using System.Collections.Generic;

    private static List<string> _objects = new()
    {   
        "cmn_obj_balloonB",                "cmn_obj_balloonG",                   "cmn_obj_balloonR",                "cmn_obj_balloonY",                   "cmn_obj_dashpanel",
        "cmn_obj_dashpanel_arrow",         "cmn_obj_dashpanel_belt",             "cmn_obj_dashring",                "cmn_obj_dashring_body",              "cmn_obj_dashroller",
        "cmn_obj_dashroller_GR",           "cmn_obj_dashroller_SV",              "cmn_obj_fan_fly",                 "cmn_obj_fan_ground",                 "cmn_obj_fan_top",
        "cmn_obj_grindbooster",            "cmn_obj_grindbooster_arrow",         "cmn_obj_grindbooster_arrow_stop", "cmn_obj_grindbooster_light_stop",    "cmn_obj_jumppanel_arrow",
        "cmn_obj_jumppanel_belt",          "cmn_obj_jumppanel30L",               "cmn_obj_jumppanel30M",            "cmn_obj_jumppanel30S",               "cmn_obj_jumpselector",
        "cmn_obj_jumpselector@correct",    "cmn_obj_jumpselector@miss",          "cmn_obj_jumpselector_arrow",      "cmn_obj_jumpselector_gauge_correct", "cmn_obj_jumpselector_gauge_in",
        "cmn_obj_jumpselector_gauge_miss", "cmn_obj_laserfence",                 "cmn_obj_pole_fvA",                "cmn_obj_pole_fvB",                   "cmn_obj_pole_guide",
        "cmn_obj_pole_guide_meter",        "cmn_obj_pole_guide_meterB",          "cmn_obj_pole_svA",                "cmn_obj_pole_svB",                   "cmn_obj_pole_svC",
        "cmn_obj_pole_svD",                "cmn_obj_propellerspring_body_limit", "cmn_obj_propellerspring_bottom",  "cmn_obj_propellerspring_top",        "cmn_obj_pulley",
        "cmn_obj_pulleystandA",            "cmn_obj_pulleystandB",               "cmn_obj_pulleystandC",            "cmn_obj_rainbowring",                "cmn_obj_rainbowring_body",
        "cmn_obj_spring",                  "cmn_obj_springair_bottom",           "cmn_obj_springair_top",           "cmn_obj_springC",                    "cmn_obj_springC_red",
        "cmn_obj_springC_yellow",          "cmn_obj_springegg",                  "cmn_obj_springpole",              "cmn_obj_springpole_L",               "cmn_obj_springpole_M",
        "cmn_obj_springpole_S",            "cmn_obj_upreel_handle",              "cmn_obj_upreel_stand",            "cmn_obj_upreel_wire",                "cmn_obj_walljumpblock01",
        "cmn_obj_walljumpblock02",         "cmn_obj_walljumpblock03",            "cmn_obj_widespring",              "cmn_obj_wjblock_arrow"
    };
//
{
    string NotifyRedirectCyberSpaceObjects(string resourceName, string resourceType)
    {
        switch (resourceType)
        {
            case "ResEffect":
            {
                if (resourceName == "ef_ob_dashring01")
                    return "ef_ob_dashring02";

                break;
            }

            case "ResModel":
            case "ResSkeleton":
            {
                if (resourceName == "cmn_obj_switch")
                    return "cmnisl_obj_switchusual";

                break;
            }

            case "ResAnimation":
            {
                if (resourceName == "cmn_obj_switch_on")
                    return "cmnisl_obj_switchusual_on";

                break;
            }

            case "ResPhysicsMesh":
            {
                switch (resourceName)
                {
                    case "cmn_obj_jumppanel30S_col":
                        return "cmnisl_obj_jumppanel30S";

                    case "cmn_obj_jumppanel30M_col":
                        return "cmnisl_obj_jumppanel30M";

                    case "cmn_obj_jumppanel30L_col":
                        return "cmnisl_obj_jumppanel30L";

                    case "col_cmn_obj_switch":
                        return "col_cmnisl_obj_switchusual";
                }

                break;
            }

            case "ResAnimTexSrt":
            {
                if (resourceName == "cmn_obj_switch03_on")
                    return "cmnisl_obj_switchusual03_on";

                break;
            }

            case "ResAnimMaterial":
            {
                if (resourceName == "cmn_obj_switch03")
                    return "cmnisl_obj_switchusual03";

                break;
            }
        }

        if (_objects.Contains(resourceName))
            return resourceName.Replace("cmn_obj_", "cmnisl_obj_");

        return resourceName;
    }

    if (GameMode.GetName() == "GameModeCyberStage" || GameMode.GetTutorialDestination() == GameMode.DestinationMode.GameModeCyberStage)
    {
        Resources.AddResourceNotifyAction(NotifyRedirectCyberSpaceObjects);
    }
    else
    {
        Resources.RemoveResourceNotifyAction(NotifyRedirectCyberSpaceObjects);
    }
}

Patch "Force Light Scattering" in "Graphics" by "WasifBoomz & Robowil" does "Forces Light Scattering to render."
{
    // FxDOFParameter
    WriteAsmHook
    (
        $@"
            ; Enable Light Scattering
            mov byte ptr [r8], 1
			
            ; Set Color to (0.015, 0.013, 0.023)
            mov dword ptr [r8+16], 0x3C75C28F
            mov dword ptr [r8+20], 0x3C54FDF4
            mov dword ptr [r8+24], 0x3CBC6A7F
			
            ; Set Scattering Scale to 15
            mov dword ptr [r8+32], 0x41700000
			
            ; Set Beta Mie to 0.6
            mov dword ptr [r8+64], 0x3F19999A
			
            ; Set Gamma to 0.08
            mov dword ptr [r8+68], 0x3DA3D70A
			
            ; Set ZNear and Far to 300 and 55000
            mov dword ptr [r8+72], 0x43960000
        ",
			
        /* 0x14828BC8C */
        ScanSignature
        (
            "\x45\x0F\x10\x00\x44\x0F\x29\x8C\x24\xE0\x00\x00\x00",
            "xxxxxxxxxxxxx"
        ),
			
        HookBehavior.After
    );
}

Patch "Force Maximum Geometry Detail" in "Graphics" by "Hyper" does
/*
Forces terrain, object and rail geometry to always render at the highest detail.

This does not address pop-in issues.
*/
//
    using System.Runtime.InteropServices;

    static float Range = 10000.0f;

    /* This array is actually 32 in length, but the game
       accesses an array with tons of padding at the start. */
    static float[] LayerRange = new float[36];
//
{
    // Geometry LODs
    IntPtr pLayerRange = Marshal.AllocHGlobal(LayerRange.Length * sizeof(float));
    {
        for (int i = 0; i < LayerRange.Length; i++)
            LayerRange[i] = Range;

        Marshal.Copy(LayerRange, 0, pLayerRange, LayerRange.Length);

        WriteAsmHook
        (
            $@"
                mov rcx, {(long)pLayerRange}

                ; Restore original code.
                movups xmm0, xmmword ptr [rcx + 0x0C]
                lea    rdx, qword ptr [rbp + 0xB0 + 0xFFFFFFFFFFFFFF34]
                movaps xmmword ptr [rbp - 0x20], xmm0
                movups xmm1, xmmword ptr [rcx + 0x1C]
            ",

            /* 0x140EDEAAE */
            ScanSignature
            (
                "\x0F\x10\x41\x0C\x48\x8D\x55\xE4",
                "xxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }

    // Rail LODs
    fixed (float* pRange = &Range)
    {
        /* 0x140B840F1 */
        var trrBlendRangeAddr = ScanSignature
        (
            "\x0F\x10\x00\x48\x8B\xCE\x0F\x11\x43\x0C\xE8",
            "xxxxxxxxxxx"
        );

        // Terrain Material Blending Range
        WriteAsmHook
        (
            $@"
                push   rcx
                mov    rcx, {(long)pRange}
                mov    ecx, dword ptr [rcx]
                mov    dword ptr [rax + 0x0C], ecx
                pop    rcx
                movups xmm0, xmmword ptr [rax]
                mov    rcx, rsi
                movups xmmword ptr [rbx + 0x0C], xmm0
                mov    rax, {((trrBlendRangeAddr + 10) + Read<int>(trrBlendRangeAddr + 11) + 0x05)} ; 0x140B81190
                call   rax
            ",

            trrBlendRangeAddr,

            HookBehavior.Replace
        );

        // Rail LODs
        WriteAsmHook
        (
            $@"
                push rax

                mov   rax, {(long)pRange}
                movss xmm0, dword ptr [rax]
                mulss xmm0, xmm0

                pop rax
            ",

            /* 0x140160930 */
            ScanSignature
            (
                "\x81\xF9\xFF\xFF\xFF\x7F\x74\x1C",
                "xxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}

Patch "Force PlayStation 4 Controller UI" in "UI" by "Hyper"
{
    WriteAsmHook
    (
        @"
            mov al, 0
            add rsp, 20h
            pop rbx
            ret
        ",

        /* v1.01: 0x1409501E6 */
        /* v1.10: 0x140950A80 */
        ScanSignature
        (
            "\x80\xF9\x02\x75\x60\x8B\xCA\xE8\x00\x00\x00\x00\x48\x8B\xD8\x48\x85\xC0\x74\x51\x48\x8B\x10\x48\x8B\xC8\xFF\x52\x38\x84\xC0\x74\x44\x48\x8B\xCB\xE8\x00\x00\x00\x00\x8B\x50\x54\x83\xEA\x01\x74\x2C\x83\xEA\x01\x74\x1F\x83\xEA\x01\x74\x2A\x83\xEA\x01\x74\x0D\x83\xFA\x01\x75\x20\xB0\x04\x48\x83\xC4\x20\x5B\xC3\xB0\x03\x48\x83\xC4\x20\x5B\xC3\xB0\x01\x48\x83\xC4\x20\x5B\xC3\x32\xC0\x48\x83\xC4\x20\x5B\xC3\xB0\x02\x48\x83\xC4\x20\x5B\xC3",
            "xxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );

    // Swap Share and Touchpad icons.
    WriteProtected<byte>
    (
        /* 0x140951B39 */
        ScanSignature
        (
            "\x74\x1F\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x85\xC0\x74\x12\x80\x78\x4C\x02",
            "xxxxxx????xxxxxxxxx"
        ),

        0xEB
    );
}

Patch "Force PlayStation 5 Controller UI" in "UI" by "Hyper"
{
    WriteAsmHook
    (
        @"
            mov al, 1
            add rsp, 20h
            pop rbx
            ret
        ",

        /* v1.01: 0x1409501E6 */
        /* v1.10: 0x140950A80 */
        ScanSignature
        (
            "\x80\xF9\x02\x75\x60\x8B\xCA\xE8\x00\x00\x00\x00\x48\x8B\xD8\x48\x85\xC0\x74\x51\x48\x8B\x10\x48\x8B\xC8\xFF\x52\x38\x84\xC0\x74\x44\x48\x8B\xCB\xE8\x00\x00\x00\x00\x8B\x50\x54\x83\xEA\x01\x74\x2C\x83\xEA\x01\x74\x1F\x83\xEA\x01\x74\x2A\x83\xEA\x01\x74\x0D\x83\xFA\x01\x75\x20\xB0\x04\x48\x83\xC4\x20\x5B\xC3\xB0\x03\x48\x83\xC4\x20\x5B\xC3\xB0\x01\x48\x83\xC4\x20\x5B\xC3\x32\xC0\x48\x83\xC4\x20\x5B\xC3\xB0\x02\x48\x83\xC4\x20\x5B\xC3",
            "xxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );

    // Swap Share and Touchpad icons.
    WriteProtected<byte>
    (
        /* 0x140951B39 */
        ScanSignature
        (
            "\x74\x1F\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x85\xC0\x74\x12\x80\x78\x4C\x02",
            "xxxxxx????xxxxxxxxx"
        ),

        0xEB
    );
}

Patch "Force Switch Controller UI" in "UI" by "Hyper"
{
    WriteAsmHook
    (
        @"
            mov al, 4
            add rsp, 20h
            pop rbx
            ret
        ",

        /* v1.01: 0x1409501E6 */
        /* v1.10: 0x140950A80 */
        ScanSignature
        (
            "\x80\xF9\x02\x75\x60\x8B\xCA\xE8\x00\x00\x00\x00\x48\x8B\xD8\x48\x85\xC0\x74\x51\x48\x8B\x10\x48\x8B\xC8\xFF\x52\x38\x84\xC0\x74\x44\x48\x8B\xCB\xE8\x00\x00\x00\x00\x8B\x50\x54\x83\xEA\x01\x74\x2C\x83\xEA\x01\x74\x1F\x83\xEA\x01\x74\x2A\x83\xEA\x01\x74\x0D\x83\xFA\x01\x75\x20\xB0\x04\x48\x83\xC4\x20\x5B\xC3\xB0\x03\x48\x83\xC4\x20\x5B\xC3\xB0\x01\x48\x83\xC4\x20\x5B\xC3\x32\xC0\x48\x83\xC4\x20\x5B\xC3\xB0\x02\x48\x83\xC4\x20\x5B\xC3",
            "xxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Force Xbox One Controller UI" in "UI" by "Hyper"
{
    WriteAsmHook
    (
        @"
            mov al, 2
            add rsp, 20h
            pop rbx
            ret
        ",

        /* v1.01: 0x1409501E6 */
        /* v1.10: 0x140950A80 */
        ScanSignature
        (
            "\x80\xF9\x02\x75\x60\x8B\xCA\xE8\x00\x00\x00\x00\x48\x8B\xD8\x48\x85\xC0\x74\x51\x48\x8B\x10\x48\x8B\xC8\xFF\x52\x38\x84\xC0\x74\x44\x48\x8B\xCB\xE8\x00\x00\x00\x00\x8B\x50\x54\x83\xEA\x01\x74\x2C\x83\xEA\x01\x74\x1F\x83\xEA\x01\x74\x2A\x83\xEA\x01\x74\x0D\x83\xFA\x01\x75\x20\xB0\x04\x48\x83\xC4\x20\x5B\xC3\xB0\x03\x48\x83\xC4\x20\x5B\xC3\xB0\x01\x48\x83\xC4\x20\x5B\xC3\x32\xC0\x48\x83\xC4\x20\x5B\xC3\xB0\x02\x48\x83\xC4\x20\x5B\xC3",
            "xxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Force Xbox Series Controller UI" in "UI" by "Hyper"
{
    WriteAsmHook
    (
        @"
            mov al, 3
            add rsp, 20h
            pop rbx
            ret
        ",

        /* v1.01: 0x1409501E6 */
        /* v1.10: 0x140950A80 */
        ScanSignature
        (
            "\x80\xF9\x02\x75\x60\x8B\xCA\xE8\x00\x00\x00\x00\x48\x8B\xD8\x48\x85\xC0\x74\x51\x48\x8B\x10\x48\x8B\xC8\xFF\x52\x38\x84\xC0\x74\x44\x48\x8B\xCB\xE8\x00\x00\x00\x00\x8B\x50\x54\x83\xEA\x01\x74\x2C\x83\xEA\x01\x74\x1F\x83\xEA\x01\x74\x2A\x83\xEA\x01\x74\x0D\x83\xFA\x01\x75\x20\xB0\x04\x48\x83\xC4\x20\x5B\xC3\xB0\x03\x48\x83\xC4\x20\x5B\xC3\xB0\x01\x48\x83\xC4\x20\x5B\xC3\x32\xC0\x48\x83\xC4\x20\x5B\xC3\xB0\x02\x48\x83\xC4\x20\x5B\xC3",
            "xxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Hide Air Trick Hint Effects" in "Graphics" by "Hyper" does "Hides the particles that hint at dash rings, jump boards and springs being air trickable."
{
    // Dash Rings
    WriteProtected<byte>
    (
        /* 0x14033752F */
        ScanSignature
        (
            "\x74\x7C\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCF\xE8\x00\x00\x00\x00\x33\xD2\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8D\x8F\x00\x00\x00\x00\x0F\xB6\x98\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x84\xDB\x74\x39\x84\xC0\x75\x47\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCF\xE8\x00\x00\x00\x00\x4C\x8D\x87\x00\x00\x00\x00\x48\x8B\xC8\x48\x8D\x15\x00\x00\x00\x00\x48\x8B\x5C\x24\x00\x48\x8B\x74\x24\x00\x48\x83\xC4\x20\x5F\xE9\x00\x00\x00\x00\x84\xC0\x74\x0E\x33\xD2\x48\x8D\x8F\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\x5C\x24\x00\x48\x8B\x74\x24\x00\x48\x83\xC4\x20\x5F\xC3\xCC\xCC\xCC\x48\x89\x5C\x24\x00",
            "xxx????xxxxxxx????xxxxxx????xxx????xxx????x????xxxxxxxxx????xxxxxxx????xxx????xxxxxx????xxxx?xxxx?xxxxxx????xxxxxxxxx????x????xxxx?xxxx?xxxxxxxxxxxxx?"
        ),

        0xEB
    );

    // Jump Boards
    WriteProtected<byte>
    (
        /* 0x140377917 */
        ScanSignature
        (
            "\x0F\x84\x00\x00\x00\x00\x48\x89\x5C\x24\x00\x48\x89\x74\x24\x00\xE8\x00\x00\x00\x00\x48\x8B\xD0",
            "xx????xxxx?xxxx?x????xxx"
        ),

        0xE9, 0x84, 0x00, 0x00, 0x00
    );

    // Springs
    WriteProtected<byte>
    (
        /* 0x1497E39EE */
        ScanSignature
        (
            "\x48\x89\xC3\x85\xC9\x0F\x84\x00\x00\x00\x00\x83\xF9\x03\x0F\x84\x00\x00\x00\x00\x83\xF9\x02\x0F\x85\x00\x00\x00\x00\x80\xBF\x00\x00\x00\x00\x00\x0F\x29\xB4\x24\x00\x00\x00\x00\x0F\x85\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x89\xC2\x48\x89\xF9\xE8\x00\x00\x00\x00\x31\xD2\x48\x89\xC1\xE8\x00\x00\x00\x00\x0F\x10\xB0\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x89\xC2\x48\x89\xF9\xE8\x00\x00\x00\x00\x0F\xC6\xF6\x55\x48\x8B\x88\x00\x00\x00\x00\xF3\x0F\x5C\xB1\x00\x00\x00\x00\x0F\x54\x35\x00\x00\x00\x00\x0F\x2F\x35\x00\x00\x00\x00\x73\x2D\x48\x8B\x8F\x00\x00\x00\x00\xC6\x87\x00\x00\x00\x00\x00\x48\x85\xC9\x74\x07\xB2\x01\xE8\x00\x00\x00\x00",
            "xxxxxxx????xxxxx????xxxxx????xx?????xxxx????xx????x????xxxxxxx????xxxxxx????xxx????x????xxxxxxx????xxxxxxx????xxxx????xxx????xxx????xxxxx????xx?????xxxxxxxx????"
        ),

        0xEB, 0x12
    );
}

Patch "Hide Boost Gauge" in "UI" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x14098D3B4 */
        ScanSignature
        (
            "\x74\x1D\xE8\xCC\xCC\xCC\xCC\x48\x8D\x0D\xCC\xCC\xCC\xCC\x48\x89\x4C\x24\x30\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE9\x8F\x00\x00\x00",
            "xxx????xxx????xxxxxxxx????xxxxx"
        ),

        0xEB
    );
}

Patch "Hide Challenge Markers" in "Graphics" by "Hyper" does "Hides the markers that appear next to challenges on the islands."
{
    // Hide map sensor visual.
    WriteProtected<byte>
    (
        /* 0x1403BF63B */
        ScanSignature
        (
            "\x74\x17\x48\x8D\x55\xD7\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD3\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x48\x8B\x8F\x58\x02\x00\x00",
            "xxxxxxxxxx????xxxxxxx????xxxxxxx"
        ),

        0xEB
    );

    // Hide map sensor prerequisite marker.
    WriteProtected<byte>
    (
        /* 0x1403BF6B3 */
        ScanSignature
        (
            "\x0F\x85\xE5\x00\x00\x00\xE8",
            "xxxxxxx"
        ),

        0xE9, 0xE6, 0x00, 0x00, 0x00
    );

    // Hide map sensor name.
    WriteProtected<byte>
    (
        /* 0x1408D128F */
        ScanSignature
        (
            "\x0F\x8E\x47\x02\x00\x00\x4C\x89\xA4\x24\x58\x01\x00\x00",
            "xxxxxxxxxxxxxx"
        ),

        0xE9, 0x48, 0x02, 0x00, 0x00
    );
}

Patch "Hide Cyber Space Timer" in "UI" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x14098EE10 */
        ScanSignature
        (
            "\x74\x1C\xE8\xCC\xCC\xCC\xCC\x48\x8D\x0D\xCC\xCC\xCC\xCC\x48\x89\x4D\xF0\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE9\x85\x00\x00\x00\xE8\xCC\xCC\xCC\xCC\x48\x8D\x0D\xCC\xCC\xCC\xCC\x48\x89\x4D\xF0\x48\x8D\x0D\xCC\xCC\xCC\xCC\xEB\x6C\x3D\xBF\x23\x00\x00\x0F\x85\x98\x00\x00\x00\x8B\x42\x20\x48\xC1\xE8\x1E",
            "xxx????xxx????xxxxxxx????xxxxxx????xxx????xxxxxxx????xxxxxxxxxxxxxxxxxxxx"
        ),

        0xEB
    );
}

Patch "Hide Drift Dash Panels" in "Graphics" by "Hyper" does "Hides the drift dash panels, but still allows them to function, similarly to drift zones in Sonic Colours."
{
    // Remove model.
    WriteNop
    (
        /* 0x140432970 */
        ScanSignature
        (
            "\x48\x89\x47\x38\x48\x8D\x1D\x00\x00\x00\x00",
            "xxxxxxx????"
        ),

        4
    );

    // Remove sound.
    WriteNop
    (
        /* 0x140432AEC */
        ScanSignature
        (
            "\xE8\x00\x00\x00\x00\x48\x8D\x4C\x24\x00\xE8\x00\x00\x00\x00\xB0\x01\x48\x81\xC4\x00\x00\x00\x00\x5E",
            "x????xxxx?x????xxxxx????x"
        ),

        5
    );
}

Patch "Hide Enemy Health Gauge" in "UI" by "Hyper & Gordon Ramsay" does "Hides the health gauge for standard enemies and guardians."
{
    WriteProtected<byte>
    (
        /* 0x14054E7AB */
        ScanSignature
        (
            "\x0F\x84\xF7\x00\x00\x00\xBA\x82\x23\x00\x00",
            "xxxxxxxxxxx"
        ),

        0xE9, 0xF8, 0x00, 0x00, 0x00
    );
}

Patch "Hide Homing Reticle" in "UI" by "Hyper"
{
    // Disable sound and main reticle.
    WriteProtected<byte>
    (
        /* 0x1409526AA */
        ScanSignature
        (
            "\x0F\x84\xB5\x00\x00\x00\x49\x8D\xBD\x10\x01\x00\x00",
            "xxxxxxxxxxxxx"
        ),

        0xE9, 0xB6, 0x00, 0x00, 0x00
    );

    // Disable lock-on triangle.
    WriteProtected<byte>
    (
        /* 0x14C5E45B2 */
        ScanSignature
        (
            "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x48\x89\x7C\x24\x18\x55\x48\x8D\x6C\x24\xA9\x48\x81\xEC\x90\x00\x00\x00\x48\x89\xCB\x48\xC7\x45\xFF\x02\x00\x00\x00",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        )
        + 0x232,

        0xEB
    );
}

Patch "Hide Oxygen Gauge" in "UI" by "Hyper"
{
    WriteProtected<byte>
    (
        /* 0x14097E4A0 */
        ScanSignature
        (
            "\x74\x1C\xE8\xCC\xCC\xCC\xCC\x48\x8D\x0D\xCC\xCC\xCC\xCC\x48\x89\x4D\xF0\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE9\x85\x00\x00\x00\xE8\xCC\xCC\xCC\xCC\x48\x8D\x0D\xCC\xCC\xCC\xCC\x48\x89\x4D\xF0\x48\x8D\x0D\xCC\xCC\xCC\xCC\xEB\x6C\x3D\xBF\x23\x00\x00\x0F\x85\x98\x00\x00\x00\x0F\xB6\x42\x20",
            "xxx????xxx????xxxxxxx????xxxxxx????xxx????xxxxxxx????xxxxxxxxxxxxxxxxx"
        ),

        0xEB
    );
}

Patch "Hide Power Boost Effects" in "Graphics" by "NM & Hyper"
{
    /* Activation FX */
    WriteNop
    (
        /* 0x1408D2AE5 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x83\x7D\x98\x00\x4C\x8D\x05\xCC\xCC\xCC\xCC\x41\xB9\x11\x00\x00\x00",
            "x????xxxxxxx????xxxxxx"
        ),

        5
    );

    /* Boost Activation FX */
    WriteProtected<byte>
    (
        /* 0x1408D1CD4 */
        ScanSignature
        (
            "\x74\x09\x4C\x8D\x05\xCC\xCC\xCC\xCC\xEB\x4F\x48\x8B\xCF",
            "xxxxx????xxxxx"
        ),

        0xEB, 0x09
    );

    /* Trail FX */
    WriteProtected<byte>
    (
        /* 0x1407E931A */
        ScanSignature
        (
            "\xB2\x02\xEB\x02\x32\xD2",
            "xxxxxx"
        ),

        Assemble("mov dl, 1")
    );
}

Patch "Hide Sixth Sense Effects" in "Graphics" by "Hyper" does "Hides the particle effect when Sonic senses an enemy attack."
{
    WriteProtected<byte>
    (
        /* 0x1407E98CC */
        ScanSignature
        (
            "\x74\x79\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4B\x6C",
            "xxx????xxxx"
        ),

        0xEB
    );
}

Patch "Hide Skill Piece Transition" in "UI" by "Hyper" does "Removes the transition when picking up skill pieces to put them into the skill points display."
{
    WriteNop
    (
        /* 0x140864297 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4C\x24\x50\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4D\x80\xE8\xCC\xCC\xCC\xCC\x45\x84\xFF",
            "x????xxxxxx????xxxxx????xxx"
        ),

        5
    );

    WriteNop
    (
        /* 0x1408CCA29 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4D\xD7\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4D\xA7",
            "x????xxxxx????xxxx"
        ),

        5
    );
}

Patch "Hide Skip Button in Cutscenes" in "UI" by "Hyper" does "Hides the button prompt at the bottom-right to skip cutscenes. This does not disable the ability to skip cutscenes."
{
    WriteProtected<byte>
    (
        /* 0x1408BE1E8 */
        ScanSignature
        (
            "\x74\x71\x48\x8D\x5C\x24\x00\xBF\x00\x00\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x83\xC3\x18\x48\x83\xEF\x01\x75\xEE\x0F\x57\xC0\xC7\x84\x24\x00\x00\x00\x00\x00\x00\x00\x00\x4C\x8D\x05\x00\x00\x00\x00\x0F\x29\x84\x24\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x40\x88\xBC\x24\x00\x00\x00\x00\x48\x8D\x4C\x24\x00\xE8\x00\x00\x00\x00\x48\x8D\x54\x24\x00\x66\xC7\x84\x24\x00\x00\x00\x00\x00\x00\x48\x8B\xCD\xC6\x84\x24\x00\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xAC\x24\x00\x00\x00\x00\xC6\x86\x00\x00\x00\x00\x00\x48\x81\xC4\x00\x00\x00\x00\x5F\x5E\x5B\xC3",
            "xxxxxx?x????xxxx????xxxxxxxxxxxxxxxx????????xxx????xxxx????xxx????xxxx????xxxx?x????xxxx?xxxx??????xxxxxx?????x????xxxx????xx?????xxx????xxxx"
        ),

        0xEB
    );
}

Patch "Hide Star Beacons" in "Graphics" by "Hyper" does "Hides the beacons that emit from the stars during Starfall."
{
    WriteProtected<byte>
    (
        ScanSignature
        (
            "cmnisl_obj_slotstarpillar",
            "xxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        0x00
    );
}

Patch "Hide Super Combat Effects" in "Graphics" by "Hyper" does "Hides the giant fist and foot particles during combat as Super Sonic."
{
    WriteProtected<byte>
    (
        /* 0x1407B5BF2 */
        ScanSignature
        (
            "\x0F\x84\x00\x00\x00\x00\x0F\x1F\x84\x00\x00\x00\x00\x00\x48\x8D\x4B\x48\xE8\x00\x00\x00\x00\x84\xC0\x75\x0D\x48\x8D\x4B\x50\xE8\x00\x00\x00\x00\x84\xC0\x74\x0E\x48\x83\xC3\x60\x48\x3B\xDF\x75\xDD\xE9\x00\x00\x00\x00\x0F\x28\x45\x10\x48\x8D\x4B\x48\xF3\x0F\x10\x4D\x00\xF3\x0F\x10\x65\x00\xF3\x0F\x10\x5D\x00\x0F\x29\xB4\x24\x00\x00\x00\x00\xF3\x0F\x10\x75\x00\x66\x0F\x7F\x43\x00\x0F\x28\x55\x20\x66\x0F\x7F\x53\x00\xF3\x0F\x11\x5B\x00\xF3\x0F\x11\x63\x00\xE8\x00\x00\x00\x00\x48\x8D\x4B\x50\x0F\x28\xCE\xE8\x00\x00\x00\x00\xF3\x0F\x10\x05\x00\x00\x00\x00",
            "xx????xxxx????xxxxx????xxxxxxxxx????xxxxxxxxxxxxxx????xxxxxxxxxxxx?xxxx?xxxx?xxxx????xxxx?xxxx?xxxxxxxx?xxxx?xxxx?x????xxxxxxxx????xxxx????"
        ),

        0xE9, 0x3C, 0x01, 0x00, 0x00
    );
}

Patch "Hide Titan Health Gauge" in "UI" by "Hyper"
{
    WriteProtected<byte>
    (
        /* v1.01: 0x14C76211A */
        /* v1.10: 0x14C6036DB */
        ScanSignature
        (
            "\x74\x18\x48\x8D\x54\x24\x70\x48\x89\xC1\xE8\xCC\xCC\xCC\xCC\x48\x89\xFA",
            "xxxxxxxxxxx????xxx"
        ),

        0xEB
    );
}

Code "Homing Attack Trick Animations" in "Animation" by "Hyper & Ahremic" does "Replaces the homing attack finish animation with randomised trick animations."
//
    #lib "Memory"

    using System.Runtime.InteropServices;

    static bool Initialised = false;

    static Random Random = new Random();

    static string[] AnimVariations = new[] { "U", "D", "L", "R" };

    static float AnimSpeed = 0.5f;

    static IntPtr pAnimName = Marshal.AllocHGlobal(14);
//
{
    string randAnimName = $"JUMP_TRICK_{AnimVariations[Random.Next(0, 4)]}{Random.Next(0, 3)}\0";

    Marshal.Copy(System.Text.Encoding.UTF8.GetBytes(randAnimName), 0, pAnimName, randAnimName.Length);

    if (!Initialised)
    {
        /* 0x140823825 */
        long playAnimCallerAddr = ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x33\xD2\x49\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x41\xB8\x74\x00\x00\x00",
            "x????xxxxxx????xxxxxx"
        );

        /* 0x14086F023 */
        long setAnimSpeedCallerAddr = ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8D\x05\xCC\xCC\xCC\xCC\xB9\x03\x00\x00\x00",
            "x????xxx????xxxxx"
        );

        /* 0x1407C9300 */
        long playAnimFuncAddr = Memory.ReadCall(playAnimCallerAddr);

        /* 0x1407C9DB0 */
        long setAnimSpeedFuncAddr = Memory.ReadCall(setAnimSpeedCallerAddr);

        fixed (float* pAnimSpeed = &AnimSpeed)
        {
            WriteAsmHook
            (
                $@"
                    push  rax
                    mov   rax, {(long)pAnimSpeed}
                    movss xmm2, dword ptr [rax]
                    pop   rax
                    mov   rdx, {(long)Marshal.StringToHGlobalAnsi("SPEED_RATIO")}
                    lea   rdx, [rdx]
                    mov   rcx, rax
                    mov   rax, {setAnimSpeedFuncAddr}
                    mov   rbx, rcx
                    call  rax
                    mov   rdx, {pAnimName}
                    lea   rdx, [rdx]
                    mov   rcx, rbx
                    mov   rax, {playAnimFuncAddr}
                    call  rax
                ",

                /* 0x14082381B */
                playAnimCallerAddr - 0x0A,

                HookBehavior.Replace
            );
        }

        Initialised = true;
    }
}

Patch "Infinite Boost Gauge" in "Cheats" by "Hyper"
{
    WriteNop
    (
        /* 0x1408D45EA */
        ScanSignature
        (
            "\xF3\x0F\x11\x4F\x3C\x48\x8B\xCF",
            "xxxxxxxx"
        ),

        5
    );
}

Patch "Infinite Skill Points" in "Cheats" by "Hyper"
{
    WriteAsmHook
    (
        "mov qword ptr [rbx - 0x70 + 0x84], 999",

        /* 0x14014425D */
        ScanSignature
        (
            "\x0F\x85\x6D\x01\x00\x00\x83\x79\x0C\x00",
            "xxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Infinite Training Simulator Timer" in "Cheats" by "Hyper" does "Allows the timer in Training Simulator to drop below zero and continue uninterrupted."
{
    WriteProtected<byte>
    (
        /* 0x14018C55C */
        ScanSignature
        (
            "\x0F\x87\x00\x00\x00\x00\x48\x8D\x05\x00\x00\x00\x00\x48\xC7\x45\x00\x00\x00\x00\x00\x48\x89\x45\xE8\x48\x8D\x4E\x20\x48\x8D\x05\x00\x00\x00\x00\xC6\x45\xF0\x01\x4C\x8D\x45\xD8\x48\x89\x45\xD8\x48\x8B\xD6\xE8\x00\x00\x00\x00\xE9\x00\x00\x00\x00\x48\x8B\x59\x10\xBA\x00\x00\x00\x00\x48\x8D\x4D\xD8\xE8\x00\x00\x00\x00\x48\x8B\x53\x30\x48\x8D\x05\x00\x00\x00\x00\x4C\x8D\x45\xD8\x48\x89\x45\xD8\x48\x8B\xCB\xC7\x45\x00\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8D\x4D\xD8\xE8\x00\x00\x00\x00\xBA\x00\x00\x00\x00\x48\x8D\x4D\xD8\xE8\x00\x00\x00\x00\x48\x8D\x05\x00\x00\x00\x00",
            "xx????xxx????xxx?????xxxxxxxxxxx????xxxxxxxxxxxxxxxx????x????xxxxx????xxxxx????xxxxxxx????xxxxxxxxxxxxx?????x????xxxxx????x????xxxxx????xxx????"
        ),

        0xE9, 0x56, 0x01, 0x00, 0x00
    );
}

Patch "Infinite Quick Cyloop Gauge" in "Cheats" by "NM"
{
    WriteAsmHook
    (
        @"
            mov dword ptr [rcx+0x000000B8], 0x42F00000 ; 120.0f, the max value of the gauge
            movss xmm0, dword ptr [rcx+0x000000B4]
        ",

        /* 0x14AA2A749 */
        ScanSignature
        (
            "\xF3\x0F\x11\x91\xB8\x00\x00\x00\xF3\x0F\x10\x81\xB4\x00\x00\x00\xF3\x0F\x5C\xC2\x0F\x54\x05\xDC\xA2\x64\xF6\x0F\x2F\x05\xCD\xA2\x64\xF6\x0F\x96\xD0\xC3",
            "xxxx????xxxx????xxxxxxx????xxx????xxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Keep Red Rings on Death" in "Cheats" by "WasifBoomz" does "Prevents you from losing Red Rings after dying in Cyber Space."
{
    WriteNop
    (
        /* 0x1401B12B4 */
        ScanSignature
        (
            "\x88\x41\x1A\xC3\x0F\xB6\x41\x18",
            "xxxxxxxx"
        ),
			
        3
    );
}

Code "Play Random Soundtrack in Cyber Space" in "Audio" by "Hyper" does "Plays a random soundtrack every time you enter Cyber Space."
//
    static long Address = 0;

    static string[] BgmList = new[]
    {
        /* Kronos */
        "bgm_w6d01", "bgm_w6d02", "bgm_w6d03", "bgm_w6d04", "bgm_w6d05",
        "bgm_w6d06", "bgm_w6d07", "bgm_w6d08", "bgm_w6d09", "bgm_w6d10",

        /* Ares */
        "bgm_w7d01", "bgm_w7d02", "bgm_w7d03", "bgm_w7d04", "bgm_w7d05",
        "bgm_w7d06", "bgm_w7d07", "bgm_w7d08",

        /* Chaos */
        "bgm_w8d01", "bgm_w8d02", "bgm_w8d03", "bgm_w8d04", "bgm_w8d05",
        "bgm_w8d06",

        /* Ouranos */
        "bgm_w9d02", "bgm_w9d03", "bgm_w9d04", "bgm_w9d05", "bgm_w9d06",
        "bgm_w9d07"
    };
//
{
    if (Address == 0)
    {
        /* 0x14132A3C0 */
        Address = ScanSignature
        (
            "bgm_%s",
            "xxxxxx"
        );
    }
    else
    {
        WriteProtected<byte>(Address, System.Text.Encoding.UTF8.GetBytes(BgmList[new Random().Next(0, 30)]));
    }
}

Code "Rail Crouch" in "Gameplay" by "WasifBoomz" does
/*
Allows Sonic to crouch on grind rails to gain or lose speed based on the angle of the rail.

Notes;
- The speed cap is increased while grinding.
- The boost has been modified to become an accelerator while grinding.
*/
//
    #lib "Sonic"
    #lib "BlackboardStatus"
    #lib "Bitwise"

    #load "System.Numerics.dll"
	
    using System;
    using System.Numerics;

    const float grindCrouchSpeed = 40.0f;
    const float boostGrindSpeedMin = 3.0f;
    const float boostGrindSpeed = 45.0f;
    static bool isInitialised = false;
    static bool isRailCrouching = false;
    static float* playerParamGrind = null;
//
{
    if (!isInitialised)
    {
        fixed (float** pPlayerParamGrind = &playerParamGrind)
        {
            // Load Player Params Grind
            WriteAsmHook
            (
                $@"
                    mov rbx, {(long)pPlayerParamGrind}
                    ; Get Pointer to Params
                    mov qword ptr [rbx], rax
                    ; Set Grind Speed to 100
                    mov dword ptr [rax], 0x42C80000
                    ; Set Boost Grind Speed to 0
                    mov dword ptr [rax+4], 0x00000000
                ",

                /* 0x14080C75E */
                ScanSignature
                (
                    "\x48\x8B\x4F\x40\x4C\x8D\x4C\x24\x30\x45\x33\xC0",
                    "xxxxxxxxxxxx"
                ),
                        
                HookBehavior.Before
            );
        }

        fixed (bool* pIsRailCrouching = &isRailCrouching)
        {
            // Modify animation when crouching on rails
            WriteAsmHook
            (
                $@"
                    ; Check if the Grind Land animation is playing
                    cmp byte ptr [r15 - 0x2], 0x52
                    jnz end
                    mov rcx, {(long)pIsRailCrouching}
                    ; Check if the player is crouching
                    cmp byte ptr [rcx], 1
                    jnz reset
                    ; Set Transition Time and Next State
                    mov byte ptr [r15 + 0x2], 0x52
                    mov dword ptr [r15 + 0x4], 0x3F800000
                    jmp end
                reset:
                    ; Reset Transition Time and Next State
                    mov byte ptr [r15 + 0x2], 0x51
                    mov dword ptr [r15 + 0x4], 0x3E4CCCCD
                end:
                ",

		    /* 0x140DA25AC */
                ScanSignature
                (
                    "\x41\x8B\x47\x08\xF2\x41\x0F\x10\x07",
                    "xxxxxxxxx"
                ),
                        
                HookBehavior.After
            );
        }

	    // Jump over the grind boost code
        WriteProtected<byte>
        (
            /* 0x14AD7760A */
            ScanSignature
            (
                "\x74\x0F\xBA\x01\x00\x00\x00\x48\x83\xC4\x20\x5B\xE9\xC5\x14\xAB\xF5",
                "xxxxxxxxxxxxxxxxx"
            ),

            0xEB
        );

        isInitialised = true;
    }

    Sonic.Kinematics kinematics = Sonic.Kinematics.Get();

    if (BlackboardStatus.Get() == null)
        return;

    if (kinematics == null)
        return;

    if (playerParamGrind == null)
        return;

    float* grindAcceleration = &playerParamGrind[2];
    *grindAcceleration = 0;
    isRailCrouching = false;

    // Run this code when crouching on rails
    if (Sonic.Input.IsDown(Sonic.PlayerActionType.PlayerStomping))
    {
        if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateGrind)
        {
            isRailCrouching = true;
            Sonic.Animation.SetAnimation("GRIND_LAND");
        }

	    // Increase speed based on gravity
        *grindAcceleration -= (Vector3.Normalize(*kinematics.Velocity).Y) * grindCrouchSpeed;
    }
    
    // Increase acceleration when boosting on Grind Rails
    if (Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsBoost))
    {
        *grindAcceleration += (Vector3.Normalize(*kinematics.Velocity).Y) * boostGrindSpeed;
        *grindAcceleration = Math.Max(*grindAcceleration, boostGrindSpeedMin);
    }
}

Patch "Rebind Quick Restart to Back" in "Gameplay" by "Hyper" does "Rebinds the quick restart command from LT + RT + Back to just pressing the Back button."
{
    // GameModeBattleRush
    WriteProtected<byte>
    (
        /* 0x1401812FB */
        ScanSignature
        (
            "\xF6\x40\x17\x01\x74\x26",
            "xxxxxx"
        ),

        0xEB, 0x0A
    );

    // GameModeCyberStage
    WriteProtected<byte>
    (
        /* 0x140189970 */
        ScanSignature
        (
            "\xF6\x40\x17\x01\x74\x21\xF6\x40\x1F\x01\x74\x1B\xF6\x40\x0F\x01\x74\x15\xBA\x0E\x00\x00\x00\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\xB0\x01\x48\x83\xC4\x20\x5B\xC3\xBA\xCA\x4F\x40\x56\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x33\xD2\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x85\xC0\x74\x7B\x48\x8B\x40\x78\x0F\xBE\x48\x07",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxx????xxxxxx????xxxxxxxxxxxxx"
        ),

        0xEB, 0x0A
    );

    // GameModeCyberStageChallenge
    WriteProtected<byte>
    (
        /* 0x140189970 */
        ScanSignature
        (
            "\xF6\x40\x17\x01\x74\x21\xF6\x40\x1F\x01\x74\x1B\xF6\x40\x0F\x01\x74\x15\xBA\x0E\x00\x00\x00\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\xB0\x01\x48\x83\xC4\x20\x5B\xC3\xBA\xCA\x4F\x40\x56\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x33\xD2\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x85\xC0\x74\x7B\x48\x8B\x40\x78\x0F\xBE\x48\x07\xD1\xE9\xF6\xC1\x01\x75\x10\x48\x8B\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x84\xC0\x74\x5C\xBA\x12\xB3\xD1\x36\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x48\x8D\x0D\xCC\xCC\xCC\xCC\x48\x8D\x15\xCC\xCC\xCC\xCC\x0F\x1F\x00\x83\x39\x09\x74\x20\x48\x83\xC1\x08\x48\x3B\xCA\x75\xF2\x45\x33\xC0\x48\x8B\xC8\x41\x8D\x50\x09\xE8\xCC\xCC\xCC\xCC\xB0\x01\x48\x83\xC4\x20\x5B\xC3",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxx????xxxxxx????xxxxxxxxxxxxxxxxxxxxxxx????x????xxxxxxxxxxxxx????xxx????xxx????xxxxxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxx"
        ),

        0xEB, 0x0A
    );
}

Patch "Reduced Homing Delay" in "Physics" by "Hyper" does "Reduces the delay after performing a homing attack, allowing you to perform chained homing attacks much quicker."
//
    static float Delay = 0.2f;
//
{
    fixed (float* pDelay = &Delay)
    {
        WriteAsmHook
        (
            $@"
                push  rbx
                mov   rbx, {(long)pDelay}
                movss xmm2, dword ptr [rbx]
                mov   edx, eax
                mov   rcx, r13
                mov   dword ptr [rbp + 0x57 + 0x28], eax
                pop   rbx
            ",

            /* 0x14082379C */
            ScanSignature
            (
                "\xF3\x41\x0F\x10\x54\x3F\x18",
                "xxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}

Patch "Restore Unused Spin Charge Camera Shake" in "Camera" by "Hyper"
{
    WriteAsmHook
    (
        $@"
            lea rbx, qword ptr [rax + 0xE8]
            mov rax, {(long)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi("SpinBoostCharge")}
            mov qword ptr [rbx], rax
        ",

        /* 0x1408A66FE */
        ScanSignature
        (
            "\x48\x8D\x98\xE8\x00\x00\x00\x48\x8B\x03\x48\x85\xC0\x74\x77\x80\x38\x00\x74\x72\xBA\xC6\x22\x00\x00\x48\x8D\x4C\x24\x30\xE8\xCC\xCC\xCC\xCC\x0F\x28\x05\xCC\xCC\xCC\xCC\x48\x8D\x05\xCC\xCC\xCC\xCC\x48\x8B\xCB\x48\x89\x44\x24\x30\x66\x0F\x7F\x44\x24\x60\x48\xC7\x44\x24\x50\x00\x00\x00\x00\xE8\xCC\xCC\xCC\xCC\x48\x8D\x54\x24\x20\x48\x89\x44\x24\x50\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCF\x0F\x28\x00\x0F\x29\x44\x24\x60\xE8\xCC\xCC\xCC\xCC\x48\x8B\xC8\x48\x8D\x54\x24\x30\xE8\xCC\xCC\xCC\xCC\x48\x8D\x4C\x24\x30\xE8\xCC\xCC\xCC\xCC\xBA\x12\x00\x00\x00",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx????xxx????xxx????xxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxx????xxxxxxxxxxxx????xxxxxxxxx????xxxxxx????xxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Restore Unused Supreme QTE" in "Gameplay" by "Gordon Ramsay" does
/*
Restores an unused quick time event for the final blow to Supreme.

This replaces the basic X button QTE to dodge the rifle projectile in the final game.
*/
{
    WriteProtected<byte>
    (
        /* 0x14125C830 */
        ScanSignature
        (
            "zev_rfl_shoot02",
            "xxxxxxxxxxxxxxx"
        ),

        System.Text.Encoding.UTF8.GetBytes("zev_rfl_shoot01")
    );
}

Patch "Retain Ground Velocity for Jump" in "Physics" by "Hyper" does
/*
Retains Sonic's ground velocity when jumping.

Notes;
- This will allow you to retain velocity when jumping out of a Drop Dash.
- The "Jump Deceleration" and "Maintain boost during a jump" options can remain active without conflicting with this code.
*/
//
    #lib "Memory"
    #lib "Sonic"

    static bool IsInitialised = false;
    static bool IsStateJump = false;
//
{
    if (!IsInitialised)
    {
        fixed (bool* pIsStateJump = &IsStateJump)
        {
            /* v1.30: 0x1408406F8 */
            var callerFuncAddr = ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\x48\x8B\x43\x20\xBA\x20\x16\x1E\x71\x44\x0F\x28\xC0\x48\x8B\x88\x80\x00\x00\x00\xE8\xCC\xCC\xCC\xCC\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCB\x0F\x28\xF8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x8D\x55\xE7",
                "x????xxxxxxxxxxxxxxxxxxxxx????xxxx????xxxxxxx????xxxx????xxxx"
            );

            /* v1.30: 0x14080CA10 */
            var mainFuncAddr = Memory.ReadCall(callerFuncAddr);

            // Update posture to allow retaining ground velocity.
            WriteAsmHook
            (
                $@"
                    mov   rdi, rcx

                    ; Check if we're in the jump state
                    push  r11
                    mov   r11, {(long)pIsStateJump}
                    mov   r11b, byte ptr [r11]
                    cmp   r11b, 0
                    jz    default
                    mov   al, 1
                    jmp   exit

                default:
                    xor   edx, edx
                    mov   rcx, [rcx + 0x28] ; RCX = BlackboardStatus
                    mov   eax, edx
                    and   eax, 0x3F
                    movzx r8d, al
                    mov   eax, edx
                    shr   rax, 6
                    mov   rax, [rcx + rax * 8 + 0x30]
                    bt    rax, r8
                    setb  al

                exit:
                    pop   r11
                ",

                /* v1.30: 0x14080CA16 */
                mainFuncAddr + 6,

                HookBehavior.Replace
            );
        }

        IsInitialised = true;
    }

    void NotifyStateJump(Sonic.StateID stateId, Sonic.StateID[] stateStackTrace)
    {
        IsStateJump = stateId == Sonic.StateID.StateJump;
    }

    Sonic.State.AddStateNotifyAction(NotifyStateJump);
}

Code "Show Framerate on Title Bar" in "System" by "Hyper & Sajid"
//
    #lib "Time"

    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Text;

    [DllImport("user32.dll", SetLastError=true, CharSet=CharSet.Auto)]
    static extern int GetWindowTextLength(IntPtr hWnd);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    static extern bool SetWindowText(IntPtr hWnd, String lpString);

    static IntPtr HWND = IntPtr.Zero;

    static string OriginalTitle;
//
{
    if (HWND == IntPtr.Zero)
    {
        HWND = Process.GetCurrentProcess().MainWindowHandle;
    }
    else
    {
        if (string.IsNullOrEmpty(OriginalTitle))
        {
            StringBuilder title = new StringBuilder(GetWindowTextLength(HWND) + 1);
            {
                GetWindowText(HWND, title, title.Capacity);

                OriginalTitle = title.ToString();
            }
        }
        else
        {
            SetWindowText(HWND, $"{OriginalTitle} - {Time.GetFrameRate()} FPS ({Time.GetDeltaTime()} ms)");
        }
    }
}

Patch "Show Missions in Arcade Mode" in "UI" by "Hyper" does "Shows the missions in the results screen when completing Cyber Space in Arcade Mode."
{
    /* 0x14093798D */
    long addr = ScanSignature
    (
        "\x44\x38\xBB\x6C\x02\x00\x00",
        "xxxxxxx"
    );

    if (addr == 0)
        return;

    WriteProtected<byte>(addr, Assemble("mov byte ptr [rbx + 0x26C], 0"));
    WriteProtected<byte>(addr + 7, 0xEB);
}

Patch "Smooth Camera (v1.30)" in "Camera" by "Ahremic" does "Replaces linear camera interpolation with a sigmoid solution, using Ken Perlin's ''Smoother Step'' second-order hermite polynomial."
//
    static float value01 = 1.0f;
    static float value03 = 3.0f;
    static float value05 = 5.0f;
    static float value10 = 10.0f;
//
{
    // Linear coordinate interpolator
    WriteProtected<byte>(0x1463B282A, Assemble("mov edx, 0x60; nop"));
    WriteProtected<byte>(0x1463B286A, Assemble("mov edx, 0x60"));

    // Target Base interpolator
    WriteProtected<byte>(0x1463B2914, Assemble("mov edx, 0x100"));
    WriteProtected<byte>(0x1463B28F0, Assemble("mov edx, 0x100"));
    WriteProtected<byte>(0x1463B28A9, Assemble("mov edx, 0x100"));

    // Base Ctor type A
    WriteAsmHook
    (
        "movss dword ptr [rdi + 0xF0], xmm6",

        0x14636EF85,

        HookBehavior.After
    );

    // Base Ctor type B
    WriteAsmHook
    (
        "movss dword ptr [rdi + 0xF0], xmm6",

        0x1400BA9AA,

        HookBehavior.After
    );

    // Linear Ctor
    WriteAsmHook
    (
        "movss dword ptr [rdi + 0x50], xmm6",

        0x1400BA550,

        HookBehavior.After
    );

    // Initialize our value in camera init/reset functions (whatever these are), just to be safe.

    // Base
    WriteAsmHook
    (
        "mov [rdi + 0xF0], eax",

        0x146374FBC,

        HookBehavior.After
    );

    // Linear. This function can't use before/after because of a call being invoked, and a bug with how HMM interprets calls in x64 assembly, potentially.
    WriteAsmHook
    (
        $@"
            ; Prologue
            mov  [rsp + 8], rbx
            push rdi
            sub  rsp, 0x20
            mov  eax, [rcx + 0x20]
            mov  rdi, rcx

            ; Custom data
            mov  [rdi + 0x50], eax

        ",

        0x1400BA8F0,

        HookBehavior.Replace
    );

    // Smoother-step algorithm by Ken Perlin
    // https://en.wikipedia.org/wiki/Smoothstep
    fixed (float* pValue01 = &value01)
    fixed (float* pValue03 = &value03)
    fixed (float* pValue05 = &value05)
    fixed (float* pValue10 = &value10)
    {
        // Base cam update
        WriteAsmHook
        (
            $@"
                movss  xmm2, dword ptr [rcx + 0xF0]
                xorps  xmm0, xmm0
                subss  xmm2, dword ptr [rdx]
                comiss xmm0, xmm2
                movss  dword ptr [rcx + 0xF0], xmm2
                jb     jumpA
                mov    dword ptr [rcx + 0xF0], 0
                xorps  xmm2, xmm2

            jumpA:
                movss  xmm3, dword ptr [rcx + 0xD0]
                comiss xmm3, xmm0
                jbe    jumpB
                divss  xmm2, xmm3
                jmp    jumpC

            jumpB:
                mov    rax, {(long)pValue01}
                movss  xmm2, dword ptr [rax]

            jumpC:
                movaps xmm0, xmm2
                movaps xmm1, xmm2
                mov    rax, {(long)pValue03}
                mulss  xmm0, dword ptr [rax]
                addss  xmm1, xmm2
                mov    rax, {(long)pValue05}
                subss  xmm1, dword ptr [rax]
                mulss  xmm1, xmm0
                movaps xmm0, xmm2
                mulss  xmm0, xmm2
                mov    rax, {(long)pValue10}
                addss  xmm1, dword ptr [rax]
                mulss  xmm0, xmm2
                mulss  xmm1, xmm0
                mulss  xmm1, xmm3
                movss  dword ptr [rcx + 0xD4], xmm1
                ret
            ",

            0x1400BB120,

            HookBehavior.Replace
        );

        // Linear cam update
        WriteAsmHook
        (
            $@"
                movss  xmm2, dword ptr [rcx + 0x50]
                xorps  xmm0, xmm0
                subss  xmm2, dword ptr [rdx]
                comiss xmm0, xmm2
                movss  dword ptr [rcx + 0x50], xmm2
                jb     jumpA
                mov    dword ptr [rcx + 0x50], 0
                xorps  xmm2, xmm2

            jumpA:
                movss  xmm3, dword ptr [rcx + 0x20]
                comiss xmm3, xmm0
                jbe    jumpB
                divss  xmm2, xmm3
                jmp    jumpC

            jumpB:
                mov    rax, {(long)pValue01}
                movss  xmm2, dword ptr [rax]

            jumpC:
                movaps xmm0, xmm2
                movaps xmm1, xmm2
                mov    rax, {(long)pValue03}
                mulss  xmm0, dword ptr [rax]
                addss  xmm1, xmm2
                mov    rax, {(long)pValue05}
                subss  xmm1, dword ptr [rax]
                mulss  xmm1, xmm0
                movaps xmm0, xmm2
                mulss  xmm0, xmm2
                mov    rax, {(long)pValue10}
                addss  xmm1, dword ptr [rax]
                mulss  xmm0, xmm2
                mulss  xmm1, xmm0
                mulss  xmm1, xmm3
                movss  dword ptr [rcx + 0x24], xmm1
                ret
            ",

            0x146365B90,

            HookBehavior.Replace
        );
    }
}

Code "Somersault Landing at High Velocity" in "Animation" by "Hyper" does
/*
Enters Sonic into a somersault state when landing from a moderate height at a high velocity whilst retaining your momentum.

This state lasts a fraction of a second, but keep in mind that within that time, you will be unable to perform certain actions until the animation is complete.
*/
//
    #lib "Bitwise"
    #lib "BlackboardStatus"
    #lib "Sonic"

    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Collections.Generic;

    static Vector3 LastGroundedPosition;

    static List<Sonic.StateID> ExitStates = new()
    {
        Sonic.StateID.StateJump,
        Sonic.StateID.StateRecoveryJump,
        Sonic.StateID.StateFall,
        Sonic.StateID.StateBumpJump,
        Sonic.StateID.StateRecovery
    };

    static float HeightFallen = 0.0f;
    
    static bool IsInitialised = false;
    static bool IsRecoveryJumpCharging = false;
//
{
    if (!IsInitialised)
    {
        fixed (bool* pIsRecoveryJumpCharging = &IsRecoveryJumpCharging)
        {
            WriteAsmHook
            (
                $@"
                    movaps xmmword ptr [rsp + 0x38 + 0xFFFFFFFFFFFFFFE8], xmm6
                    mov    rsi, rcx
                    mov    rcx, {(long)pIsRecoveryJumpCharging}
                    mov    dl, byte ptr [rsi + 0xC4]
                    mov    byte ptr [rcx], dl
                    mov    edx, 0x18
                    mov    rcx, rdi
                ",

                /* 0x1408A0A1D */
                ScanSignature
                (
                    "\x0F\x29\x74\x24\x20\x48\x8B\xF1\xBA\x18\x00\x00\x00",
                    "xxxxxxxxxxxxx"
                ),

                HookBehavior.Replace
            );
        }

        void NotifyStateSpringJumpHeadLandDamageCollision(Sonic.StateID stateId, Sonic.StateID[] stateStackTrace)
        {
            bool isStateSpringJumpHeadLand = stateId == Sonic.StateID.StateSpringJumpHeadLand;
            
            if (isStateSpringJumpHeadLand)
            {
                Sonic.Collision.ToggleEntityCollision(false);
            }
            else if (Sonic.State.GetPreviousStateID() == Sonic.StateID.StateSpringJumpHeadLand)
            {
                Sonic.Collision.ToggleEntityCollision(true);
            }
        }

        Sonic.State.AddStateNotifyAction(NotifyStateSpringJumpHeadLandDamageCollision);

        IsInitialised = true;
    }

    var kinematics = Sonic.Kinematics.Get();

    if (kinematics == null)
        return;

    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateSpringJumpHeadLand)
    {
        if (Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerJump) ||
            Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerAttack))
        {
            // Exit into StateRun.
            Sonic.State.SetState(Sonic.StateID.StateRun);
        }
    }

    if (Sonic.IsGrounded())
    {
        LastGroundedPosition = *kinematics.Position;

        if (!ExitStates.Contains(Sonic.State.GetPreviousStateID()))
            goto Reset;

        if (Sonic.Kinematics.GetHorizontalMagnitude() > 15.0f && HeightFallen >= 5.0f)
        {
            if (BlackboardStatus.Get() != null && Bitwise.Test(*BlackboardStatus.GetStateFlags(), (uint)BlackboardStatus.StateFlags.IsBoost))
            {
                // Allow StateJump to continue running if we're boosting.
                if (Sonic.State.GetPreviousStateID() == Sonic.StateID.StateJump)
                    goto Reset;
            }

            // Allow StateRecoveryJump to enter StateDropDash.
            if (Sonic.State.GetPreviousStateID() == Sonic.StateID.StateRecoveryJump && IsRecoveryJumpCharging)
                goto Reset;

            // Exit into StateSpringJumpHeadLand.
            Sonic.State.SetState(Sonic.StateID.StateSpringJumpHeadLand);
        }
        
    Reset:
        HeightFallen = 0.0f;
    }
    else
    {
        /* Reset position if the player has reached
           apex height and has begun falling again. */
        if ((LastGroundedPosition.Y - kinematics.Position->Y) < HeightFallen)
        {
            LastGroundedPosition = *kinematics.Position;
        }

        HeightFallen = LastGroundedPosition.Y - kinematics.Position->Y;
    }
}

Code "Super Stomp" in "Gameplay" by "Hyper & Yosho" does
/*
Sends a powerful shockwave when landing a stomp from a great height.

Idea by Yosho.
*/
//
    #lib "MathHelpers"
    #lib "Memory"
    #lib "Sonic"

    #load "System.Numerics.dll"

    using System.Numerics;

    static bool IsInitialised = false;
    static bool IsStompBeginPositionPreserved = false;

    static Vector3 StompBeginPosition;

    static float HeightFallen = 0.0f;
    static float HeightThreshold = 15.0f;
    static float Radius = 11.0f;
//
{
    if (!IsInitialised)
    {
        fixed (float* pHeightFallen = &HeightFallen)
        fixed (float* pHeightThreshold = &HeightThreshold)
        {
            /* 0x1408ACA68 */
            long shockwaveCondAddr = ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\x83\xBE\xB0\x00\x00\x00\x02\x48\x8B\xE8",
                "x????xxxxxxxxxx"
            );

            // Set stomp shockwave condition.
            WriteAsmHook
            (
                $@"
                    mov    rax, {Memory.ReadCall(shockwaveCondAddr)}
                    call   rax
                    mov    rbp, {(long)pHeightFallen}
                    movss  xmm8, dword ptr [rbp]
                    mov    rbp, {(long)pHeightThreshold}
                    movss  xmm9, dword ptr [rbp]
                    comiss xmm8, xmm9
                    mov    ebp, dword ptr [rsi + 0xB0] ; preserve stomp bounce count
                    jna    exit
                    mov    dword ptr [rsi + 0xB0], 2   ; force stomp bounce count to meet condition requirements
                exit:
                    cmp    dword ptr [rsi + 0xB0], 2
                    mov    dword ptr [rsi + 0xB0], ebp ; restore stomp bounce count
                    mov    rbp, {(long)pHeightFallen}
                    mov    dword ptr [rbp], 0
                    mov    rbp, rax
                ",

                shockwaveCondAddr,

                HookBehavior.Replace
            );
        }

        fixed (float* pRadius = &Radius)
        {
            /* 0x1408ACA9B */
            long radiusAddr = ScanSignature
            (
                "\xF3\x0F\x10\x55\x1C\xB2\x08",
                "xxxxxxx"
            );

            WriteAsmHook
            (
                $@"
                    mov   rcx, {(long)pRadius}
                    movss xmm2, dword ptr [rcx]
                    mov   dl, 8
                    mov   rcx, rax
                    mov   rax, {Memory.ReadCall(radiusAddr + 0x0A)}
                    call  rax
                ",

                radiusAddr,

                HookBehavior.Replace
            );
        }

        IsInitialised = true;
    }

    var kinematics = Sonic.Kinematics.Get();

    if (kinematics == null)
        return;

    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateStompingDown)
    {
        if (!IsStompBeginPositionPreserved)
        {
            StompBeginPosition = *kinematics.Position;

            IsStompBeginPositionPreserved = true;
        }
        
        HeightFallen = StompBeginPosition.Y - kinematics.Position->Y;

        // 11.0f is the default value for boundStompingCollisionScale.
        Radius = MathHelpers.Clamp(HeightFallen - HeightThreshold, 11.0f, 33.0f);
    }
    else
    {
        IsStompBeginPositionPreserved = false;

        HeightFallen = 0.0f;
    }
}

Patch "Tighter Drop Dash Rotation" in "Physics" by "Hyper" does "Allows for tighter steering whilst rolling for more precise movement."
{
    // steeringSpeed#
    WriteAsmHook
    (
        $@"
            mov dword ptr [rax + 0x20], 0x43C80000 ; 400.0f
            mov dword ptr [rax + 0x24], 0x43480000 ; 200.0f

            ; Restore original code.
            mov   rbx, rax
            movss xmm9, dword ptr [rax + 0x20] ; steeringSpeed1
            movss xmm8, dword ptr [rax + 0x24] ; steeringSpeed2
        ",

        /* 0x1407EC02A */
        ScanSignature
        (
            "\x48\x8B\xD8\xF3\x44\x0F\x10\x48\x20",
            "xxxxxxxxx"
        ),

        HookBehavior.Replace
    );

    // brake
    WriteAsmHook
    (
        $@"
            mov dword ptr [rbx + 0x1C], 0x40200000 ; 2.5f

            ; Restore original code.
            mulss xmm10, dword ptr [rbx + 0x1C]
            lea   rdx, [rbp + 0x57 + 0xFFFFFFFFFFFFFF80]
            mov   rcx, rsi
            subss xmm7, xmm10
        ",

        /* 0x1407EC263 */
        ScanSignature
        (
            "\xF3\x44\x0F\x59\x53\x1C",
            "xxxxxx"
        ),

        HookBehavior.Replace
    );
}

Patch "Tighter Jump Rotation" in "Physics" by "Hyper" does "Allows for tighter mid-air control for more precise movements when jumping, similar to SONIC THE HEDGEHOG (2006)."
//
    static float Threshold = 0.05f;
//
{
    fixed (float* pThreshold = &Threshold)
    {
        WriteAsmHook
        (
            $@"
                push rax

                mov   rax, {(long)pThreshold}
                mulss xmm7, cs:[rax]
                maxss xmm0, xmm6
                mulss xmm0, dword ptr [rsp + 0x140 + 0xFFFFFFFFFFFFFF30]

                pop rax
            ",

            /* 0x1407F562A */
            ScanSignature
            (
                "\xF3\x0F\x59\x3D\xCC\xCC\xCC\xCC\xF3\x0F\x5F\xC6",
                "xxxx????xxxx"
            ),

            HookBehavior.Replace
        );
    }
}

/*---------------------------------------- LARGE LIBRARIES ----------------------------------------*/

Library "CustomMusicParameter"
{
    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public struct CustomMusicTransitInfo
    {
        [FieldOffset(0)] public float fadeOutTime;
        [FieldOffset(4)] public float delayTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct CString
    {
        [FieldOffset(0)] public long pValue;

        public string Value
        {
        	get => Marshal.PtrToStringAnsi((IntPtr)pValue);
        	set => pValue = (long)Marshal.StringToHGlobalAnsi(value);
        }
    }

    public enum MusicType : sbyte
    {
        THEME_SONG = 0,
        OTHER = 1
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public struct CustomMusicInfo
    {
        [FieldOffset(0)]  public CString cueName;
        [FieldOffset(16)] public float fadeOutTiming;
        [FieldOffset(20)] public bool _lock;
        [FieldOffset(21)] public MusicType musicType;
    }

    [StructLayout(LayoutKind.Explicit, Size = 3088)]
    public struct Root
    {
        [FieldOffset(0)]    public CustomMusicTransitInfo transitInfo;
        [FieldOffset(8)]    public unsafe fixed byte /* CustomMusicInfo[128] */ _musicInfos[3072];

        public unsafe CustomMusicInfo* musicInfos
        {
            get
            {
                fixed (byte* p_musicInfos = _musicInfos)
                    return (CustomMusicInfo*)p_musicInfos;
            }
        }

        [FieldOffset(3080)] public float idlingViewTime;
    }
}

Library "SonicParameters"
{
    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public struct PlayerParamOffensive
    {
        [FieldOffset(0)]  public ushort pointMin;
        [FieldOffset(2)]  public ushort pointMax;
        [FieldOffset(4)]  public float damageRandomRate;
        [FieldOffset(8)]  public float damageRandomRateSS;
        [FieldOffset(12)] public float shapeDamageRate;
        [FieldOffset(16)] public float shapeStunRate;
        [FieldOffset(20)] public float shapeStaggerRate;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamDefensive
    {
        [FieldOffset(0)] public byte rateMin;
        [FieldOffset(1)] public byte rateMax;
        [FieldOffset(2)] public ushort infimumDropRings;
    }

    [StructLayout(LayoutKind.Explicit, Size = 44)]
    public struct PlayerParamAttackCommon
    {
        [FieldOffset(0)]  public PlayerParamOffensive offensive;
        [FieldOffset(24)] public PlayerParamDefensive defensive;
        [FieldOffset(28)] public float criticalDamageRate;
        [FieldOffset(32)] public float criticalRate;
        [FieldOffset(36)] public float criticalRateSS;
        [FieldOffset(40)] public float downedDamageRate;
    }

    public enum HitSE : sbyte
    {
        SE_None = -1,
        Weak = 0,
        Strong = 1,
        VeryStrong = 2
    }

    [StructLayout(LayoutKind.Explicit, Size=16)]
    public struct CString
    {
        [FieldOffset(0)] public long pValue;

        public string Value
        {
            get => Marshal.PtrToStringAnsi((IntPtr)pValue);
            set => pValue = (long)Marshal.StringToHGlobalAnsi(value);
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 352)]
    public struct PlayerParamAttackData
    {
        [FieldOffset(0)]   public float damageRate;
        [FieldOffset(4)]   public float damageRateSS;
        [FieldOffset(8)]   public float damageRateAcceleMode;
        [FieldOffset(12)]  public float damageRateManual;
        [FieldOffset(16)]  public float stunPoint;
        [FieldOffset(20)]  public float staggerPoint;
        [FieldOffset(32)]  public Vector3 velocity;
        [FieldOffset(48)]  public float velocityKeepTime;
        [FieldOffset(52)]  public float addComboValue;
        [FieldOffset(56)]  public float addComboValueAccele;
        [FieldOffset(60)]  public float addComboValueSS;
        [FieldOffset(64)]  public float addComboValueAcceleSS;
        [FieldOffset(68)]  public float addQuickCyloopEnergy;
        [FieldOffset(72)]  public float addQuickCyloopEnergyAccele;
        [FieldOffset(76)]  public float addQuickCyloopEnergySS;
        [FieldOffset(80)]  public float addQuickCyloopEnergyAcceleSS;
        [FieldOffset(84)]  public float addQuickCyloopEnergyGuard;
        [FieldOffset(88)]  public float addQuickCyloopEnergyAcceleGuard;
        [FieldOffset(96)]  public Vector3 gimmickVelocity;
        [FieldOffset(112)] public float ignoreTime;
        [FieldOffset(116)] public ushort attributes;
        [FieldOffset(118)] public HitSE se;
        [FieldOffset(120)] public CString hitEffectName;
        [FieldOffset(136)] public CString hitEffectNameSS;
        [FieldOffset(152)] public CString hitStopName;
        [FieldOffset(168)] public CString hitStopNameDead;
        [FieldOffset(184)] public CString hitStopNameDeadBoss;
        [FieldOffset(200)] public CString hitStopNameSS;
        [FieldOffset(216)] public CString hitStopNameDeadSS;
        [FieldOffset(232)] public CString hitCameraShakeName;
        [FieldOffset(248)] public CString hitCameraShakeNameDead;
        [FieldOffset(264)] public CString hitCameraShakeNameDeadBoss;
        [FieldOffset(280)] public CString hitCameraShakeNameSS;
        [FieldOffset(296)] public CString hitCameraShakeNameDeadSS;
        [FieldOffset(312)] public CString hitVibrationName;
        [FieldOffset(328)] public CString hitVibrationNameSS;
    }

    [StructLayout(LayoutKind.Explicit, Size = 15536)]
    public struct PlayerParamAttack
    {
        [FieldOffset(0)]     public PlayerParamAttackCommon common;
        [FieldOffset(48)]    public PlayerParamAttackData spinAttack;
        [FieldOffset(400)]   public PlayerParamAttackData spinDash;
        [FieldOffset(752)]   public PlayerParamAttackData homingAttack;
        [FieldOffset(1104)]  public PlayerParamAttackData homingAttackAir;
        [FieldOffset(1456)]  public PlayerParamAttackData pursuitKick;
        [FieldOffset(1808)]  public PlayerParamAttackData stomping;
        [FieldOffset(2160)]  public PlayerParamAttackData stompingAttack;
        [FieldOffset(2512)]  public PlayerParamAttackData boundStompingLast;
        [FieldOffset(2864)]  public PlayerParamAttackData sliding;
        [FieldOffset(3216)]  public PlayerParamAttackData loopKick;
        [FieldOffset(3568)]  public PlayerParamAttackData crasher;
        [FieldOffset(3920)]  public PlayerParamAttackData spinSlashHoming;
        [FieldOffset(4272)]  public PlayerParamAttackData spinSlash;
        [FieldOffset(4624)]  public PlayerParamAttackData spinSlashLast;
        [FieldOffset(4976)]  public PlayerParamAttackData sonicBoom;
        [FieldOffset(5328)]  public PlayerParamAttackData crossSlash;
        [FieldOffset(5680)]  public PlayerParamAttackData homingShot;
        [FieldOffset(6032)]  public PlayerParamAttackData chargeAttack;
        [FieldOffset(6384)]  public PlayerParamAttackData chargeAttackLast;
        [FieldOffset(6736)]  public PlayerParamAttackData cyloop;
        [FieldOffset(7088)]  public PlayerParamAttackData cyloopQuick;
        [FieldOffset(7440)]  public PlayerParamAttackData cyloopAerial;
        [FieldOffset(7792)]  public PlayerParamAttackData accele1;
        [FieldOffset(8144)]  public PlayerParamAttackData accele2;
        [FieldOffset(8496)]  public PlayerParamAttackData aerialAccele1;
        [FieldOffset(8848)]  public PlayerParamAttackData aerialAccele2;
        [FieldOffset(9200)]  public PlayerParamAttackData comboFinish;
        [FieldOffset(9552)]  public PlayerParamAttackData comboFinishF;
        [FieldOffset(9904)]  public PlayerParamAttackData comboFinishB;
        [FieldOffset(10256)] public PlayerParamAttackData comboFinishL;
        [FieldOffset(10608)] public PlayerParamAttackData comboFinishR;
        [FieldOffset(10960)] public PlayerParamAttackData acceleComboFinish;
        [FieldOffset(11312)] public PlayerParamAttackData acceleComboFinishF;
        [FieldOffset(11664)] public PlayerParamAttackData acceleComboFinishB;
        [FieldOffset(12016)] public PlayerParamAttackData acceleComboFinishL;
        [FieldOffset(12368)] public PlayerParamAttackData acceleComboFinishR;
        [FieldOffset(12720)] public PlayerParamAttackData smash;
        [FieldOffset(13072)] public PlayerParamAttackData smashLast;
        [FieldOffset(13424)] public PlayerParamAttackData slingShot;
        [FieldOffset(13776)] public PlayerParamAttackData knucklesPunch1;
        [FieldOffset(14128)] public PlayerParamAttackData knucklesPunch2;
        [FieldOffset(14480)] public PlayerParamAttackData knucklesUppercut;
        [FieldOffset(14832)] public PlayerParamAttackData amyTarotAttack;
        [FieldOffset(15184)] public PlayerParamAttackData amyTarotRolling;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamWaterAct
    {
        [FieldOffset(0)]  public float resistRate;
        [FieldOffset(4)]  public float breatheBrake;
        [FieldOffset(8)]  public float breatheTime;
        [FieldOffset(12)] public float breatheGravity;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public struct PlayerParamBaseJump
    {
        [FieldOffset(0)]  public float baseSpeed;
        [FieldOffset(4)]  public float upSpeed;
        [FieldOffset(8)]  public float upSpeedAir;
        [FieldOffset(12)] public float edgeSpeed;
        [FieldOffset(16)] public float airActionTime;
        [FieldOffset(20)] public float wallMoveTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public struct PlayerParamBallMove
    {
        [FieldOffset(0)]  public float maxSpeed;
        [FieldOffset(4)]  public float slidePower;
        [FieldOffset(8)]  public float brakeForce;
        [FieldOffset(12)] public float slidePowerSlalom;
        [FieldOffset(16)] public float brakeForceSlalom;
        [FieldOffset(20)] public float releaseSpeed;
        [FieldOffset(24)] public bool useInput;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamLocusData
    {
        [FieldOffset(0)]  public float width;
        [FieldOffset(4)]  public float distance;
        [FieldOffset(8)]  public float u0;
        [FieldOffset(12)] public float u1;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct PlayerParamLocus
    {
        [FieldOffset(0)] public fixed byte /* PlayerParamLocusData[4] */ _data[64];

        public PlayerParamLocusData* data
        {
            get
            {
                fixed (byte* p_data = _data)
                    return (PlayerParamLocusData*)p_data;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamAuraTrain
    {
        [FieldOffset(0)]  public float effectSpanTime;
        [FieldOffset(4)]  public float effectLifeTime;
        [FieldOffset(8)]  public float effectOffsetDistance;
        [FieldOffset(12)] public float effectOverlapDistance;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamLevel
    {
        [FieldOffset(0)] public byte ringsLevel;
        [FieldOffset(1)] public byte speedLevel;
        [FieldOffset(2)] public byte offensiveLevel;
        [FieldOffset(3)] public byte defensiveLevel;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamBarrierWall
    {
        [FieldOffset(0)] public float coolTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamDamageRateLevel
    {
        [FieldOffset(0)] public fixed float rates[5];
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public struct PlayerParamDamageRate
    {
        [FieldOffset(0)] public fixed byte /* PlayerParamDamageRateLevel[4] */ _diffculties[80];

        public PlayerParamDamageRateLevel* diffculties
        {
            get
            {
                fixed (byte* p_diffculties = _diffculties)
                    return (PlayerParamDamageRateLevel*)p_diffculties;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 15776)]
    public struct CommonPackage
    {
        [FieldOffset(0)]     public PlayerParamAttack attack;
        [FieldOffset(15536)] public PlayerParamWaterAct wateract;
        [FieldOffset(15552)] public PlayerParamBaseJump basejump;
        [FieldOffset(15576)] public PlayerParamBallMove ballmove;
        [FieldOffset(15604)] public PlayerParamLocus locus;
        [FieldOffset(15668)] public PlayerParamAuraTrain auratrain;
        [FieldOffset(15684)] public PlayerParamLevel level;
        [FieldOffset(15688)] public PlayerParamBarrierWall barrierWall;
        [FieldOffset(15692)] public PlayerParamDamageRate damageRate;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamAcceleMode
    {
        [FieldOffset(0)]  public float declineSpeed;
        [FieldOffset(4)]  public float declineSpeedAccele;
        [FieldOffset(8)]  public float lossDamaged;
        [FieldOffset(12)] public float lossDamagedAccele;
        [FieldOffset(16)] public uint comboRateAccele;
    }

    public enum Condition : sbyte
    {
        Time = 0,
        Animation = 1
    }

    public enum Shape : sbyte
    {
        Sphere = 0,
        Cylinder = 1,
        Box = 2
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public struct PlayerParamAttackCollider
    {
        [FieldOffset(0)]  public Condition condition;
        [FieldOffset(1)]  public sbyte count;
        [FieldOffset(4)]  public float spanTime;
        [FieldOffset(8)]  public Shape shape;
        [FieldOffset(16)] public Vector3 shapeSize;
        [FieldOffset(32)] public Vector3 shapeOffset;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct PlayerParamAcceleCombo
    {
        [FieldOffset(0)]  public PlayerParamAttackCollider hit;
        [FieldOffset(48)] public float motionSpeedRatio;
        [FieldOffset(52)] public float motionSpeedRatioAccele;
    }

    [StructLayout(LayoutKind.Explicit, Size = 192)]
    public struct PlayerParamAcceleComboSet
    {
        [FieldOffset(0)]   public PlayerParamAcceleCombo sonic;
        [FieldOffset(64)]  public PlayerParamAcceleCombo superSonic1;
        [FieldOffset(128)] public PlayerParamAcceleCombo superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct PlayerParamLoopKick
    {
        [FieldOffset(0)]  public float loopRadius;
        [FieldOffset(4)]  public float loopTime;
        [FieldOffset(8)]  public float loopSpeedCurveRatio;
        [FieldOffset(12)] public float loopEndStopTime;
        [FieldOffset(16)] public float loopEndSpeed;
        [FieldOffset(20)] public float kickSpeed;
        [FieldOffset(24)] public float failSafeTime;
        [FieldOffset(32)] public Vector3 offset;
        [FieldOffset(48)] public CString cameraName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 192)]
    public struct PlayerParamLoopKickSet
    {
        [FieldOffset(0)]   public PlayerParamLoopKick sonic;
        [FieldOffset(64)]  public PlayerParamLoopKick superSonic1;
        [FieldOffset(128)] public PlayerParamLoopKick superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 144)]
    public struct PlayerParamCrasher
    {
        [FieldOffset(0)]   public float startWait;
        [FieldOffset(4)]   public fixed float distanceRatios[5];
        [FieldOffset(24)]  public fixed float angles[5];
        [FieldOffset(44)]  public fixed float radii[5];
        [FieldOffset(64)]  public float distanceMax;
        [FieldOffset(68)]  public float zigzagBeginOneStepTime;
        [FieldOffset(72)]  public float zigzagEndOneStepTime;
        [FieldOffset(76)]  public float crasherSpeed;
        [FieldOffset(80)]  public float failSafeTime;
        [FieldOffset(84)]  public float cameraDistance;
        [FieldOffset(88)]  public float cameraOffsetElevation;
        [FieldOffset(92)]  public float cameraOffsetAzimuth;
        [FieldOffset(96)]  public float cameraRoll;
        [FieldOffset(112)] public Vector3 offset;
        [FieldOffset(128)] public CString cameraName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 432)]
    public struct PlayerParamCrasherSet
    {
        [FieldOffset(0)]   public PlayerParamCrasher sonic;
        [FieldOffset(144)] public PlayerParamCrasher superSonic1;
        [FieldOffset(288)] public PlayerParamCrasher superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 208)]
    public struct PlayerParamSpinSlash
    {
        [FieldOffset(0)]   public PlayerParamAttackCollider hit;
        [FieldOffset(48)]  public PlayerParamAttackCollider hitLast;
        [FieldOffset(96)]  public float chargeTime;
        [FieldOffset(100)] public float homingSpeed;
        [FieldOffset(104)] public float bounceTime;
        [FieldOffset(108)] public float radius;
        [FieldOffset(112)] public float slashTime;
        [FieldOffset(116)] public sbyte numSlashs;
        [FieldOffset(120)] public float angle;
        [FieldOffset(124)] public float lastHitTime;
        [FieldOffset(128)] public float slowRatio0;
        [FieldOffset(132)] public float slowRatio1;
        [FieldOffset(144)] public Vector3 offset;
        [FieldOffset(160)] public CString cameraName;
        [FieldOffset(176)] public CString cameraNamePost;
        [FieldOffset(192)] public CString cameraShakeName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 624)]
    public struct PlayerParamSpinSlashSet
    {
        [FieldOffset(0)]   public PlayerParamSpinSlash sonic;
        [FieldOffset(208)] public PlayerParamSpinSlash superSonic1;
        [FieldOffset(416)] public PlayerParamSpinSlash superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 160)]
    public struct PlayerParamChargeAttack
    {
        [FieldOffset(0)]   public PlayerParamAttackCollider hit;
        [FieldOffset(48)]  public PlayerParamAttackCollider hitLast;
        [FieldOffset(96)]  public float ignoreSwingingTime;
        [FieldOffset(100)] public float riseSlowRatio;
        [FieldOffset(104)] public float riseTime;
        [FieldOffset(108)] public float riseDistance;
        [FieldOffset(112)] public float preRiseDistance;
        [FieldOffset(116)] public float postRiseDistance;
        [FieldOffset(120)] public float lastVelocity;
        [FieldOffset(124)] public float spiralRadius;
        [FieldOffset(128)] public float spiralRadiusEaseInTime;
        [FieldOffset(132)] public float spiralRadiusEaseOutTime;
        [FieldOffset(136)] public float spiralAngularSpeed;
        [FieldOffset(140)] public float lastHitTime;
        [FieldOffset(144)] public CString cameraName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 480)]
    public struct PlayerParamChargeAttackSet
    {
        [FieldOffset(0)]   public PlayerParamChargeAttack sonic;
        [FieldOffset(160)] public PlayerParamChargeAttack superSonic1;
        [FieldOffset(320)] public PlayerParamChargeAttack superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 208)]
    public struct PlayerParamStompingAttack
    {
        [FieldOffset(0)]   public PlayerParamAttackCollider hit;
        [FieldOffset(48)]  public PlayerParamAttackCollider hitLast;
        [FieldOffset(96)]  public float riseTime;
        [FieldOffset(100)] public float flipSpeed;
        [FieldOffset(104)] public float motionTime;
        [FieldOffset(108)] public float lastHitTime;
        [FieldOffset(112)] public float slowRatio;
        [FieldOffset(116)] public float minPressTime;
        [FieldOffset(120)] public float minPressTimeHeight;
        [FieldOffset(124)] public float maxPressTime;
        [FieldOffset(128)] public float maxPressTimeHeight;
        [FieldOffset(144)] public Vector3 offset;
        [FieldOffset(160)] public Vector3 offsetAsura;
        [FieldOffset(176)] public CString cameraName;
        [FieldOffset(192)] public CString cameraNameBarrage;
    }

    [StructLayout(LayoutKind.Explicit, Size = 624)]
    public struct PlayerParamStompingAttackSet
    {
        [FieldOffset(0)]   public PlayerParamStompingAttack sonic;
        [FieldOffset(208)] public PlayerParamStompingAttack superSonic1;
        [FieldOffset(416)] public PlayerParamStompingAttack superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct PlayerParamComboFinish
    {
        [FieldOffset(0)]  public PlayerParamAttackCollider hit;
        [FieldOffset(48)] public float ignoreSwingingTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 192)]
    public struct PlayerParamComboFinishSet
    {
        [FieldOffset(0)]   public PlayerParamComboFinish sonic;
        [FieldOffset(64)]  public PlayerParamComboFinish superSonic1;
        [FieldOffset(128)] public PlayerParamComboFinish superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct PlayerParamSonicBoom
    {
        [FieldOffset(0)]  public float waitTime;
        [FieldOffset(4)]  public float spanTime;
        [FieldOffset(8)]  public float fallSpeed;
        [FieldOffset(12)] public float autoContinueTime;
        [FieldOffset(16)] public float speed;
        [FieldOffset(20)] public float maxSpeed;
        [FieldOffset(24)] public float accele;
        [FieldOffset(28)] public float slowRatio;
        [FieldOffset(32)] public Vector3 offset;
        [FieldOffset(48)] public CString cameraName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 192)]
    public struct PlayerParamSonicBoomSet
    {
        [FieldOffset(0)]   public PlayerParamSonicBoom sonic;
        [FieldOffset(64)]  public PlayerParamSonicBoom superSonic1;
        [FieldOffset(128)] public PlayerParamSonicBoom superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 176)]
    public struct PlayerParamCrossSlash
    {
        [FieldOffset(0)]   public float spanTime;
        [FieldOffset(4)]   public float attackTime;
        [FieldOffset(8)]   public float moveAngle;
        [FieldOffset(12)]  public float stopTime;
        [FieldOffset(16)]  public float slowRatio;
        [FieldOffset(20)]  public float spinPhase;
        [FieldOffset(24)]  public float spinRadius;
        [FieldOffset(28)]  public float spinSpeed;
        [FieldOffset(32)]  public fixed float spawnDelayTime[2];
        [FieldOffset(48)]  public fixed byte /* Vector3[2] */ _spawnLocalTranslation[32];

        public Vector3* spawnLocalTranslation
        {
            get
            {
                fixed (byte* p_spawnLocalTranslation = _spawnLocalTranslation)
                    return (Vector3*)p_spawnLocalTranslation;
            }
        }

        [FieldOffset(80)]  public fixed byte /* Vector3[2] */ _spawnLocalAngle[32];

        public Vector3* spawnLocalAngle
        {
            get
            {
                fixed (byte* p_spawnLocalAngle = _spawnLocalAngle)
                    return (Vector3*)p_spawnLocalAngle;
            }
        }

        [FieldOffset(112)] public float speed;
        [FieldOffset(116)] public float maxSpeed;
        [FieldOffset(120)] public float accele;
        [FieldOffset(128)] public Vector3 offset;
        [FieldOffset(144)] public CString cameraName;
        [FieldOffset(160)] public CString launchCameraShakeName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 528)]
    public struct PlayerParamCrossSlashSet
    {
        [FieldOffset(0)]   public PlayerParamCrossSlash sonic;
        [FieldOffset(176)] public PlayerParamCrossSlash superSonic1;
        [FieldOffset(352)] public PlayerParamCrossSlash superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 144)]
    public struct PlayerParamHomingShot
    {
        [FieldOffset(0)]   public float appearTime;
        [FieldOffset(4)]   public float appearPhaseTime;
        [FieldOffset(8)]   public float spinRadius;
        [FieldOffset(12)]  public float spinSpeed;
        [FieldOffset(16)]  public float spinSpeedPostLaunch;
        [FieldOffset(20)]  public float chargeTime;
        [FieldOffset(24)]  public float spawnTime;
        [FieldOffset(28)]  public float launchPreWaitTime;
        [FieldOffset(32)]  public float spanTime;
        [FieldOffset(36)]  public bool launchRandomize;
        [FieldOffset(40)]  public float launchWaitTime;
        [FieldOffset(44)]  public float beginAngleX;
        [FieldOffset(48)]  public float tangent0;
        [FieldOffset(52)]  public float tangent1;
        [FieldOffset(56)]  public float spiralWaitTime;
        [FieldOffset(60)]  public float spiralAngularSpeed;
        [FieldOffset(64)]  public float spiralAngularSpeedMax;
        [FieldOffset(68)]  public float spiralAngularSpeedAccele;
        [FieldOffset(72)]  public byte numShots;
        [FieldOffset(76)]  public float speed;
        [FieldOffset(80)]  public float maxSpeed;
        [FieldOffset(84)]  public float accele;
        [FieldOffset(88)]  public float whiteoutBeginTime;
        [FieldOffset(92)]  public float whiteoutFadeOutTime;
        [FieldOffset(96)]  public float whiteoutFadingTime;
        [FieldOffset(100)] public float whiteoutFadeInTime;
        [FieldOffset(112)] public Vector3 offset;
        [FieldOffset(128)] public CString cameraName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 432)]
    public struct PlayerParamHomingShotSet
    {
        [FieldOffset(0)]   public PlayerParamHomingShot sonic;
        [FieldOffset(144)] public PlayerParamHomingShot superSonic1;
        [FieldOffset(288)] public PlayerParamHomingShot superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 352)]
    public struct PlayerParamSmash
    {
        [FieldOffset(0)]  public PlayerParamAttackCollider hit1;
        [FieldOffset(48)] public PlayerParamAttackCollider hit2;
        [FieldOffset(96)] public fixed byte /* Vector3[16] */ _offsets[256];

        public Vector3* offsets
        {
            get
            {
                fixed (byte* p_offsets = _offsets)
                    return (Vector3*)p_offsets;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 1056)]
    public struct PlayerParamSmashSet
    {
        [FieldOffset(0)]   public PlayerParamSmash sonic;
        [FieldOffset(352)] public PlayerParamSmash superSonic1;
        [FieldOffset(704)] public PlayerParamSmash superSonic2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamBehind
    {
        [FieldOffset(0)]  public float moveTime;
        [FieldOffset(4)]  public float moveTimeSS;
        [FieldOffset(8)]  public float tangentScale;
        [FieldOffset(12)] public float waitTime;
        [FieldOffset(16)] public float cameraTurnRatio;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamComboCommon
    {
        [FieldOffset(0)] public float longPressTime;
    }

    public enum ComboMoveType : byte
    {
        Homing = 0,
        Step = 1,
        None = 2
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamComboMove
    {
        [FieldOffset(0)]  public ComboMoveType moveType;
        [FieldOffset(4)]  public float moveInitialSpeed;
        [FieldOffset(8)]  public float moveMaxSpeed;
        [FieldOffset(12)] public float moveAccele;
        [FieldOffset(16)] public float timeout;
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public struct PlayerParamComboMoveCorrection
    {
        [FieldOffset(0)] public float moveSpeed;
        [FieldOffset(4)] public float rotateSpeed;
    }

    public enum Action : sbyte
    {
        Root = 0,
        HomingAttack = 1,
        AerialHomingAttack = 2,
        Pursuit = 3,
        Stomping = 4,
        LoopKick = 5,
        Crasher = 6,
        SpinSlash = 7,
        SonicBoom = 8,
        CrossSlash = 9,
        HomingShot = 10,
        ChargeAttack = 11,
        QuickCyloop = 12,
        AerialQuickCyloop = 13,
        AcceleCombo1 = 14,
        AcceleCombo2 = 15,
        AcceleCombo3 = 16,
        AcceleCombo4 = 17,
        AerialAcceleCombo1 = 18,
        AerialAcceleCombo2 = 19,
        AerialAcceleCombo3 = 20,
        AerialAcceleCombo4 = 21,
        ComboFinish = 22,
        SpinJump = 23,
        Smash = 24,
        Behind = 25,
        Guarded = 26,
        Avoid = 27,
        AirBoost = 28,
        AfterAirBoost = 29,
        KnucklesPunch1 = 30,
        KnucklesPunch2 = 31,
        KnucklesUppercut = 32,
        KnucklesCyKnuckle = 33,
        KnucklesHeatKnuckle = 34,
        AmyTarotAttack = 35,
        AmyTarotRolling = 36,
        AmyCyHammer = 37,
        ActionNum = 38
    }

    [StructLayout(LayoutKind.Explicit, Size = 18)]
    public struct PlayerParamComboTransit
    {
        [FieldOffset(0)]  public fixed byte /* Action[6] */ _transitExistTarget[6];

        public Action* transitExistTarget
        {
            get
            {
                fixed (byte* p_transitExistTarget = _transitExistTarget)
                    return (Action*)p_transitExistTarget;
            }
        }

        [FieldOffset(6)]  public fixed byte /* Action[6] */ _transitInAir[6];

        public Action* transitInAir
        {
            get
            {
                fixed (byte* p_transitInAir = _transitInAir)
                    return (Action*)p_transitInAir;
            }
        }

        [FieldOffset(12)] public fixed byte /* Action[6] */ _transitNotExistTarget[6];

        public Action* transitNotExistTarget
        {
            get
            {
                fixed (byte* p_transitNotExistTarget = _transitNotExistTarget)
                    return (Action*)p_transitNotExistTarget;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 630)]
    public struct PlayerParamComboTransitTable
    {
        [FieldOffset(0)]   public PlayerParamComboTransit root;
        [FieldOffset(18)]  public PlayerParamComboTransit homingAttack;
        [FieldOffset(36)]  public PlayerParamComboTransit aerialHoming;
        [FieldOffset(54)]  public PlayerParamComboTransit pursuit;
        [FieldOffset(72)]  public PlayerParamComboTransit stomping;
        [FieldOffset(90)]  public PlayerParamComboTransit loopKick;
        [FieldOffset(108)] public PlayerParamComboTransit crasher;
        [FieldOffset(126)] public PlayerParamComboTransit spinSlash;
        [FieldOffset(144)] public PlayerParamComboTransit sonicBoom;
        [FieldOffset(162)] public PlayerParamComboTransit crossSlash;
        [FieldOffset(180)] public PlayerParamComboTransit homingShot;
        [FieldOffset(198)] public PlayerParamComboTransit chargeAttack;
        [FieldOffset(216)] public PlayerParamComboTransit quickCyloop;
        [FieldOffset(234)] public PlayerParamComboTransit aerialQuickCyloop;
        [FieldOffset(252)] public PlayerParamComboTransit acceleCombo1;
        [FieldOffset(270)] public PlayerParamComboTransit acceleCombo2;
        [FieldOffset(288)] public PlayerParamComboTransit acceleCombo3;
        [FieldOffset(306)] public PlayerParamComboTransit acceleCombo4;
        [FieldOffset(324)] public PlayerParamComboTransit aerialAcceleCombo1;
        [FieldOffset(342)] public PlayerParamComboTransit aerialAcceleCombo2;
        [FieldOffset(360)] public PlayerParamComboTransit aerialAcceleCombo3;
        [FieldOffset(378)] public PlayerParamComboTransit aerialAcceleCombo4;
        [FieldOffset(396)] public PlayerParamComboTransit behind;
        [FieldOffset(414)] public PlayerParamComboTransit guarded;
        [FieldOffset(432)] public PlayerParamComboTransit avoid;
        [FieldOffset(450)] public PlayerParamComboTransit airBoost;
        [FieldOffset(468)] public PlayerParamComboTransit afterAirBoost;
        [FieldOffset(486)] public PlayerParamComboTransit knucklesPunch1;
        [FieldOffset(504)] public PlayerParamComboTransit knucklesPunch2;
        [FieldOffset(522)] public PlayerParamComboTransit knucklesUppercut;
        [FieldOffset(540)] public PlayerParamComboTransit knucklesCyKnuckle;
        [FieldOffset(558)] public PlayerParamComboTransit knucklesHeatKnuckle;
        [FieldOffset(576)] public PlayerParamComboTransit amyTarotAttack;
        [FieldOffset(594)] public PlayerParamComboTransit amyTarotRolling;
        [FieldOffset(612)] public PlayerParamComboTransit amyCyHammer;
    }

    [StructLayout(LayoutKind.Explicit, Size = 684)]
    public struct PlayerParamCombo
    {
        [FieldOffset(0)]  public PlayerParamComboCommon common;
        [FieldOffset(4)]  public PlayerParamComboMove comboMoveSonic;
        [FieldOffset(24)] public PlayerParamComboMove comboMoveSupersonic;
        [FieldOffset(44)] public PlayerParamComboMoveCorrection comboMoveCorrection;
        [FieldOffset(52)] public PlayerParamComboTransitTable comboTable;
    }

    [StructLayout(LayoutKind.Explicit, Size = 88)]
    public struct CyloopSlashEffectBaseParameter
    {
        [FieldOffset(0)]  public int m_divideCircle;
        [FieldOffset(4)]  public float m_circleRadius;
        [FieldOffset(8)]  public float m_circleWaveCycle;
        [FieldOffset(12)] public float m_circleWaveWidth;
        [FieldOffset(16)] public float m_circleWaveSpeed;
        [FieldOffset(20)] public Vector2 m_scale;
        [FieldOffset(32)] public CString m_textureName;
        [FieldOffset(48)] public float m_flowSpeed;
        [FieldOffset(52)] public float m_twistCycle;
        [FieldOffset(56)] public float m_rollCycle;
        [FieldOffset(60)] public float m_rollPhase;
        [FieldOffset(64)] public float m_alphaHeadDistance;
        [FieldOffset(68)] public float m_alphaTailDistance;
        [FieldOffset(72)] public float m_offsetCycle;
        [FieldOffset(76)] public float m_offsetPhase;
        [FieldOffset(80)] public float m_offsetRadius;
    }

    public struct ColorF
    {
        public float A;
        public float R;
        public float G;
        public float B;
    }

    [StructLayout(LayoutKind.Explicit, Size = 168)]
    public struct CyloopTransparentLocusParameter
    {
        [FieldOffset(0)]   public CyloopSlashEffectBaseParameter cyloopSlashEffectBaseParameter;
        [FieldOffset(88)]  public ColorF m_color0;
        [FieldOffset(104)] public ColorF m_color1;
        [FieldOffset(120)] public float m_luminance;
        [FieldOffset(124)] public ColorF m_flashColor0;
        [FieldOffset(140)] public ColorF m_flashColor1;
        [FieldOffset(156)] public float m_flashLuminance;
        [FieldOffset(160)] public float m_flashTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public struct OpaqueLineUvCell
    {
        [FieldOffset(0)] public float scale;
        [FieldOffset(4)] public float speedX;
        [FieldOffset(8)] public float speedY;
    }

    [StructLayout(LayoutKind.Explicit, Size = 160)]
    public struct CyloopOpaqueLocusParameter
    {
        [FieldOffset(0)]   public CyloopSlashEffectBaseParameter cyloopSlashEffectBaseParameter;
        [FieldOffset(88)]  public ColorF m_color;
        [FieldOffset(104)] public float m_alphaThreshold;
        [FieldOffset(108)] public fixed byte /* OpaqueLineUvCell[2] */ _m_uvCells[24];

        public OpaqueLineUvCell* m_uvCells
        {
            get
            {
                fixed (byte* p_m_uvCells = _m_uvCells)
                    return (OpaqueLineUvCell*)p_m_uvCells;
            }
        }

        [FieldOffset(132)] public float m_uvLineScaleX;
        [FieldOffset(136)] public float m_uvLineScaleY;
        [FieldOffset(140)] public ColorF m_flashColor;
        [FieldOffset(156)] public float m_flashTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 240)]
    public struct CyloopCrossLineParameter
    {
        [FieldOffset(0)]   public CString m_textureNamePattern;
        [FieldOffset(16)]  public CString m_textureNameDist;
        [FieldOffset(32)]  public ColorF startColor;
        [FieldOffset(48)]  public ColorF endColor;
        [FieldOffset(64)]  public float startColorLuminance;
        [FieldOffset(68)]  public float endColorLuminance;
        [FieldOffset(72)]  public ColorF startColorFlash;
        [FieldOffset(88)]  public ColorF endColorFlash;
        [FieldOffset(104)] public float startColorLuminanceFlash;
        [FieldOffset(108)] public float endColorLuminanceFlash;
        [FieldOffset(112)] public float flashTime;
        [FieldOffset(116)] public float patternDepth;
        [FieldOffset(120)] public float patternScrollSpeed;
        [FieldOffset(124)] public float patternDarkness;
        [FieldOffset(128)] public float patternScale;
        [FieldOffset(132)] public float glitchResX;
        [FieldOffset(136)] public float glitchResY;
        [FieldOffset(140)] public float glitchOffset;
        [FieldOffset(144)] public float glitchMaxLength;
        [FieldOffset(148)] public float startGlitchScrollSpeed;
        [FieldOffset(152)] public float startGlitchChangeSpeed;
        [FieldOffset(156)] public float startGlitchShift;
        [FieldOffset(160)] public float startGlitchContrust;
        [FieldOffset(164)] public float endGlitchScrollSpeed;
        [FieldOffset(168)] public float endGlitchChangeSpeed;
        [FieldOffset(172)] public float endGlitchShift;
        [FieldOffset(176)] public float endGlitchContrust;
        [FieldOffset(180)] public float lineWidth;
        [FieldOffset(184)] public float lineDisplayWidth;
        [FieldOffset(188)] public float lineBlackEdgeWidth;
        [FieldOffset(192)] public float lineBlackEdgeIntensity;
        [FieldOffset(196)] public float lineBlackEdgeNormalFade;
        [FieldOffset(200)] public float distNoiseScale;
        [FieldOffset(204)] public float distLowNoiseScale;
        [FieldOffset(208)] public float distHighNoiseScale;
        [FieldOffset(212)] public float distNoiseRate;
        [FieldOffset(216)] public float distScrollSpeed;
        [FieldOffset(220)] public float distIntensity;
        [FieldOffset(224)] public float dissolve;
        [FieldOffset(228)] public float dissolveRate;
        [FieldOffset(232)] public float heightOffset;
    }

    [StructLayout(LayoutKind.Explicit, Size = 1248)]
    public struct CyloopLocusParameter
    {
        [FieldOffset(0)]    public int m_numTransparentLines;
        [FieldOffset(8)]    public fixed byte /* CyloopTransparentLocusParameter[3] */ _m_transparentLines[504];

        public CyloopTransparentLocusParameter* m_transparentLines
        {
            get
            {
                fixed (byte* p_m_transparentLines = _m_transparentLines)
                    return (CyloopTransparentLocusParameter*)p_m_transparentLines;
            }
        }

        [FieldOffset(512)]  public int m_numOpaqueLines;
        [FieldOffset(520)]  public fixed byte /* CyloopOpaqueLocusParameter[3] */ _m_opaqueLines[480];

        public CyloopOpaqueLocusParameter* m_opaqueLines
        {
            get
            {
                fixed (byte* p_m_opaqueLines = _m_opaqueLines)
                    return (CyloopOpaqueLocusParameter*)p_m_opaqueLines;
            }
        }

        [FieldOffset(1000)] public int m_numCrossLines;
        [FieldOffset(1008)] public CyloopCrossLineParameter m_crossline;
    }

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public struct CyloopDropItemWeightParameter
    {
        [FieldOffset(0)]  public uint noneWeight;
        [FieldOffset(4)]  public uint ring10Weight;
        [FieldOffset(8)]  public uint powerSeedWeight;
        [FieldOffset(12)] public uint guardSeedWeight;
        [FieldOffset(16)] public uint sequenceItemWeight;
        [FieldOffset(20)] public uint portalBitWeight;
        [FieldOffset(24)] public uint skillPieceWeight;
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public struct CyloopDropItemParameter
    {
        [FieldOffset(0)]  public CyloopDropItemWeightParameter weight;
        [FieldOffset(28)] public CyloopDropItemWeightParameter weight2;
        [FieldOffset(56)] public uint numRings;
        [FieldOffset(60)] public uint numRings2;
        [FieldOffset(64)] public uint num10Rings;
        [FieldOffset(68)] public uint numSkillPieces;
        [FieldOffset(72)] public uint skillPieceExp;
        [FieldOffset(76)] public float rareDropCoolTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct CyloopShapeWindCountParameter
    {
        [FieldOffset(0)]  public float damageRate;
        [FieldOffset(4)]  public float stunRate;
        [FieldOffset(8)]  public float staggerRate;
        [FieldOffset(12)] public float velocityRate;
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public struct CyloopShapeWindEffectParaemter
    {
        [FieldOffset(0)] public fixed byte /* CyloopShapeWindCountParameter[5] */ _param[80];

        public CyloopShapeWindCountParameter* param
        {
            get
            {
                fixed (byte* p_param = _param)
                    return (CyloopShapeWindCountParameter*)p_param;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public struct CyloopShapeEffectParameter
    {
        [FieldOffset(0)] public CyloopShapeWindEffectParaemter wind;
    }

    [StructLayout(LayoutKind.Explicit, Size = 5184)]
    public struct PlayerParamCyloop
    {
        [FieldOffset(0)]    public CyloopLocusParameter locus;
        [FieldOffset(1248)] public CyloopLocusParameter locusQuick;
        [FieldOffset(2496)] public CyloopLocusParameter locusSuperSonic;
        [FieldOffset(3744)] public CyloopLocusParameter locusSuperSonicQuick;
        [FieldOffset(4992)] public ColorF auraColor;
        [FieldOffset(5008)] public CyloopDropItemParameter dropItem;
        [FieldOffset(5088)] public float needSpeed;
        [FieldOffset(5092)] public CyloopShapeEffectParameter shapeEffect;
        [FieldOffset(5172)] public float lossQuickCyloopEnergy;
        [FieldOffset(5176)] public float recoveryQuickCyloopEnergyByTime;
        [FieldOffset(5180)] public float recoveryQuickCyloopEnergyByTimeInMinigame;
    }

    public enum Part : sbyte
    {
        PunchR = 0,
        PunchL = 1,
        KickR = 2,
        KickL = 3
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public struct PlayerParamSuperSonicShapeAttackData
    {
        [FieldOffset(0)]  public CString name;
        [FieldOffset(16)] public Part part;
        [FieldOffset(32)] public Vector3 begin;
        [FieldOffset(48)] public Vector3 end;
        [FieldOffset(64)] public float scale;
        [FieldOffset(68)] public float roll;
        [FieldOffset(72)] public float moveTime;
        [FieldOffset(76)] public float fadeoutTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 2576)]
    public struct PlayerParamSuperSonic
    {
        [FieldOffset(0)]  public int numRings;
        [FieldOffset(4)]  public float decreaseSec;
        [FieldOffset(8)]  public float inletRadius;
        [FieldOffset(12)] public float moveSoundSpeed;
        [FieldOffset(16)] public fixed byte /* PlayerParamSuperSonicShapeAttackData[32] */ _shapeEffects[2560];

        public PlayerParamSuperSonicShapeAttackData* shapeEffects
        {
            get
            {
                fixed (byte* p_shapeEffects = _shapeEffects)
                    return (PlayerParamSuperSonicShapeAttackData*)p_shapeEffects;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public struct PlayerParamSandSki
    {
        [FieldOffset(0)]  public float blowDeceleForce;
        [FieldOffset(4)]  public float blowDeceleForceOnGround;
        [FieldOffset(8)]  public float blowGravityScale;
        [FieldOffset(12)] public float blowTransitTime;
        [FieldOffset(16)] public float blowDownTime;
        [FieldOffset(20)] public float pylonBlowUpSize;
        [FieldOffset(24)] public float pylonBlowSpeed;
        [FieldOffset(32)] public CString pylonHitStop;
    }

    public enum CameraShakeTiming : sbyte
    {
        StartCameraInterpolation = 0,
        EndCameraInterpolation = 1
    }

    [StructLayout(LayoutKind.Explicit, Size = 96)]
    public struct PlayerParamSlingshot
    {
        [FieldOffset(0)]  public float timeScaleInMove;
        [FieldOffset(4)]  public float hitStartRestTime;
        [FieldOffset(16)] public Vector3 hitCameraOffset;
        [FieldOffset(32)] public float hitCameraTimeEaseIn;
        [FieldOffset(36)] public float hitCameraFovyAngle;
        [FieldOffset(40)] public float hitTimeScaleValue;
        [FieldOffset(44)] public float hitTimeScaleTimeEaseIn;
        [FieldOffset(48)] public float resetCameraEaseOutTime;
        [FieldOffset(52)] public float resetTimeScaleEaseOutTime;
        [FieldOffset(56)] public float timeScaleKeepTime;
        [FieldOffset(60)] public float shotEffOffset;
        [FieldOffset(64)] public float hitEffOffset;
        [FieldOffset(68)] public CameraShakeTiming cameraShakeTiming;
        [FieldOffset(72)] public CString cameraShakeName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamRunawayBee
    {
        [FieldOffset(0)]  public float meanderCycle;
        [FieldOffset(4)]  public float meanderAngle;
        [FieldOffset(8)]  public float minSpeed;
        [FieldOffset(12)] public float maxSpeed;
        [FieldOffset(16)] public float time;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamRunWithKodamaParam
    {
        [FieldOffset(0)]  public int numKodamas;
        [FieldOffset(4)]  public float initialSpeed;
        [FieldOffset(8)]  public float minSpeed;
        [FieldOffset(12)] public float maxSpeed;
        [FieldOffset(16)] public float jumpForce;
    }

    [StructLayout(LayoutKind.Explicit, Size = 168)]
    public struct PlayerParamRunWithKodama
    {
        [FieldOffset(0)] public int maxKodamas;
        [FieldOffset(4)] public float gravitySize;
        [FieldOffset(8)] public fixed byte /* PlayerParamRunWithKodamaParam[8] */ __params[160];

        public PlayerParamRunWithKodamaParam* _params
        {
            get
            {
                fixed (byte* p__params = __params)
                    return (PlayerParamRunWithKodamaParam*)p__params;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 29552)]
    public struct CommonPackageSonic
    {
        [FieldOffset(0)]     public CommonPackage commonPackage;
        [FieldOffset(15776)] public PlayerParamAcceleMode acceleMode;
        [FieldOffset(15808)] public PlayerParamAcceleComboSet acceleComboSet;
        [FieldOffset(16000)] public PlayerParamLoopKickSet loopKickSet;
        [FieldOffset(16192)] public PlayerParamCrasherSet crasherSet;
        [FieldOffset(16624)] public PlayerParamSpinSlashSet spinSlashSet;
        [FieldOffset(17248)] public PlayerParamChargeAttackSet chargeAtackSet;
        [FieldOffset(17728)] public PlayerParamStompingAttackSet stompingAttackSet;
        [FieldOffset(18352)] public PlayerParamComboFinishSet comboFinishSet;
        [FieldOffset(18544)] public PlayerParamSonicBoomSet sonicboomSet;
        [FieldOffset(18736)] public PlayerParamCrossSlashSet crossSlashSet;
        [FieldOffset(19264)] public PlayerParamHomingShotSet homingShotSet;
        [FieldOffset(19696)] public PlayerParamSmashSet smashSet;
        [FieldOffset(20752)] public PlayerParamBehind behind;
        [FieldOffset(20772)] public PlayerParamCombo combo;
        [FieldOffset(21456)] public PlayerParamCyloop cyloop;
        [FieldOffset(26640)] public PlayerParamSuperSonic supersonic;
        [FieldOffset(29216)] public PlayerParamSandSki sandski;
        [FieldOffset(29264)] public PlayerParamSlingshot slingshot;
        [FieldOffset(29360)] public PlayerParamRunawayBee runawayBee;
        [FieldOffset(29380)] public PlayerParamRunWithKodama runWithKodama;
    }

    public enum SupportedPlane : sbyte
    {
        Flat = 0,
        Slope = 1,
        Wall = 2
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public struct PlayerParamCommon
    {
        [FieldOffset(0)]  public float movableMaxSlope;
        [FieldOffset(4)]  public float activeLandingSlope;
        [FieldOffset(8)]  public float activeLandingSlopeInBoost;
        [FieldOffset(12)] public float landingMaxSlope;
        [FieldOffset(16)] public float slidingMaxSlope;
        [FieldOffset(20)] public float wallAngleMaxSlope;
        [FieldOffset(24)] public SupportedPlane onStand;
        [FieldOffset(25)] public SupportedPlane onRunInAir;
        [FieldOffset(26)] public SupportedPlane onRun;
        [FieldOffset(27)] public bool moveHolding;
        [FieldOffset(28)] public bool wallSlideSlowInBoost;
        [FieldOffset(29)] public bool attrWallOnGround;
        [FieldOffset(32)] public float priorityInputTime;
        [FieldOffset(36)] public int capacityRings;
        [FieldOffset(40)] public int capacityRingsLvMax;
        [FieldOffset(44)] public float collectRingRange;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamSpeedData
    {
        [FieldOffset(0)]  public float initial;
        [FieldOffset(4)]  public float min;
        [FieldOffset(8)]  public float max;
        [FieldOffset(12)] public float minTurn;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamSpeedAcceleData
    {
        [FieldOffset(0)]  public float force;
        [FieldOffset(4)]  public float force2;
        [FieldOffset(8)]  public float damperRange;
        [FieldOffset(12)] public float jerkMin;
        [FieldOffset(16)] public float jerkMax;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamSpeedAcceleData2
    {
        [FieldOffset(0)]  public float force;
        [FieldOffset(4)]  public float damperRange;
        [FieldOffset(8)]  public float jerkMin;
        [FieldOffset(12)] public float jerkMax;
    }

    [StructLayout(LayoutKind.Explicit, Size = 224)]
    public struct PlayerParamSpeed
    {
        [FieldOffset(0)]   public PlayerParamSpeedData normal;
        [FieldOffset(16)]  public PlayerParamSpeedData normal2;
        [FieldOffset(32)]  public PlayerParamSpeedData boost;
        [FieldOffset(48)]  public PlayerParamSpeedData boost2;
        [FieldOffset(64)]  public PlayerParamSpeedData boostLvMax;
        [FieldOffset(80)]  public PlayerParamSpeedData boostLvMax2;
        [FieldOffset(96)]  public float maxSpeedOver;
        [FieldOffset(100)] public float opitonMaxSpeedLimitMin;
        [FieldOffset(104)] public float opitonMaxSpeedLimitMax;
        [FieldOffset(108)] public float thresholdStopSpeed;
        [FieldOffset(112)] public float maxFallSpeed;
        [FieldOffset(116)] public PlayerParamSpeedAcceleData accele;
        [FieldOffset(136)] public PlayerParamSpeedAcceleData decele;
        [FieldOffset(156)] public PlayerParamSpeedAcceleData2 deceleNeutralMin;
        [FieldOffset(172)] public PlayerParamSpeedAcceleData2 deceleNeutralMax;
        [FieldOffset(188)] public float acceleAuto;
        [FieldOffset(192)] public float deceleAuto;
        [FieldOffset(196)] public float turnDeceleAngleMin;
        [FieldOffset(200)] public float turnDeceleAngleMax;
        [FieldOffset(204)] public float maxGravityAccele;
        [FieldOffset(208)] public float maxGravityDecele;
        [FieldOffset(212)] public float deceleSquat;
        [FieldOffset(216)] public float acceleSensitive;
        [FieldOffset(220)] public float boostAnimSpeedInWater;
    }

    [StructLayout(LayoutKind.Explicit, Size = 44)]
    public struct PlayerParamRotation
    {
        [FieldOffset(0)]  public float baseRotateForce;
        [FieldOffset(4)]  public float baseRotateForce2;
        [FieldOffset(8)]  public float baseRotateForceSpeed;
        [FieldOffset(12)] public float minRotateForce;
        [FieldOffset(16)] public float maxRotateForce;
        [FieldOffset(20)] public bool angleRotateForceDecayEnabled;
        [FieldOffset(24)] public float frontRotateRatio;
        [FieldOffset(28)] public float rotationForceDecaySpeed;
        [FieldOffset(32)] public float rotationForceDecayRate;
        [FieldOffset(36)] public float rotationForceDecayMax;
        [FieldOffset(40)] public float autorunRotateForce;
    }

    [StructLayout(LayoutKind.Explicit, Size = 52)]
    public struct PlayerParamRunning
    {
        [FieldOffset(0)]  public float walkSpeed;
        [FieldOffset(4)]  public float sneakingSpeed;
        [FieldOffset(8)]  public float animSpeedSneak;
        [FieldOffset(12)] public float animSpeedWalk;
        [FieldOffset(16)] public float animSpeedRun;
        [FieldOffset(20)] public float animSpeedBoost;
        [FieldOffset(24)] public float animLRBlendSampleTime;
        [FieldOffset(28)] public float animLRBlendAngleMin;
        [FieldOffset(32)] public float animLRBlendAngleMax;
        [FieldOffset(36)] public float animLRBlendSpeed;
        [FieldOffset(40)] public float animLRBlendSpeedToCenter;
        [FieldOffset(44)] public float minChangeWalkTime;
        [FieldOffset(48)] public float fallAnimationAngle;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamBalanceData
    {
        [FieldOffset(0)]  public float rotateSpeedMinFB;
        [FieldOffset(4)]  public float rotateSpeedMaxFB;
        [FieldOffset(8)]  public float rotateSpeedMinLR;
        [FieldOffset(12)] public float rotateSpeedMaxLR;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamBalance
    {
        [FieldOffset(0)]  public PlayerParamBalanceData standard;
        [FieldOffset(16)] public PlayerParamBalanceData loop;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public struct PlayerParamBrake
    {
        [FieldOffset(0)]  public float initialSpeedRatio;
        [FieldOffset(4)]  public float maxSpeed;
        [FieldOffset(8)]  public float forceLand;
        [FieldOffset(12)] public float forceAir;
        [FieldOffset(16)] public float endSpeed;
        [FieldOffset(20)] public float stopTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamTurn
    {
        [FieldOffset(0)]  public float thresholdSpeed;
        [FieldOffset(4)]  public float thresholdAngle;
        [FieldOffset(8)]  public float turnAfterSpeed;
        [FieldOffset(12)] public bool stopEdge;
    }

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public struct PlayerParamJump
    {
        [FieldOffset(0)]  public float preActionTime;
        [FieldOffset(4)]  public float longPressTime;
        [FieldOffset(8)]  public float addForceTime;
        [FieldOffset(12)] public float force;
        [FieldOffset(16)] public float addForce;
        [FieldOffset(20)] public float forceMin;
        [FieldOffset(24)] public float gravitySize;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public struct PlayerParamJumpSpeed
    {
        [FieldOffset(0)]  public float acceleForce;
        [FieldOffset(4)]  public float deceleForce;
        [FieldOffset(8)]  public float deceleNeutralForce;
        [FieldOffset(12)] public float deceleBackForce;
        [FieldOffset(16)] public float limitMin;
        [FieldOffset(20)] public float limitUpSpeed;
        [FieldOffset(24)] public float rotationForce;
        [FieldOffset(28)] public float rotationForceDecaySpeed;
        [FieldOffset(32)] public float rotationForceDecayRate;
        [FieldOffset(36)] public float rotationForceDecayMax;
        [FieldOffset(40)] public float baseAirDragScaleMin;
        [FieldOffset(44)] public float baseAirDragScaleMax;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public struct PlayerParamDoubleJump
    {
        [FieldOffset(0)] public float initialSpeed;
        [FieldOffset(4)] public float bounceSpeed;
        [FieldOffset(8)] public float limitSpeedMin;
    }

    [StructLayout(LayoutKind.Explicit, Size = 44)]
    public struct PlayerParamFall
    {
        [FieldOffset(0)]  public float thresholdVertSpeed;
        [FieldOffset(4)]  public float tolerateJumpTime;
        [FieldOffset(8)]  public float fallEndDelayTime;
        [FieldOffset(12)] public float fallEndFadeTime;
        [FieldOffset(16)] public float acceleForce;
        [FieldOffset(20)] public float deceleForce;
        [FieldOffset(24)] public float overSpeedDeceleForce;
        [FieldOffset(28)] public float rotationForce;
        [FieldOffset(32)] public float rotationForceDecaySpeed;
        [FieldOffset(36)] public float rotationForceDecayRate;
        [FieldOffset(40)] public float rotationForceDecayMax;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamDamageCommon
    {
        [FieldOffset(0)] public float invincibleTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamDamageNormal
    {
        [FieldOffset(0)]  public float initialHorzSpeed;
        [FieldOffset(4)]  public float initialVertSpeed;
        [FieldOffset(8)]  public float deceleForce;
        [FieldOffset(12)] public float transitFallTime;
        [FieldOffset(16)] public float gravityScale;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamDamageTurnBack
    {
        [FieldOffset(0)] public float fixedTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public struct PlayerParamDamageBlowOff
    {
        [FieldOffset(0)]  public float initialHorzSpeed;
        [FieldOffset(4)]  public float initialVertSpeed;
        [FieldOffset(8)]  public float deceleForceInAir;
        [FieldOffset(12)] public float deceleForceOnGround;
        [FieldOffset(16)] public float gravityScale;
        [FieldOffset(20)] public float downTime;
        [FieldOffset(24)] public float transitTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamDamageGuarded
    {
        [FieldOffset(0)]  public float vertSpeed;
        [FieldOffset(4)]  public float horzSpeed;
        [FieldOffset(8)]  public float deceleForce;
        [FieldOffset(12)] public float transitTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamDamageRunning
    {
        [FieldOffset(0)]  public float actionTime;
        [FieldOffset(4)]  public float minSpeed;
        [FieldOffset(8)]  public float lossSpeed;
        [FieldOffset(12)] public float lossTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamDamageQuake
    {
        [FieldOffset(0)] public float actionTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamDamageLava
    {
        [FieldOffset(0)]  public Vector3 jumpVelocity;
        [FieldOffset(16)] public float gravitySize;
        [FieldOffset(20)] public float invincibleTime;
        [FieldOffset(24)] public float noActionTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 144)]
    public struct PlayerParamDamage
    {
        [FieldOffset(0)]   public PlayerParamDamageCommon common;
        [FieldOffset(4)]   public PlayerParamDamageNormal normal;
        [FieldOffset(24)]  public PlayerParamDamageTurnBack turnBack;
        [FieldOffset(28)]  public PlayerParamDamageBlowOff blowOff;
        [FieldOffset(56)]  public PlayerParamDamageGuarded guarded;
        [FieldOffset(72)]  public PlayerParamDamageGuarded guardedSS;
        [FieldOffset(88)]  public PlayerParamDamageRunning running;
        [FieldOffset(104)] public PlayerParamDamageQuake quake;
        [FieldOffset(112)] public PlayerParamDamageLava lava;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public struct PlayerParamDeadNormal
    {
        [FieldOffset(0)] public float invincibleTime;
        [FieldOffset(4)] public float initialHorzSpeed;
        [FieldOffset(8)] public float initialVertSpeed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public struct PlayerParamDead
    {
        [FieldOffset(0)] public PlayerParamDeadNormal normal;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct PlayerParamSliding
    {
        [FieldOffset(0)]  public float minSpeed;
        [FieldOffset(4)]  public float endSpeed;
        [FieldOffset(8)]  public float deceleJerk;
        [FieldOffset(12)] public float deceleJerkContinue;
        [FieldOffset(16)] public float deceleForceMax;
        [FieldOffset(20)] public float baseRotateForce;
        [FieldOffset(24)] public float baseRotateForceSpeed;
        [FieldOffset(28)] public float maxRotateForce;
        [FieldOffset(32)] public float frontRotateRatio;
        [FieldOffset(36)] public float rotationForceAutoRun;
        [FieldOffset(40)] public float movableMaxSlope;
        [FieldOffset(44)] public float gravitySize;
        [FieldOffset(48)] public float minContinueTime;
        [FieldOffset(52)] public float maxAutoRunTime;
        [FieldOffset(56)] public float endSpeedAutoRun;
        [FieldOffset(60)] public float loopKickTransitTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamStomping
    {
        [FieldOffset(0)]  public float initialSpeed;
        [FieldOffset(4)]  public float initialAccele;
        [FieldOffset(8)]  public float maxAccele;
        [FieldOffset(12)] public float jerk;
        [FieldOffset(16)] public float maxFallSpeed;
        [FieldOffset(20)] public float angle;
        [FieldOffset(24)] public float landingCancelTime;
        [FieldOffset(28)] public float boundStompingCollisionScale;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamGrind
    {
        [FieldOffset(0)]  public float maxSpeed;
        [FieldOffset(4)]  public float maxBoostSpeed;
        [FieldOffset(8)]  public float acceleForce;
        [FieldOffset(12)] public float deceleForce;
        [FieldOffset(16)] public float limitSpeedMin;
    }

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public struct PlayerParamFallSlope
    {
        [FieldOffset(0)]  public float initialSpeed;
        [FieldOffset(4)]  public float maxSpeed;
        [FieldOffset(8)]  public float brakeAngle;
        [FieldOffset(12)] public float highBrakeAngle;
        [FieldOffset(16)] public float brakeForce;
        [FieldOffset(20)] public float brakeForceHigh;
        [FieldOffset(24)] public float gravitySize;
        [FieldOffset(28)] public float gravitySizeAir;
        [FieldOffset(32)] public float endSpeedFront;
        [FieldOffset(36)] public float endSpeedBack;
        [FieldOffset(40)] public float reverseFallTime;
        [FieldOffset(44)] public float fallToSlipTime;
        [FieldOffset(48)] public float slipIdlingTime;
        [FieldOffset(52)] public float minSlipTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public struct PlayerParamFallFlip
    {
        [FieldOffset(0)] public float thresholdSpeed;
        [FieldOffset(4)] public float maxSpeed;
        [FieldOffset(8)] public float flipAngle;
    }

    [StructLayout(LayoutKind.Explicit, Size = 104)]
    public struct PlayerParamTumble
    {
        [FieldOffset(0)]   public bool enabled;
        [FieldOffset(4)]   public float sideSpinAngle;
        [FieldOffset(8)]   public float initialVertSpeed;
        [FieldOffset(12)]  public float gravitySize;
        [FieldOffset(16)]  public float gravitySize2;
        [FieldOffset(20)]  public float deceleForceInAir;
        [FieldOffset(24)]  public float minSpeedInAir;
        [FieldOffset(28)]  public float rotateEaseTimeLeftRight;
        [FieldOffset(32)]  public float rotateEaseTimeFrontBack;
        [FieldOffset(36)]  public float rotateSpeedMinLeftRight;
        [FieldOffset(40)]  public float rotateSpeedMaxLeftRight;
        [FieldOffset(44)]  public float rotateSpeedMinFrontBack;
        [FieldOffset(48)]  public float rotateSpeedMaxFrontBack;
        [FieldOffset(52)]  public float angleLeftRightStagger;
        [FieldOffset(56)]  public float angleLeftRightRoll;
        [FieldOffset(60)]  public float angleFrontBackRoll;
        [FieldOffset(64)]  public float angleBigRoll;
        [FieldOffset(68)]  public float inRunTime;
        [FieldOffset(72)]  public float inAirTime;
        [FieldOffset(76)]  public float rollSpeedFront;
        [FieldOffset(80)]  public float bigRollVelocityRatio;
        [FieldOffset(84)]  public float dropDashHoldTime;
        [FieldOffset(88)]  public float airBrakeVertSpeed;
        [FieldOffset(92)]  public float airBrakeForce;
        [FieldOffset(96)]  public float airTrickHeight;
        [FieldOffset(100)] public float airTrickTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamSpinAttack
    {
        [FieldOffset(0)]  public float jumpForce;
        [FieldOffset(4)]  public float jumpAddForce;
        [FieldOffset(8)]  public float addTime;
        [FieldOffset(12)] public float acceleForce;
        [FieldOffset(16)] public float deceleForce;
        [FieldOffset(20)] public float brakeForce;
        [FieldOffset(24)] public float limitSpeedMin;
        [FieldOffset(28)] public float limitSpeedMax;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamHomingAttackData
    {
        [FieldOffset(0)] public float speed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamHomingBounceData
    {
        [FieldOffset(0)]  public float bounceVertSpeed;
        [FieldOffset(4)]  public float bounceHorzSpeed;
        [FieldOffset(8)]  public float bounceAcceleForce;
        [FieldOffset(12)] public float bounceDeceleForce;
        [FieldOffset(16)] public float bounceAngleWidth;
        [FieldOffset(20)] public float bounceTime;
        [FieldOffset(24)] public float attackDownTime;
        [FieldOffset(28)] public float attackDownTimeForStomp;
    }

    [StructLayout(LayoutKind.Explicit, Size = 176)]
    public struct PlayerParamHomingAttack
    {
        [FieldOffset(0)]   public PlayerParamHomingAttackData sonic;
        [FieldOffset(4)]   public PlayerParamHomingAttackData supersonic;
        [FieldOffset(8)]   public PlayerParamHomingBounceData sonicBounce;
        [FieldOffset(40)]  public PlayerParamHomingBounceData sonicBounceWeak;
        [FieldOffset(72)]  public PlayerParamHomingBounceData sonicBounceStorm;
        [FieldOffset(104)] public PlayerParamHomingBounceData sonicBounceStormSwirl;
        [FieldOffset(136)] public PlayerParamHomingBounceData supersonicBounce;
        [FieldOffset(168)] public float cameraEaseInTime;
        [FieldOffset(172)] public float cameraEaseOutTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamHitEnemy
    {
        [FieldOffset(0)]  public float bounceVertSpeed;
        [FieldOffset(4)]  public float bounceHorzSpeed;
        [FieldOffset(8)]  public float attackDownTime;
        [FieldOffset(12)] public float enableHomingTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct SpeedParam
    {
        [FieldOffset(0)]  public float maxVertSpeed;
        [FieldOffset(4)]  public float acceleVertForce;
        [FieldOffset(8)]  public float maxHorzSpeed;
        [FieldOffset(12)] public float acceleHorzForce;
    }

    [StructLayout(LayoutKind.Explicit, Size = 92)]
    public struct PlayerParamDiving
    {
        [FieldOffset(0)]  public SpeedParam normal;
        [FieldOffset(16)] public SpeedParam fast;
        [FieldOffset(32)] public SpeedParam damaged;
        [FieldOffset(48)] public SpeedParam ringdash;
        [FieldOffset(64)] public float startHeight;
        [FieldOffset(68)] public float startSpeed;
        [FieldOffset(72)] public float deceleVertForce;
        [FieldOffset(76)] public float deceleHorzForce;
        [FieldOffset(80)] public float deceleNeutralForce;
        [FieldOffset(84)] public float damageTime;
        [FieldOffset(88)] public float ringdashTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public struct PlayerParamFan
    {
        [FieldOffset(0)]  public float damperV;
        [FieldOffset(4)]  public float damperH;
        [FieldOffset(8)]  public float accelRate;
        [FieldOffset(12)] public float moveForceFV;
        [FieldOffset(16)] public float moveForceSV;
        [FieldOffset(20)] public float jumpCheckSpeed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public struct PlayerParamBackflip
    {
        [FieldOffset(0)]  public float jumpSpeed;
        [FieldOffset(4)]  public float backSpeed;
        [FieldOffset(8)]  public float downAccel;
        [FieldOffset(12)] public float damperV;
        [FieldOffset(16)] public float damperH;
        [FieldOffset(20)] public float time;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamSlowMove
    {
        [FieldOffset(0)]  public float startSpeed;
        [FieldOffset(4)]  public float maxSpeed;
        [FieldOffset(8)]  public float accel;
        [FieldOffset(12)] public float brake;
        [FieldOffset(16)] public float damageSpeed;
        [FieldOffset(20)] public float damageBrake;
        [FieldOffset(24)] public float steeringSpeed;
        [FieldOffset(28)] public float endSteeringSpeed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamSpin
    {
        [FieldOffset(0)]  public float startSlopeAngle;
        [FieldOffset(4)]  public float endSlopeAngle;
        [FieldOffset(8)]  public float startSpeed;
        [FieldOffset(12)] public float endSpeed;
        [FieldOffset(16)] public float stickAngle;
        [FieldOffset(20)] public float brake;
        [FieldOffset(24)] public float forceBrake;
        [FieldOffset(28)] public float maxSpeed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 136)]
    public struct PlayerParamWallMove
    {
        [FieldOffset(0)]   public float maxSpeed;
        [FieldOffset(4)]   public float walkSpeed;
        [FieldOffset(8)]   public float walkSpeedMax;
        [FieldOffset(12)]  public float runSpeed;
        [FieldOffset(16)]  public float runSpeedMax;
        [FieldOffset(20)]  public float walkSpeedOnMesh;
        [FieldOffset(24)]  public float walkSpeedOnMeshMax;
        [FieldOffset(28)]  public float runSpeedOnMesh;
        [FieldOffset(32)]  public float runSpeedOnMeshMax;
        [FieldOffset(36)]  public float minAccessSpeed;
        [FieldOffset(40)]  public float stickSpeed;
        [FieldOffset(44)]  public float gravity;
        [FieldOffset(48)]  public float accel;
        [FieldOffset(52)]  public float brake;
        [FieldOffset(56)]  public float stopBrake;
        [FieldOffset(60)]  public float fallSpeed;
        [FieldOffset(64)]  public float steeringSpeed1;
        [FieldOffset(68)]  public float steeringSpeed2;
        [FieldOffset(72)]  public float startSteeringSpeed;
        [FieldOffset(76)]  public float endSteeringSpeed;
        [FieldOffset(80)]  public float startTime;
        [FieldOffset(84)]  public float useEnergySpeedBase;
        [FieldOffset(88)]  public float useEnergySpeedBaseOnMesh;
        [FieldOffset(92)]  public float useEnergySpeedVal;
        [FieldOffset(96)]  public float useEnergySpeedValOnMesh;
        [FieldOffset(100)] public float useEnergyAngle;
        [FieldOffset(104)] public float useEnergyAngleOnMesh;
        [FieldOffset(108)] public float brakeStartEnergy;
        [FieldOffset(112)] public float brakeStartEnergyOnMesh;
        [FieldOffset(116)] public float homingSearchDistanceNear;
        [FieldOffset(120)] public float homingSearchDistanceFar;
        [FieldOffset(124)] public float wallBumpHeightUpper;
        [FieldOffset(128)] public float wallBumpHeightUnder;
        [FieldOffset(132)] public float recoveryCheckTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 36)]
    public struct PlayerParamWallJump
    {
        [FieldOffset(0)]  public float gravitySize;
        [FieldOffset(4)]  public float minTime;
        [FieldOffset(8)]  public float maxTime;
        [FieldOffset(12)] public float stopTime;
        [FieldOffset(16)] public float maxDownSpeed;
        [FieldOffset(20)] public float fallGroundDistance;
        [FieldOffset(24)] public float frontForce;
        [FieldOffset(28)] public float upForce;
        [FieldOffset(32)] public float impulseTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 84)]
    public struct PlayerParamClimbing
    {
        [FieldOffset(0)]  public float stepSpeedFront;
        [FieldOffset(4)]  public float stepSpeedFrontDash;
        [FieldOffset(8)]  public float stepSpeedSide;
        [FieldOffset(12)] public float stepSpeedSideDash;
        [FieldOffset(16)] public float stepSpeedBack;
        [FieldOffset(20)] public float stepDashRate;
        [FieldOffset(24)] public float maxAnimSpeed;
        [FieldOffset(28)] public float exhaustAngle;
        [FieldOffset(32)] public float exhaustAngleOnMesh;
        [FieldOffset(36)] public float exhaustBase;
        [FieldOffset(40)] public float exhaustBaseOnMesh;
        [FieldOffset(44)] public float exhaustRate;
        [FieldOffset(48)] public float exhaustRateOnMesh;
        [FieldOffset(52)] public float useGrabGaugeSpeed;
        [FieldOffset(56)] public float useGrabGaugeSpeedOnMesh;
        [FieldOffset(60)] public float useGrabGaugeTurbo;
        [FieldOffset(64)] public float useGrabGaugeTurboOnMesh;
        [FieldOffset(68)] public float homingSearchDistanceNear;
        [FieldOffset(72)] public float homingSearchDistanceFar;
        [FieldOffset(76)] public float resetAngle;
        [FieldOffset(80)] public float recoveryCheckTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public struct PlayerParamSlideDown
    {
        [FieldOffset(0)]  public float time;
        [FieldOffset(4)]  public float speed;
        [FieldOffset(8)]  public float speedOnMesh;
        [FieldOffset(12)] public float accel;
        [FieldOffset(16)] public float brake;
        [FieldOffset(20)] public float brakeOnMesh;
    }

    [StructLayout(LayoutKind.Explicit, Size = 60)]
    public struct PlayerParamBoost
    {
        [FieldOffset(0)]  public float consumptionRate;
        [FieldOffset(4)]  public float consumptionRateSS;
        [FieldOffset(8)]  public float recoveryRate;
        [FieldOffset(12)] public float recoveryRateSS;
        [FieldOffset(16)] public float reigniteRatio;
        [FieldOffset(20)] public float recoveryByRing;
        [FieldOffset(24)] public float recoveryByAttack;
        [FieldOffset(28)] public fixed float blurPowers[3];
        [FieldOffset(40)] public float blurEaseInTime;
        [FieldOffset(44)] public float blurEaseOutTime;
        [FieldOffset(48)] public float endSpeed;
        [FieldOffset(52)] public float powerBoostCoolTime;
        [FieldOffset(56)] public float infinityBoostTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 52)]
    public struct PlayerParamAirBoost
    {
        [FieldOffset(0)]  public float startHSpeed;
        [FieldOffset(4)]  public float startHSpeedMax;
        [FieldOffset(8)]  public float startVSpeed;
        [FieldOffset(12)] public float minHSpeed;
        [FieldOffset(16)] public float minHSpeedMax;
        [FieldOffset(20)] public float brakeTime;
        [FieldOffset(24)] public float minKeepTime;
        [FieldOffset(28)] public float maxKeepTime;
        [FieldOffset(32)] public float maxTime;
        [FieldOffset(36)] public float gravityRate;
        [FieldOffset(40)] public float steeringSpeed;
        [FieldOffset(44)] public float additionalTransitTime;
        [FieldOffset(48)] public float supersonicTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamAutorun
    {
        [FieldOffset(0)]  public float initialSideSpeed;
        [FieldOffset(4)]  public float acceleSideForce;
        [FieldOffset(8)]  public float deceleSideForce;
        [FieldOffset(12)] public float maxSideSpeed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamSideStep
    {
        [FieldOffset(0)]  public float speed;
        [FieldOffset(4)]  public float brakeForce;
        [FieldOffset(8)]  public float motionSpeedRatio;
        [FieldOffset(12)] public float stepSpeed;
        [FieldOffset(16)] public float maxStepDistance;
        [FieldOffset(20)] public float minStepDistance;
        [FieldOffset(24)] public float maxStepSpeed;
        [FieldOffset(28)] public float minStepSpeed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamSideStep2
    {
        [FieldOffset(0)]  public float speed;
        [FieldOffset(4)]  public float brakeForce;
        [FieldOffset(8)]  public float motionSpeedRatio;
        [FieldOffset(12)] public float stepSpeed;
        [FieldOffset(16)] public float maxStepDistance;
        [FieldOffset(20)] public float minStepDistance;
        [FieldOffset(24)] public float maxStepSpeed;
        [FieldOffset(28)] public float minStepSpeed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 36)]
    public struct PlayerParamQuickStep
    {
        [FieldOffset(0)]  public float needSpeed;
        [FieldOffset(4)]  public float acceleForce;
        [FieldOffset(8)]  public float acceleSideForce;
        [FieldOffset(12)] public float stepInitialSpeed;
        [FieldOffset(16)] public float avoidForce;
        [FieldOffset(20)] public float justBoostForce;
        [FieldOffset(24)] public float justBoostMax;
        [FieldOffset(28)] public float justBoostTime;
        [FieldOffset(32)] public float justBoostBrake;
    }

    [StructLayout(LayoutKind.Explicit, Size = 36)]
    public struct PlayerParamParry
    {
        [FieldOffset(0)]  public float minRecieveTime;
        [FieldOffset(4)]  public float maxRecieveTime;
        [FieldOffset(8)]  public float frozenTime;
        [FieldOffset(12)] public float justEffectEasein;
        [FieldOffset(16)] public float justEffectEaseout;
        [FieldOffset(20)] public float justEffectTime;
        [FieldOffset(24)] public float justEffectEasein2;
        [FieldOffset(28)] public float justEffectEaseout2;
        [FieldOffset(32)] public float justEffectTime2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct PlayerParamAvoidData
    {
        [FieldOffset(0)]  public float speed;
        [FieldOffset(4)]  public float damper;
        [FieldOffset(8)]  public float parryTime;
        [FieldOffset(12)] public float invincibleTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 148)]
    public struct PlayerParamAvoid
    {
        [FieldOffset(0)]   public float time;
        [FieldOffset(4)]   public float fixedTime;
        [FieldOffset(8)]   public float reentryInputPriorityTime;
        [FieldOffset(12)]  public float reentryTime;
        [FieldOffset(16)]  public float frontAngle;
        [FieldOffset(20)]  public float backAngle;
        [FieldOffset(24)]  public float addFallSpeed;
        [FieldOffset(28)]  public fixed byte /* PlayerParamAvoidData[7] */ _data[112];

        public PlayerParamAvoidData* data
        {
            get
            {
                fixed (byte* p_data = _data)
                    return (PlayerParamAvoidData*)p_data;
            }
        }

        [FieldOffset(140)] public float baseDistance;
        [FieldOffset(144)] public float limitAngle;
    }

    [StructLayout(LayoutKind.Explicit, Size = 2144)]
    public struct ModePackage
    {
        [FieldOffset(0)]    public PlayerParamCommon common;
        [FieldOffset(48)]   public PlayerParamSpeed speed;
        [FieldOffset(272)]  public PlayerParamRotation rotation;
        [FieldOffset(316)]  public PlayerParamRunning running;
        [FieldOffset(368)]  public PlayerParamBalance balance;
        [FieldOffset(400)]  public PlayerParamBrake brake;
        [FieldOffset(424)]  public PlayerParamTurn turn;
        [FieldOffset(440)]  public PlayerParamJump jump;
        [FieldOffset(468)]  public PlayerParamJumpSpeed jumpSpeed;
        [FieldOffset(516)]  public PlayerParamDoubleJump doubleJump;
        [FieldOffset(528)]  public PlayerParamFall fall;
        [FieldOffset(576)]  public PlayerParamDamage damage;
        [FieldOffset(720)]  public PlayerParamDead dead;
        [FieldOffset(732)]  public PlayerParamSliding sliding;
        [FieldOffset(796)]  public PlayerParamStomping stomping;
        [FieldOffset(828)]  public PlayerParamGrind grind;
        [FieldOffset(848)]  public PlayerParamFallSlope fallSlope;
        [FieldOffset(904)]  public PlayerParamFallFlip fallFlip;
        [FieldOffset(916)]  public PlayerParamTumble tumble;
        [FieldOffset(1020)] public PlayerParamSpinAttack spinAttack;
        [FieldOffset(1052)] public PlayerParamHomingAttack homingAttack;
        [FieldOffset(1228)] public PlayerParamHitEnemy hitEnemy;
        [FieldOffset(1244)] public PlayerParamDiving diving;
        [FieldOffset(1336)] public PlayerParamFan fan;
        [FieldOffset(1360)] public PlayerParamBackflip backflip;
        [FieldOffset(1384)] public PlayerParamSlowMove slowmove;
        [FieldOffset(1416)] public PlayerParamSpin spin;
        [FieldOffset(1448)] public PlayerParamWallMove wallmove;
        [FieldOffset(1584)] public PlayerParamWallJump walljump;
        [FieldOffset(1620)] public PlayerParamClimbing climbing;
        [FieldOffset(1704)] public PlayerParamSlideDown slidedown;
        [FieldOffset(1728)] public PlayerParamBoost boost;
        [FieldOffset(1788)] public PlayerParamAirBoost airboost;
        [FieldOffset(1840)] public PlayerParamAutorun autorun;
        [FieldOffset(1856)] public PlayerParamSideStep sidestep;
        [FieldOffset(1888)] public PlayerParamSideStep2 sidestep2;
        [FieldOffset(1920)] public PlayerParamQuickStep quickstep;
        [FieldOffset(1956)] public PlayerParamParry parry;
        [FieldOffset(1992)] public PlayerParamAvoid avoid;
    }

    [StructLayout(LayoutKind.Explicit, Size = 68)]
    public struct PlayerParamStorm
    {
        [FieldOffset(0)]  public float damperV;
        [FieldOffset(4)]  public float damperH;
        [FieldOffset(8)]  public float brake;
        [FieldOffset(12)] public float accelRate;
        [FieldOffset(16)] public float moveForce;
        [FieldOffset(20)] public float maxSpeedH;
        [FieldOffset(24)] public float maxSpeedV;
        [FieldOffset(28)] public float rotateSpeed;
        [FieldOffset(32)] public float rotateAngularSpeed;
        [FieldOffset(36)] public float minDrawSpeed;
        [FieldOffset(40)] public float maxDrawSpeed;
        [FieldOffset(44)] public float minDrawSpeedDistance;
        [FieldOffset(48)] public float maxDrawSpeedDistance;
        [FieldOffset(52)] public float damageTime;
        [FieldOffset(56)] public float damageNoBrakeTime;
        [FieldOffset(60)] public float forceHomingReaction;
        [FieldOffset(64)] public float forceHomingReaction2;
    }

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public struct PlayerParamCloudJump
    {
        [FieldOffset(0)]  public float acceleForce;
        [FieldOffset(4)]  public float deceleForce;
        [FieldOffset(8)]  public float overSpeedDeceleForce;
        [FieldOffset(12)] public float rotationForce;
        [FieldOffset(16)] public float rotationForceDecaySpeed;
        [FieldOffset(20)] public float rotationForceDecayRate;
        [FieldOffset(24)] public float rotationForceDecayMax;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamAquaBall
    {
        [FieldOffset(0)]  public float fallAccel;
        [FieldOffset(4)]  public float damper;
        [FieldOffset(8)]  public float jumpSpeed;
        [FieldOffset(12)] public float stompingSpeed;
        [FieldOffset(16)] public float boundSpeed;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct PlayerParamSlider
    {
        [FieldOffset(0)]  public float frontAccel;
        [FieldOffset(4)]  public float frontBrake;
        [FieldOffset(8)]  public float sideBrake;
        [FieldOffset(12)] public float damageBrake;
        [FieldOffset(16)] public float defaultRotateSpeed;
        [FieldOffset(20)] public float rotateSpeed;
        [FieldOffset(24)] public float rotateSpeedAir;
        [FieldOffset(28)] public float gravity;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct PlayerParamAirTrick
    {
        [FieldOffset(0)] public uint amount;
    }

    [StructLayout(LayoutKind.Explicit, Size = 104)]
    public struct PlayerParamDrift
    {
        [FieldOffset(0)]   public float startAngle;
        [FieldOffset(4)]   public float endSpeed;
        [FieldOffset(8)]   public float minSpeed;
        [FieldOffset(12)]  public float minSpeedMax;
        [FieldOffset(16)]  public float maxSpeed;
        [FieldOffset(20)]  public float maxSpeedMax;
        [FieldOffset(24)]  public float minBoostSpeed;
        [FieldOffset(28)]  public float minBoostSpeedMax;
        [FieldOffset(32)]  public float maxBoostSpeed;
        [FieldOffset(36)]  public float maxBoostSpeedMax;
        [FieldOffset(40)]  public float accel;
        [FieldOffset(44)]  public float brake;
        [FieldOffset(48)]  public float maxSteerAngle;
        [FieldOffset(52)]  public float steerAccel;
        [FieldOffset(56)]  public float maxSteerSpeed;
        [FieldOffset(60)]  public float neutralSteerAccel;
        [FieldOffset(64)]  public float maxNeutralSteerSpeed;
        [FieldOffset(68)]  public float maxRotateSpeed;
        [FieldOffset(72)]  public float recoverTime;
        [FieldOffset(76)]  public float maxChargeTime;
        [FieldOffset(80)]  public float minDashSpeed;
        [FieldOffset(84)]  public float maxDashSpeed;
        [FieldOffset(88)]  public float minDashJumpSpeed;
        [FieldOffset(92)]  public float maxDashJumpSpeed;
        [FieldOffset(96)]  public float jumpSpeed;
        [FieldOffset(100)] public float checkFallTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 52)]
    public struct PlayerParamDriftAir
    {
        [FieldOffset(0)]  public float startAngle;
        [FieldOffset(4)]  public float endSpeed;
        [FieldOffset(8)]  public float minSpeed;
        [FieldOffset(12)] public float maxSpeed;
        [FieldOffset(16)] public float accel;
        [FieldOffset(20)] public float brake;
        [FieldOffset(24)] public float maxSteerAngle;
        [FieldOffset(28)] public float steerAccel;
        [FieldOffset(32)] public float maxSteerSpeed;
        [FieldOffset(36)] public float neutralSteerAccel;
        [FieldOffset(40)] public float maxNeutralSteerSpeed;
        [FieldOffset(44)] public float maxRotateSpeed;
        [FieldOffset(48)] public float recoverTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 36)]
    public struct PlayerParamDriftDash
    {
        [FieldOffset(0)]  public float maxSpeed;
        [FieldOffset(4)]  public float brake;
        [FieldOffset(8)]  public float steeringSpeed1;
        [FieldOffset(12)] public float steeringSpeed2;
        [FieldOffset(16)] public float startSteeringSpeed;
        [FieldOffset(20)] public float endSteeringSpeed;
        [FieldOffset(24)] public float outOfControlSpeed;
        [FieldOffset(28)] public float checkDashSpeed;
        [FieldOffset(32)] public float checkDashTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 112)]
    public struct PlayerParamBoarding
    {
        [FieldOffset(0)]   public float maxSpeed;
        [FieldOffset(4)]   public float minSpeed;
        [FieldOffset(8)]   public float damageSpeed;
        [FieldOffset(12)]  public float accel;
        [FieldOffset(16)]  public float damageBrake;
        [FieldOffset(20)]  public float damageBrakeTime;
        [FieldOffset(24)]  public float damageMotionTime;
        [FieldOffset(28)]  public float damageInvicibleTime;
        [FieldOffset(32)]  public float damper;
        [FieldOffset(36)]  public float airDamperV;
        [FieldOffset(40)]  public float airDamperH;
        [FieldOffset(44)]  public float gravity;
        [FieldOffset(48)]  public float airJumpSpeed;
        [FieldOffset(52)]  public float groundJumpSpeed;
        [FieldOffset(56)]  public float airAccel;
        [FieldOffset(60)]  public float maxAirAddSpeed;
        [FieldOffset(64)]  public float downForceRate;
        [FieldOffset(68)]  public float steeringSpeed1;
        [FieldOffset(72)]  public float steeringSpeed2;
        [FieldOffset(76)]  public float steeringSpeed3;
        [FieldOffset(80)]  public float startSteeringSpeed;
        [FieldOffset(84)]  public float endSteeringSpeed;
        [FieldOffset(88)]  public float startSpeed;
        [FieldOffset(92)]  public float startSlope;
        [FieldOffset(96)]  public float staticStartSlope;
        [FieldOffset(100)] public float finishSlope;
        [FieldOffset(104)] public float finishTime;
        [FieldOffset(108)] public float bigLandTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 60)]
    public struct PlayerParamDropDash
    {
        [FieldOffset(0)]  public float maxChargeTime;
        [FieldOffset(4)]  public float minDashSpeed;
        [FieldOffset(8)]  public float minDashSpeedMax;
        [FieldOffset(12)] public float maxDashSpeed;
        [FieldOffset(16)] public float maxDashSpeedMax;
        [FieldOffset(20)] public float tumbleDashSpeed;
        [FieldOffset(24)] public float maxSpeed;
        [FieldOffset(28)] public float brake;
        [FieldOffset(32)] public float steeringSpeed1;
        [FieldOffset(36)] public float steeringSpeed2;
        [FieldOffset(40)] public float startSteeringSpeed;
        [FieldOffset(44)] public float endSteeringSpeed;
        [FieldOffset(48)] public float outOfControlSpeed;
        [FieldOffset(52)] public float checkDashSpeed;
        [FieldOffset(56)] public float checkDashTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public struct PlayerParamBounceJump
    {
        [FieldOffset(0)]  public float startSpeed;
        [FieldOffset(4)]  public float jumpRate1;
        [FieldOffset(8)]  public float jumpRate2;
        [FieldOffset(12)] public float jumpRate3;
        [FieldOffset(16)] public float inoperableTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public struct PlayerParamLightDash
    {
        [FieldOffset(0)]  public float dashSpeed;
        [FieldOffset(4)]  public float dashSpeedMax;
        [FieldOffset(8)]  public float speed;
        [FieldOffset(12)] public float speedMax;
        [FieldOffset(16)] public float accel;
        [FieldOffset(20)] public float brake;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public struct PlayerParamSpinDash
    {
        [FieldOffset(0)] public float time;
        [FieldOffset(4)] public float minSpeed;
        [FieldOffset(8)] public float deceleForce;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct PlayerParamSpinBoostSpeed
    {
        [FieldOffset(0)]  public float initialSpeed;
        [FieldOffset(4)]  public float maxSpeed;
        [FieldOffset(8)]  public PlayerParamSpeedAcceleData accele;
        [FieldOffset(28)] public PlayerParamSpeedAcceleData decele;
        [FieldOffset(48)] public float baseRotateForce;
        [FieldOffset(52)] public float minTurnSpeed;
        [FieldOffset(56)] public float turnDeceleAngleMin;
        [FieldOffset(60)] public float turnDeceleAngleMax;
    }

    public enum AirAccelMode : sbyte
    {
        Alawys = 0,
        AirAccelMode_None = 1,
        Speed = 2
    }

    [StructLayout(LayoutKind.Explicit, Size = 248)]
    public struct PlayerParamSpinBoost
    {
        [FieldOffset(0)]   public float forceRunTime;
        [FieldOffset(4)]   public float initialRunTime;
        [FieldOffset(8)]   public PlayerParamSpinBoostSpeed speedBall;
        [FieldOffset(72)]  public PlayerParamSpinBoostSpeed speedBoost;
        [FieldOffset(136)] public PlayerParamSpeedAcceleData2 deceleNeutralMin;
        [FieldOffset(152)] public PlayerParamSpeedAcceleData2 deceleNeutralMax;
        [FieldOffset(168)] public float gravitySize;
        [FieldOffset(172)] public float gravityBeginTime;
        [FieldOffset(176)] public float gravityMaxTime;
        [FieldOffset(180)] public float gravitySizeMinInAir;
        [FieldOffset(184)] public float gravitySizeMaxInAir;
        [FieldOffset(188)] public float maxGravityAccele;
        [FieldOffset(192)] public float maxGravityDecele;
        [FieldOffset(196)] public float inAirTime;
        [FieldOffset(200)] public float spinBoostEndSpeed;
        [FieldOffset(204)] public float jumpOutAngle;
        [FieldOffset(208)] public float jumpOutSpeed;
        [FieldOffset(212)] public bool humpJumpOut;
        [FieldOffset(213)] public AirAccelMode airAccelMode;
        [FieldOffset(216)] public float airAccelVertSpeedThreshold;
        [FieldOffset(220)] public float chargeRotateForce;
        [FieldOffset(224)] public float chargeRotateForceMinAngle;
        [FieldOffset(228)] public float chargeRotateForceMaxAngle;
        [FieldOffset(232)] public CString cameraShakeName;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct PlayerParamFly
    {
        [FieldOffset(0)]  public float maxSpeed;
        [FieldOffset(4)]  public float maxDashSpeed;
        [FieldOffset(8)]  public float accel;
        [FieldOffset(12)] public float dashAccel;
        [FieldOffset(16)] public float brake;
        [FieldOffset(20)] public float minRotateSpeed;
        [FieldOffset(24)] public float maxRotateSpeed;
        [FieldOffset(28)] public float blowOffTime;
        [FieldOffset(32)] public float blowOffAngle;
        [FieldOffset(36)] public float turnBrake;
        [FieldOffset(40)] public float turnRotateSpeed;
        [FieldOffset(44)] public float quickTurnThresholdAngle;
        [FieldOffset(48)] public float quickTurnStartSpeed;
        [FieldOffset(52)] public float quickTurnBrake;
        [FieldOffset(56)] public float quickTurnRotateSpeed;
        [FieldOffset(60)] public float comboTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 52)]
    public struct PlayerParamLimitedFly
    {
        [FieldOffset(0)]  public float maxSpeed1D;
        [FieldOffset(4)]  public float accel1D;
        [FieldOffset(8)]  public float brake1D;
        [FieldOffset(12)] public float fixAccel1D;
        [FieldOffset(16)] public float fixSpeed1D;
        [FieldOffset(20)] public float fixAccelQuick;
        [FieldOffset(24)] public float fixSpeedQuick;
        [FieldOffset(28)] public float rotateSpeed1D;
        [FieldOffset(32)] public float maxSpeed2D;
        [FieldOffset(36)] public float accel2D;
        [FieldOffset(40)] public float brake2D;
        [FieldOffset(44)] public float fixSpeed2D;
        [FieldOffset(48)] public float rotateSpeed2D;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public struct PlayerParamCyberMode
    {
        [FieldOffset(0)]  public float lowGravityScale;
        [FieldOffset(4)]  public float timeScale;
        [FieldOffset(8)]  public float accelForce;
        [FieldOffset(12)] public float jerk;
        [FieldOffset(16)] public float maxSpeedThreshold;
        [FieldOffset(20)] public float recoveryRate;
        [FieldOffset(24)] public float animalMinSpeed;
        [FieldOffset(28)] public float animalMaxSpeed;
        [FieldOffset(32)] public float animalInitialSpeed;
        [FieldOffset(36)] public float animalMinTurnSpeed;
        [FieldOffset(40)] public float animalJumpForce;
        [FieldOffset(44)] public float animalGravitySize;
    }

    [StructLayout(LayoutKind.Explicit, Size = 3136)]
    public struct ModePackageSonic
    {
        [FieldOffset(0)]    public ModePackage modePackage;
        [FieldOffset(2144)] public PlayerParamStorm storm;
        [FieldOffset(2212)] public PlayerParamCloudJump cloudJump;
        [FieldOffset(2240)] public PlayerParamAquaBall aquaball;
        [FieldOffset(2260)] public PlayerParamSlider slider;
        [FieldOffset(2292)] public PlayerParamAirTrick airtrick;
        [FieldOffset(2296)] public PlayerParamDrift drift;
        [FieldOffset(2400)] public PlayerParamDriftAir driftair;
        [FieldOffset(2452)] public PlayerParamDriftDash driftDash;
        [FieldOffset(2488)] public PlayerParamBoarding boarding;
        [FieldOffset(2600)] public PlayerParamDropDash dropDash;
        [FieldOffset(2660)] public PlayerParamBounceJump bounceJump;
        [FieldOffset(2680)] public PlayerParamLightDash lightDash;
        [FieldOffset(2704)] public PlayerParamSpinDash spindash;
        [FieldOffset(2720)] public PlayerParamSpinBoost spinBoost;
        [FieldOffset(2968)] public PlayerParamFly fly;
        [FieldOffset(3032)] public PlayerParamLimitedFly limitedfly;
        [FieldOffset(3084)] public PlayerParamCyberMode cyberMode;
    }

    [StructLayout(LayoutKind.Explicit, Size = 424)]
    public struct WaterModePackage
    {
        [FieldOffset(0)]   public PlayerParamSpeed speed;
        [FieldOffset(224)] public PlayerParamJump jump;
        [FieldOffset(252)] public PlayerParamJumpSpeed jumpSpeed;
        [FieldOffset(300)] public PlayerParamDoubleJump doubleJump;
        [FieldOffset(312)] public PlayerParamBoost boost;
        [FieldOffset(372)] public PlayerParamAirBoost airboost;
    }

    [StructLayout(LayoutKind.Explicit, Size = 39392)]
    public struct Root
    {
        [FieldOffset(0)]     public CommonPackageSonic common;
        [FieldOffset(29552)] public ModePackageSonic forwardView;
        [FieldOffset(32688)] public WaterModePackage water;
        [FieldOffset(33120)] public ModePackageSonic cyberspace;
        [FieldOffset(36256)] public ModePackageSonic cyberspaceSV;
    }
}